<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="集合在我们日常开发使用的次数数不胜数，ArrayList&#x2F;LinkedList&#x2F;HashMap&#x2F;HashSet······信手拈来，抬手就拿来用，在 IDE 上龙飞凤舞，但是作为一名合格的优雅的程序猿，仅仅了解怎么使用API是远远不够的，如果在调用API时，知道它内部发生了什么事情，就像开了透视外挂一样，洞穿一切，这种感觉才真的爽，而且这样就不是集合提供什么功能给我们使用，而是我们选择使用它的什么">
<meta property="og:type" content="article">
<meta property="og:title" content="SumInOne-2-集合框架">
<meta property="og:url" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="集合在我们日常开发使用的次数数不胜数，ArrayList&#x2F;LinkedList&#x2F;HashMap&#x2F;HashSet······信手拈来，抬手就拿来用，在 IDE 上龙飞凤舞，但是作为一名合格的优雅的程序猿，仅仅了解怎么使用API是远远不够的，如果在调用API时，知道它内部发生了什么事情，就像开了透视外挂一样，洞穿一切，这种感觉才真的爽，而且这样就不是集合提供什么功能给我们使用，而是我们选择使用它的什么">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804225835079.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804225901295.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804225921489.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804225937441.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804225953903.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230014881.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230028909.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230045861.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230058332.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230116972.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230200901.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230736883.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230759606.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230848821.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804230930085.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804231015303.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804233823344.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804233858397.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234015857.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234033263.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234048371.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234100539.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234116787.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234130343.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234143071.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234155781.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234207442.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234300261.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234312965.png">
<meta property="og:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804234328376.png">
<meta property="article:published_time" content="2020-07-16T08:20:15.000Z">
<meta property="article:modified_time" content="2020-07-16T08:20:15.000Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="java容器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20200804225835079.png">

<link rel="canonical" href="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SumInOne-2-集合框架 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/old/SumInOne-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SumInOne-2-集合框架
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-16 16:20:15" itemprop="dateCreated datePublished" datetime="2020-07-16T16:20:15+08:00">2020-07-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">java容器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>集合在我们日常开发使用的次数数不胜数，<code>ArrayList</code>/<code>LinkedList</code>/<code>HashMap</code>/<code>HashSet</code>······信手拈来，抬手就拿来用，在 IDE 上龙飞凤舞，但是作为一名合格的优雅的程序猿，仅仅了解怎么使用<code>API</code>是远远不够的，如果在调用<code>API</code>时，知道它内部发生了什么事情，就像开了<code>透视</code>外挂一样，洞穿一切，这种感觉才真的爽，而且这样就<strong>不是集合提供什么功能给我们使用，而是我们选择使用它的什么功能了</strong>。</p>
<a id="more"></a>

<p><img src="image-20200804225835079.png" alt="image-20200804225835079"></p>
<h2 id="集合框架总览"><a href="#集合框架总览" class="headerlink" title="集合框架总览"></a>集合框架总览</h2><p>下图堪称集合框架的<strong>上帝视角</strong>，讲到集合框架不得不看的就是这幅图，当然，你会觉得眼花缭乱，不知如何看起，这篇文章带你一步一步地秒杀上面的每一个接口、抽象类和具体类。我们将会从最顶层的接口开始讲起，一步一步往下深入，帮助你把对集合的认知构建起一个知识网络。</p>
<p><img src="image-20200804225901295.png" alt="image-20200804225901295"></p>
<p>工欲善其事必先利其器，让我们先来过一遍整个集合框架的组成部分：</p>
<ol>
<li>集合框架提供了两个遍历接口：<code>Iterator</code>和<code>ListIterator</code>，其中后者是前者的<code>优化版</code>，支持在任意一个位置进行<strong>前后双向遍历</strong>。注意图中的<code>Collection</code>应当继承的是<code>Iterable</code>而不是<code>Iterator</code>，后面会解释<code>Iterable</code>和<code>Iterator</code>的区别</li>
<li>整个集合框架分为两个门派（类型）：<code>Collection</code>和<code>Map</code>，前者是一个容器，存储一系列的<strong>对象</strong>；后者是键值对<code>&lt;key, value&gt;</code>，存储一系列的<strong>键值对</strong></li>
<li>在集合框架体系下，衍生出四种具体的集合类型：<code>Map</code>、<code>Set</code>、<code>List</code>、<code>Queue</code></li>
<li><code>Map</code>存储<code>&lt;key,value&gt;</code>键值对，查找元素时通过<code>key</code>查找<code>value</code></li>
<li><code>Set</code>内部存储一系列<strong>不可重复</strong>的对象，且是一个<strong>无序</strong>集合，对象排列顺序不一</li>
<li><code>List</code>内部存储一系列<strong>可重复</strong>的对象，是一个<strong>有序</strong>集合，对象按插入顺序排列</li>
<li><code>Queue</code>是一个<strong>队列</strong>容器，其特性与<code>List</code>相同，但只能从<code>队头</code>和<code>队尾</code>操作元素</li>
<li>JDK 为集合的各种操作提供了两个工具类<code>Collections</code>和<code>Arrays</code>，之后会讲解工具类的常用方法</li>
<li>四种抽象集合类型内部也会衍生出许多具有不同特性的集合类，<strong>不同场景下择优使用，没有最佳的集合</strong></li>
</ol>
<p>上面了解了整个集合框架体系的组成部分，接下来的章节会严格按照上面罗列的顺序进行讲解，每一步都会有<code>承上启下</code>的作用</p>
<blockquote>
<p>学习<code>Set</code>前，最好最好要先学习<code>Map</code>，因为<code>Set</code>的操作本质上是对<code>Map</code>的操作，往下看准没错</p>
</blockquote>
<h3 id="Iterator-Iterable-ListIterator"><a href="#Iterator-Iterable-ListIterator" class="headerlink" title="Iterator  Iterable ListIterator"></a>Iterator  Iterable ListIterator</h3><p>在第一次看这两个接口，真以为是一模一样的，没发现里面有啥不同，<strong>存在即合理</strong>，它们两个还是有本质上的区别的。</p>
<p>首先来看<code>Iterator</code>接口：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>提供的API接口含义如下：</p>
<ul>
<li><code>hasNext()</code>：判断集合中是否存在下一个对象</li>
<li><code>next()</code>：返回集合中的下一个对象，并将访问指针移动一位</li>
<li><code>remove()</code>：删除集合中调用<code>next()</code>方法返回的对象</li>
</ul>
<p>在早期，遍历集合的方式只有一种，通过<code>Iterator</code>迭代器操作</p>
<pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Iterator iter <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Integer next <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> iter<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再来看<code>Iterable</code>接口：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    Iterator<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// JDK 1.8</span>
    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>T t <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到<code>Iterable</code>接口里面提供了<code>Iterator</code>接口，所以实现了<code>Iterable</code>接口的集合依旧可以使用<code>迭代器</code>遍历和操作集合中的对象；</p>
<p>而在 <code>JDK 1.8</code>中，<code>Iterable</code>提供了一个新的方法<code>forEach()</code>，它允许使用增强 for 循环遍历对象。</p>
<pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>Integer num <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们通过命令：<code>javap -c</code>反编译上面的这段代码后，发现它只是 Java 中的一个<code>语法糖</code>，本质上还是调用<code>Iterator</code>去遍历。</p>
<p><img src="image-20200804225921489.png" alt="image-20200804225921489"></p>
<p>翻译成代码，就和一开始的<code>Iterator</code>迭代器遍历方式基本相同了。</p>
<pre class="line-numbers language-java"><code class="language-java">Iterator iter <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Integer num <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>还有更深层次的探讨：为什么要设计两个接口<code>Iterable</code>和<code>Iterator</code>，而不是保留其中一个就可以了。</p>
<p>简单讲解：<code>Iterator</code>的保留可以让子类去<strong>实现自己的迭代器</strong>，而<code>Iterable</code>接口更加关注于<code>for-each</code>的增强语法。具体可参考：<a href="https://www.cnblogs.com/litexy/p/9744241.html" target="_blank" rel="noopener">Java中的Iterable与Iterator详解</a></p>
</blockquote>
<p>关于<code>Iterator</code>和<code>Iterable</code>的讲解告一段落，下面来总结一下它们的重点：</p>
<ol>
<li><code>Iterator</code>是提供集合操作内部对象的一个迭代器，它可以<strong>遍历、移除</strong>对象，且只能够<strong>单向移动</strong></li>
<li><code>Iterable</code>是对<code>Iterator</code>的封装，在<code>JDK 1.8</code>时，实现了<code>Iterable</code>接口的集合可以使用<strong>增强 for 循环</strong>遍历集合对象，我们通过<strong>反编译</strong>后发现底层还是使用<code>Iterator</code>迭代器进行遍历</li>
</ol>
<p>等等，这一章还没完，还有一个<code>ListIterator</code>。它继承 Iterator 接口，在遍历<code>List</code>集合时可以从<strong>任意索引下标</strong>开始遍历，而且支持<strong>双向遍历</strong>。</p>
<p>ListIterator 存在于 List 集合之中，通过调用方法可以返回<strong>起始下标</strong>为 <code>index</code>的迭代器</p>
<pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 返回下标为0的迭代器</span>
ListIterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> listIter1 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 返回下标为5的迭代器</span>
ListIterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> listIter2 <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ListIterator 中有几个重要方法，大多数方法与 Iterator 中定义的含义相同，但是比 Iterator 强大的地方是可以在<strong>任意一个下标位置</strong>返回该迭代器，且可以实现<strong>双向遍历</strong>。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ListIterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    E <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">previousIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 替换当前下标的元素,即访问过的最后一个元素</span>
    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Map-和-Collection-接口"><a href="#Map-和-Collection-接口" class="headerlink" title="Map 和 Collection 接口"></a>Map 和 Collection 接口</h3><p>Map 接口和 Collection 接口是集合框架体系的两大门派，Collection 是存储元素本身，而 Map 是存储<code>&lt;key, value&gt;</code>键值对，在 Collection 门派下有一小部分弟子去<code>偷师</code>，利用 Map 门派下的弟子来修炼自己。</p>
<p>是不是听的一头雾水哈哈哈，举个例子你就懂了：<code>HashSet</code>底层利用了<code>HashMap</code>，<code>TreeSet</code>底层用了<code>TreeMap</code>，<code>LinkedHashSet</code>底层用了<code>LinkedHashMap</code>。</p>
<p>下面我会详细讲到各个具体集合类哦，所以在这里，我们先从整体上了解这两个<code>门派</code>的特点和区别。</p>
<p><img src="image-20200804225937441.png" alt="image-20200804225937441"></p>
<p><code>Map</code>接口定义了存储的数据结构是<code>&lt;key, value&gt;</code>形式，根据 key 映射到 value，一个 key 对应一个 value ，所以<code>key</code>不可重复，而<code>value</code>可重复。</p>
<p>在<code>Map</code>接口下会将存储的方式细分为不同的种类：</p>
<ul>
<li><code>SortedMap</code>接口：该类映射可以对<code>&lt;key, value&gt;</code>按照自己的规则进行<strong>排序</strong>，具体实现有 TreeMap</li>
<li><code>AbsractMap</code>：它为子类提供好一些<strong>通用的API实现</strong>，所有的具体Map如<code>HashMap</code>都会继承它</li>
</ul>
<p>而<code>Collection</code>接口提供了所有集合的<strong>通用方法</strong>（注意这里不包括<code>Map</code>）：</p>
<ul>
<li>添加方法：<code>add(E e)</code> / <code>addAll(Collection&lt;? extends E&gt; var1)</code></li>
<li>删除方法：<code>remove(Object var1)</code> / <code>removeAll(Collection&lt;?&gt; var1)</code></li>
<li>查找方法：<code>contains(Object var1)</code> / <code>containsAll(Collection&lt;?&gt; var1);</code></li>
<li>查询集合自身信息：<code>size()</code> / <code>isEmpty()</code></li>
<li>···</li>
</ul>
<p>在<code>Collection</code>接口下，同样会将集合细分为不同的种类：</p>
<ul>
<li><code>Set</code>接口：一个<strong>不允许存储重复元素</strong>的<strong>无序</strong>集合，具体实现有<code>HashSet</code> / <code>TreeSet</code>···</li>
<li><code>List</code>接口：一个<strong>可存储重复元素</strong>的<strong>有序</strong>集合，具体实现有<code>ArrayList</code> / <code>LinkedList</code>···</li>
<li><code>Queue</code>接口：一个<strong>可存储重复元素</strong>的<strong>队列</strong>，具体实现有<code>PriorityQueue</code> / <code>ArrayDeque</code>···</li>
</ul>
<h2 id="Map-集合体系详解"><a href="#Map-集合体系详解" class="headerlink" title="Map 集合体系详解"></a>Map 集合体系详解</h2><p><code>Map</code>接口是由<code>&lt;key, value&gt;</code>组成的集合，由<code>key</code>映射到<strong>唯一</strong>的<code>value</code>，所以<code>Map</code>不能包含重复的<code>key</code>，每个键<strong>至多</strong>映射一个值。下图是整个 Map 集合体系的主要组成部分，我将会按照日常使用频率从高到低一一讲解。</p>
<p>不得不提的是 Map 的设计理念：<strong>定位元素</strong>的时间复杂度优化到 <code>O(1)</code></p>
<p>Map 体系下主要分为 AbstractMap 和 SortedMap两类集合</p>
<p><code>AbstractMap</code>是对 Map 接口的扩展，它定义了普通的 Map 集合具有的<strong>通用行为</strong>，可以避免子类重复编写大量相同的代码，子类继承 AbstractMap 后可以重写它的方法，<strong>实现额外的逻辑</strong>，对外提供更多的功能。</p>
<p><code>SortedMap</code> 定义了该类 Map 具有 <code>排序</code>行为，同时它在内部定义好有关排序的抽象方法，当子类实现它时，必须重写所有方法，对外提供排序功能。</p>
<p><img src="image-20200804225953903.png" alt="image-20200804225953903"></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap 是一个<strong>最通用的</strong>利用哈希表存储元素的集合，将元素放入 HashMap 时，将<code>key</code>的哈希值转换为数组的<code>索引</code>下标<strong>确定存放位置</strong>，查找时，根据<code>key</code>的哈希地址转换成数组的<code>索引</code>下标<strong>确定查找位置</strong>。</p>
<p>HashMap 底层是用数组 + 链表 + 红黑树这三种数据结构实现，它是<strong>非线程安全</strong>的集合。</p>
<p>发送哈希冲突时，HashMap 的解决方法是将相同映射地址的元素连成一条<code>链表</code>，如果链表的长度大于<code>8</code>时，且数组的长度大于<code>64</code>则会转换成<code>红黑树</code>数据结构。</p>
<p>关于 HashMap 的简要总结：</p>
<ol>
<li>它是集合中最常用的<code>Map</code>集合类型，底层由<code>数组 + 链表 + 红黑树</code>组成</li>
<li>HashMap不是线程安全的</li>
<li>插入元素时，通过计算元素的<code>哈希值</code>，通过<strong>哈希映射函数</strong>转换为<code>数组下标</code>；查找元素时，同样通过哈希映射函数得到数组下标<code>定位元素的位置</code></li>
</ol>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap 可以看作是 <code>HashMap</code> 和 <code>LinkedList</code> 的结合：它在 HashMap 的基础上添加了一条双向链表，<code>默认</code>存储各个元素的插入顺序，但由于这条双向链表，使得 LinkedHashMap 可以实现 <code>LRU</code>缓存淘汰策略，因为我们可以设置这条双向链表按照<code>元素的访问次序</code>进行排序</p>
<p><img src="image-20200804230014881.png" alt="image-20200804230014881"></p>
<p>LinkedHashMap 是 HashMap 的子类，所以它具备 HashMap 的所有特点，其次，它在 HashMap 的基础上维护了一条<code>双向链表</code>，该链表存储了<strong>所有元素</strong>，<code>默认</code>元素的顺序与插入顺序<strong>一致</strong>。若<code>accessOrder</code>属性为<code>true</code>，则遍历顺序按元素的访问次序进行排序。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 头节点</span>
<span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> head<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 尾结点</span>
<span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> tail<span class="token punctuation">;</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>利用 LinkedHashMap  可以实现 <code>LRU</code> 缓存淘汰策略，因为它提供了一个方法：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>该方法可以移除<code>最靠近链表头部</code>的一个节点，而在<code>get()</code>方法中可以看到下面这段代码，其作用是挪动结点的位置：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>只要调用了<code>get()</code>且<code>accessOrder = true</code>，则会将该节点更新到链表<code>尾部</code>，具体的逻辑在<code>afterNodeAccess()</code>中，感兴趣的可翻看源码，篇幅原因这里不再展开。</p>
<p>现在如果要实现一个<code>LRU</code>缓存策略，则需要做两件事情：</p>
<ul>
<li>指定<code>accessOrder = true</code>可以设定链表按照访问顺序排列，通过提供的构造器可以设定<code>accessOrder</code></li>
</ul>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>重写<code>removeEldestEntry()</code>方法，内部定义逻辑，通常是判断<code>容量</code>是否达到上限，若是则执行淘汰。</li>
</ul>
<p>这里就要贴出一道大厂面试必考题目：<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a>，只要跟着我的步骤，就能顺利完成这道大厂题了。</p>
<p>关于 LinkedHashMap 主要介绍两点：</p>
<ol>
<li>它底层维护了一条<code>双向链表</code>，因为继承了 HashMap，所以它也不是线程安全的</li>
<li>LinkedHashMap 可实现<code>LRU</code>缓存淘汰策略，其原理是通过设置<code>accessOrder</code>为<code>true</code>并重写<code>removeEldestEntry</code>方法定义淘汰元素时需满足的条件</li>
</ol>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap 是 <code>SortedMap</code> 的子类，所以它具有<strong>排序</strong>功能。它是基于<code>红黑树</code>数据结构实现的，每一个键值对<code>&lt;key, value&gt;</code>都是一个结点，默认情况下按照<code>key</code>自然排序，另一种是可以通过传入定制的<code>Comparator</code>进行自定义规则排序。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 按照 key 自然排序，Integer 的自然排序是升序</span>
TreeMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Object<span class="token operator">></span> naturalSort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 定制排序，按照 key 降序排序</span>
TreeMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Object<span class="token operator">></span> customSort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o2<span class="token punctuation">,</span> o1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>TreeMap 底层使用了数组+红黑树实现，所以里面的存储结构可以理解成下面这幅图哦。</p>
<p><img src="image-20200804230028909.png" alt="image-20200804230028909"></p>
<p>图中红黑树的每一个节点都是一个<code>Entry</code>，在这里为了图片的简洁性，就不标明 key 和 value 了，注意这些元素都是已经按照<code>key</code>排好序了，整个数据结构都是保持着<code>有序</code> 的状态！</p>
<p>关于<code>自然</code>排序与<code>定制</code>排序：</p>
<ul>
<li>自然排序：要求<code>key</code>必须实现<code>Comparable</code>接口。</li>
</ul>
<p>由于<code>Integer</code>类实现了 Comparable 接口，按照自然排序规则是按照<code>key</code>从小到大排序。</p>
<pre class="line-numbers language-java"><code class="language-java">TreeMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"TWO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"ONE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>treeMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// {1=ONE, 2=TWO}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>定制排序：在初始化 TreeMap 时传入新的<code>Comparator</code>，<strong>不</strong>要求<code>key</code>实现 Comparable 接口</li>
</ul>
<pre class="line-numbers language-java"><code class="language-java">TreeMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o2<span class="token punctuation">,</span> o1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"ONE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"TWO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"FOUR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"THREE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// {4=FOUR, 3=THREE, 2=TWO, 1=ONE}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过传入新的<code>Comparator</code>比较器，可以覆盖默认的排序规则，上面的代码按照<code>key</code>降序排序，在实际应用中还可以按照其它规则自定义排序。</p>
<pre><code>compare()`方法的返回值有三种，分别是：`0`，`-1`，`+1</code></pre><p>（1）如果返回<code>0</code>，代表两个元素相等，不需要调换顺序</p>
<p>（2）如果返回<code>+1</code>，代表前面的元素需要与后面的元素调换位置</p>
<p>（3）如果返回<code>-1</code>，代表前面的元素不需要与后面的元素调换位置</p>
<p>而何时返回<code>+1</code>和<code>-1</code>，则由我们自己去定义，JDK默认是按照<strong>自然排序</strong>，而我们可以根据<code>key</code>的不同去定义降序还是升序排序。</p>
<p>关于 TreeMap 主要介绍了两点：</p>
<ol>
<li>它底层是由<code>红黑树</code>这种数据结构实现的，所以操作的时间复杂度恒为<code>O(logN)</code></li>
<li>TreeMap 可以对<code>key</code>进行自然排序或者自定义排序，自定义排序时需要传入<code>Comparator</code>，而自然排序要求<code>key</code>实现了<code>Comparable</code>接口</li>
<li>TreeMap 不是线程安全的。</li>
</ol>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>WeakHashMap 日常开发中比较少见，它是基于普通的<code>Map</code>实现的，而里面<code>Entry</code>中的键在每一次的<code>垃圾回收</code>都会被清除掉，所以非常适合用于<strong>短暂访问、仅访问一次</strong>的元素，缓存在<code>WeakHashMap</code>中，并尽早地把它回收掉。</p>
<p>当<code>Entry</code>被<code>GC</code>时，WeakHashMap 是如何感知到某个元素被回收的呢？</p>
<p>在 WeakHashMap 内部维护了一个引用队列<code>queue</code></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> ReferenceQueue<span class="token operator">&lt;</span>Object<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个 queue 里包含了所有被<code>GC</code>掉的键，当JVM开启<code>GC</code>后，如果回收掉 WeakHashMap 中的 key，会将 key 放入queue 中，在<code>expungeStaleEntries()</code>中遍历 queue，把 queue 中的所有<code>key</code>拿出来，并在 WeakHashMap 中删除掉，以达到<strong>同步</strong>。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Object x<span class="token punctuation">;</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 去 WeakHashMap 中删除该键值对</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>再者，需要注意 WeakHashMap 底层存储的元素的数据结构是<code>数组 + 链表</code>，<strong>没有红黑树</strong>哦，可以换一个角度想，如果还有红黑树，那干脆直接继承 HashMap ，然后再扩展就完事了嘛，然而它并没有这样做：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeakHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以，WeakHashMap 的数据结构图我也为你准备好啦。</p>
<p><img src="image-20200804230045861.png" alt="image-20200804230045861"></p>
<p>图中被虚线标识的元素将会在下一次访问 WeakHashMap 时被删除掉，WeakHashMap 内部会做好一系列的调整工作，所以记住队列的作用就是标志那些已经被<code>GC</code>回收掉的元素。</p>
<p>关于 WeakHashMap 需要注意两点：</p>
<ol>
<li>它的键是一种<strong>弱键</strong>，放入 WeakHashMap 时，随时会被回收掉，所以不能确保某次访问元素一定存在</li>
<li>它依赖普通的<code>Map</code>进行实现，是一个非线程安全的集合</li>
<li>WeakHashMap 通常作为<strong>缓存</strong>使用，适合存储那些<strong>只需访问一次</strong>、或<strong>只需保存短暂时间</strong>的键值对</li>
</ol>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable 底层的存储结构是<code>数组 + 链表</code>，而它是一个<strong>线程安全</strong>的集合，但是因为这个线程安全，它就被淘汰掉了。</p>
<p>下面是Hashtable存储元素时的数据结构图，它只会存在数组+链表，当链表过长时，查询的效率过低，而且会长时间<strong>锁住</strong> Hashtable。</p>
<p><img src="image-20200804230058332.png" alt="image-20200804230058332"></p>
<blockquote>
<p>这幅图是否有点眼熟哈哈哈哈，本质上就是 WeakHashMap 的底层存储结构了。你千万别问为什么 WeakHashMap 不继承 Hashtable 哦，Hashtable 的<code>性能</code>在并发环境下非常差，在非并发环境下可以用<code>HashMap</code>更优。</p>
</blockquote>
<p>HashTable 本质上是 HashMap 的前辈，它被淘汰的原因也主要因为两个字：<strong>性能</strong></p>
<p>HashTable 是一个 <strong>线程安全</strong> 的 Map，它所有的方法都被加上了 <strong>synchronized</strong> 关键字，也是因为这个关键字，它注定成为了时代的弃儿。</p>
<p>HashTable 底层采用 <strong>数组+链表</strong> 存储键值对，由于被弃用，后人也没有对它进行任何改进</p>
<p>HashTable 默认长度为 <code>11</code>，负载因子为 <code>0.75F</code>，即元素个数达到数组长度的 75% 时，会进行一次扩容，每次扩容为原来数组长度的 <code>2</code> 倍</p>
<p>HashTable 所有的操作都是线程安全的。</p>
<h2 id="Collection-集合体系详解"><a href="#Collection-集合体系详解" class="headerlink" title="Collection 集合体系详解"></a>Collection 集合体系详解</h2><p>Collection 集合体系的顶层接口就是<code>Collection</code>，它规定了该集合下的一系列行为约定。</p>
<p>该集合下可以分为三大类集合：List，Set和Queue</p>
<p><code>Set</code>接口定义了该类集合<strong>不允许存储重复</strong>的元素，且任何操作时均需要通过<strong>哈希函数映射</strong>到集合内部定位元素，集合内部的元素<strong>默认</strong>是<strong>无序</strong>的。</p>
<p><code>List</code>接口定义了该类集合<strong>允许存储重复</strong>的元素，且集合内部的元素按照元素插入的顺序<strong>有序排列</strong>，可以通过<strong>索引</strong>访问元素。</p>
<p><code>Queue</code>接口定义了该类集合是以<code>队列</code>作为存储结构，所以集合内部的元素<strong>有序排列</strong>，仅可以操作<strong>头结点</strong>元素，无法访问队列中间的元素。</p>
<p>上面三个接口是<strong>最普通，最抽象</strong>的实现，而在各个集合接口内部，还会有更加具体的表现，衍生出各种不同的<strong>额外功能</strong>，使开发者能够对比各个集合的优势，<strong>择优使用</strong>。</p>
<p><img src="image-20200804230116972.png" alt="image-20200804230116972"></p>
<h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p><code>Set</code>接口继承了<code>Collection</code>接口，是一个不包括重复元素的集合，更确切地说，Set 中任意两个元素不会出现 <code>o1.equals(o2)</code>，而且 Set <strong>至多</strong>只能存储一个 <code>NULL</code> 值元素，Set 集合的组成部分可以用下面这张图概括：</p>
<p><img src="image-20200804230200901.png" alt="image-20200804230200901"></p>
<p>在 Set 集合体系中，我们需要着重关注两点：</p>
<ul>
<li>存入<strong>可变元素</strong>时，必须非常小心，因为任意时候元素状态的改变都有可能使得 Set 内部出现两个<strong>相等</strong>的元素，即 <code>o1.equals(o2) = true</code>，所以一般不要更改存入 Set 中的元素，否则将会破坏了 <code>equals()</code> 的作用！</li>
<li>Set 的最大作用就是判重，在项目中最大的作用也是<strong>判重</strong>！</li>
</ul>
<p>接下来我们去看它的实现类和子类： <code>AbstractSet</code> 和 <code>SortedSet</code></p>
<h3 id="AbstractSet-抽象类"><a href="#AbstractSet-抽象类" class="headerlink" title="AbstractSet 抽象类"></a>AbstractSet 抽象类</h3><p><code>AbstractSet</code> 是一个实现 Set 的一个抽象类，定义在这里可以将所有具体 Set 集合的<strong>相同行为</strong>在这里实现，<strong>避免子类包含大量的重复代码</strong></p>
<p>所有的 Set 也应该要有相同的 <code>hashCode()</code> 和 <code>equals()</code> 方法，所以使用抽象类把该方法重写后，子类无需关心这两个方法。</p>
<pre class="line-numbers language-Java"><code class="language-Java">public abstract class AbstractSet<E> implements Set<E> {
    // 判断两个 set 是否相等
    public boolean equals(Object o) {
        if (o == this) { // 集合本身
            return true;
        } else if (!(o instanceof Set)) { // 集合不是 set
            return false;
        } else {
            // 比较两个集合的元素是否全部相同
        }
    }
    // 计算所有元素的 hashcode 总和
    public int hashCode() { 
        int h = 0;
        Iterator i = this.iterator();
        while(i.hasNext()) {
            E obj = i.next();
            if (obj != null) {
                h += obj.hashCode();
            }
        }
        return h;
    }
}
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="SortedSet-接口"><a href="#SortedSet-接口" class="headerlink" title="SortedSet 接口"></a>SortedSet 接口</h3><p><code>SortedSet</code> 是一个接口，它在 Set 的基础上扩展了<strong>排序</strong>的行为，所以所有实现它的子类都会拥有排序功能。</p>
<pre class="line-numbers language-Java"><code class="language-Java">public interface SortedSet<E> extends Set<E> {
    // 元素的比较器,决定元素的排列顺序
    Comparator<? super E> comparator(); 
    // 获取 [var1, var2] 之间的 set
    SortedSet<E> subSet(E var1, E var2); 
    // 获取以 var1 开头的 Set
    SortedSet<E> headSet(E var1); 
    // 获取以 var1 结尾的 Set
    SortedSet<E> tailSet(E var1); 
    // 获取首个元素
    E first(); 
    // 获取最后一个元素
    E last();
}
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet 底层借助 <code>HashMap</code> 实现，我们可以观察它的多个构造方法，本质上都是 new 一个 HashMap</p>
<blockquote>
<p>这也是这篇文章为什么先讲解 Map 再讲解 Set 的原因！先学习 Map，有助于理解 Set</p>
</blockquote>
<pre class="line-numbers language-Java"><code class="language-Java">public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable {
    public HashSet() {
        this.map = new HashMap();
    }
    public HashSet(int initialCapacity, float loadFactor) {
        this.map = new HashMap(initialCapacity, loadFactor);
    }
    public HashSet(int initialCapacity) {
        this.map = new HashMap(initialCapacity);
    }
}
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以观察 <code>add()</code> 方法和<code>remove()</code>方法是如何将 HashSet 的操作嫁接到 HashMap 的。</p>
<pre class="line-numbers language-Java"><code class="language-Java">private static final Object PRESENT = new Object();

public boolean add(E e) {
    return this.map.put(e, PRESENT) == null;
}
public boolean remove(Object o) {
        return this.map.remove(o) == PRESENT;
}
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们看到 <code>PRESENT</code> 就是一个<strong>静态常量</strong>：使用 PRESENT 作为 HashMap 的 value 值，使用HashSet的开发者只需<strong>关注</strong>于需要插入的 <code>key</code>，<strong>屏蔽</strong>了 HashMap 的 <code>value</code></p>
<p><img src="image-20200804230736883.png" alt="image-20200804230736883"></p>
<p>上图可以观察到每个<code>Entry</code>的<code>value</code>都是 PRESENT 空对象，我们就不用再理会它了。</p>
<p>HashSet 在 HashMap 基础上实现，所以很多地方可以联系到 HashMap：</p>
<ul>
<li>底层数据结构：HashSet 也是采用<code>数组 + 链表 + 红黑树</code>实现</li>
<li>线程安全性：由于采用 HashMap 实现，而 HashMap 本身线程不安全，在HashSet 中没有添加额外的同步策略，所以 HashSet 也<strong>线程不安全</strong></li>
<li>存入 HashSet 的对象的状态<strong>最好不要发生变化</strong>，因为有可能改变状态后，在集合内部出现两个元素<code>o1.equals(o2)</code>，破坏了 <code>equals()</code>的语义。</li>
</ul>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet 的代码少的可怜，不信我给你我粘出来</p>
<p><img src="image-20200804230759606.png" alt="image-20200804230759606"></p>
<p>少归少，还是不能闹，<code>LinkedHashSet</code>继承了<code>HashSet</code>，我们跟随到父类 HashSet 的构造方法看看</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span> <span class="token keyword">boolean</span> dummy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现父类中 map 的实现采用<code>LinkedHashMap</code>，这里注意不是<code>HashMap</code>，而 LinkedHashMap 底层又采用 HashMap + 双向链表 实现的，所以本质上 LinkedHashSet 还是使用 HashMap 实现的。</p>
<blockquote>
<p>LinkedHashSet -&gt; LinkedHashMap -&gt; HashMap + 双向链表</p>
</blockquote>
<p><img src="image-20200804230848821.png" alt="image-20200804230848821"></p>
<p>而 LinkedHashMap 是采用 <code>HashMap</code>和<code>双向链表</code>实现的，这条双向链表中保存了元素的插入顺序。所以 LinkedHashSet 可以按照元素的插入顺序遍历元素，如果你熟悉<code>LinkedHashMap</code>，那 LinkedHashSet 也就更不在话下了。</p>
<p>关于 LinkedHashSet 需要注意几个地方：</p>
<ul>
<li>它继承了 <code>HashSet</code>，而 HashSet 默认是采用 HashMap 存储数据的，但是 LinkedHashSet 调用父类构造方法初始化 map 时是 LinkedHashMap 而不是 HashMap，这个要额外注意一下</li>
<li>由于 LinkedHashMap 不是线程安全的，且在 LinkedHashSet 中没有添加额外的同步策略，所以 LinkedHashSet 集合<strong>也不是线程安全</strong>的</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet 是基于 TreeMap 的实现，所以存储的元素是<strong>有序</strong>的，底层的数据结构是<code>数组 + 红黑树</code>。</p>
<p><img src="image-20200804230930085.png" alt="image-20200804230930085"></p>
<p>而元素的排列顺序有<code>2</code>种，和 TreeMap 相同：自然排序和定制排序，常用的构造方法已经在下面展示出来了，TreeSet 默认按照自然排序，如果需要定制排序，需要传入<code>Comparator</code>。</p>
<pre class="line-numbers language-Java"><code class="language-Java">public TreeSet() { 
    this(new TreeMap<E,Object>());
}
public TreeSet(Comparator<? super E> comparator) {
    this(new TreeMap<>(comparator));
}
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>TreeSet 应用场景有很多，像在游戏里的玩家战斗力排行榜</p>
<pre class="line-numbers language-Java"><code class="language-Java">public class Player implements Comparable<Integer> {
    public String name;
    public int score;
    @Override
    public int compareTo(Student o) {
        return Integer.compareTo(this.score, o.score);
    }
}
public static void main(String[] args) {
    Player s1 = new Player("张三", 100);
    Player s2 = new Player("李四", 90);
    Player s3 = new Player("王五", 80);
    TreeSet<Player> set = new TreeSet();
    set.add(s2); set.add(s1); set.add(s3);
    System.out.println(set);
}
// [Student{name='王五', score=80}, Student{name='李四', score=90}, Student{name='张三', score=100}]
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对 TreeSet 介绍了它的主要实现方式和应用场景，有几个值得注意的点。</p>
<ul>
<li>TreeSet 的所有操作都会转换为对 TreeMap 的操作，TreeMap 采用<strong>红黑树</strong>实现，任意操作的平均时间复杂度为 <code>O(logN)</code></li>
<li>TreeSet 是一个<strong>线程不安全</strong>的集合</li>
<li>TreeSet 常应用于对<strong>不重复</strong>的元素<strong>定制排序</strong>，例如玩家战力排行榜</li>
</ul>
<blockquote>
<p>注意:TreeSet判断元素是否重复的方法是判断compareTo()方法是否返回0，而不是调用 hashcode() 和 equals() 方法，如果返回 0 则认为集合内已经存在相同的元素，不会再加入到集合当中。</p>
</blockquote>
<h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><p>List 接口和 Set 接口齐头并进，是我们日常开发中接触的很多的一种集合类型了。整个 List 集合的组成部分如下图</p>
<p><img src="image-20200804231015303.png" alt="image-20200804231015303"></p>
<p><code>List</code> 接口直接继承 Collection 接口，它定义为可以存储<strong>重复</strong>元素的集合，并且元素按照插入顺序<strong>有序排列</strong>，且可以通过<strong>索引</strong>访问指定位置的元素。常见的实现有：ArrayList、LinkedList、Vector和Stack</p>
<h3 id="AbstractList-和-AbstractSequentialList"><a href="#AbstractList-和-AbstractSequentialList" class="headerlink" title="AbstractList  和 AbstractSequentialList"></a>AbstractList  和 AbstractSequentialList</h3><p>AbstractList 抽象类实现了 List 接口，其内部实现了所有的 List 都需具备的功能，子类可以专注于实现自己具体的操作逻辑。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 查找元素 o 第一次出现的索引位置</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 查找元素 o 最后一次出现的索引位置</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//···</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>AbstractSequentialList 抽象类继承了 AbstractList，在原基础上限制了访问元素的顺序<strong>只能够按照顺序访问</strong>，而<strong>不支持随机访问</strong>，如果需要满足随机访问的特性，则继承 AbstractList。子类 LinkedList 使用链表实现，所以仅能支持<strong>顺序访问</strong>，顾继承了 <code>AbstractSequentialList</code>而不是 AbstractList。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p><img src="image-20200804233823344.png" alt="image-20200804233823344"></p>
<p><code>Vector</code> 在现在已经是一种过时的集合了，包括继承它的 <code>Stack</code> 集合也如此，它们被淘汰的原因都是因为<strong>性能</strong>低下。</p>
<blockquote>
<p>JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的<strong>每个操作</strong>都被 <strong>synchronized</strong> 关键字修饰，即使在线程安全的情况下，仍然<strong>进行无意义的加锁与释放锁</strong>，造成额外的性能开销，做了无用功。</p>
</blockquote>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 JDK 1.2 时，Collection 家族出现了，它提供了大量<strong>高性能、适用於不同场合</strong>的集合，而 Vector 也是其中一员，但由于 Vector 在每个方法上都加了锁，由于需要兼容许多老的项目，很难在此基础上优化<code>Vector</code>了，所以渐渐地也就被历史淘汰了。</p>
<p>现在，在<strong>线程安全</strong>的情况下，不需要选用 Vector 集合，取而代之的是 <strong>ArrayList</strong> 集合；在并发环境下，出现了 <code>CopyOnWriteArrayList</code>，Vector 完全被弃用了。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><img src="image-20200804233858397.png" alt="image-20200804233858397"></p>
<p><code>Stack</code>是一种<code>后入先出（LIFO）</code>型的集合容器，如图中所示，<code>大雄</code>是最后一个进入容器的，top指针指向大雄，那么弹出元素时，大雄也是第一个被弹出去的。</p>
<p>Stack 继承了 Vector 类，提供了栈顶的压入元素操作（push）和弹出元素操作（pop），以及查看栈顶元素的方法（peek）等等，但由于继承了 Vector，正所谓跟错老大没福报，Stack 也渐渐被淘汰了。</p>
<p>取而代之的是后起之秀 <code>Deque</code>接口，其实现有 <code>ArrayDeque</code>，该数据结构更加完善、可靠性更好，依靠队列也可以实现<code>LIFO</code>的栈操作，所以优先选择 ArrayDeque 实现栈。</p>
<pre class="line-numbers language-java"><code class="language-java">Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>ArrayDeque 的数据结构是：<code>数组</code>，并提供<strong>头尾指针下标</strong>对数组元素进行操作。本文也会讲到哦，客官请继续往下看，莫着急！:smile:</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 以<strong>数组</strong>作为存储结构，它是<strong>线程不安全</strong>的集合；具有<strong>查询快、在数组中间或头部增删慢</strong>的特点，所以它除了线程不安全这一点，其余可以替代<code>Vector</code>，而且线程安全的 ArrayList 可以使用 <code>CopyOnWriteArrayList</code>代替 Vector。</p>
<p><img src="image-20200804234015857.png" alt="image-20200804234015857"></p>
<p>关于 ArrayList 有几个重要的点需要注意的：</p>
<ul>
<li>具备<strong>随机访问</strong>特点，<strong>访问元素的效率</strong>较高，ArrayList 在<strong>频繁插入、删除</strong>集合元素的场景下效率较<code>低</code>。</li>
<li>底层数据结构：ArrayList 底层使用数组作为存储结构，具备<strong>查找快、增删慢</strong>的特点</li>
<li>线程安全性：ArrayList 是<strong>线程不安全</strong>的集合</li>
<li>ArrayList <strong>首次扩容</strong>后的长度为 <code>10</code>，调用 <code>add()</code> 时需要计算容器的最小容量。可以看到如果数组<code>elementData</code>为空数组，会将最小容量设置为<code>10</code>，之后会将数组长度完成首次扩容到 10。</li>
</ul>
<pre class="line-numbers language-Java"><code class="language-Java">// new ArrayList 时的默认空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
// 默认容量
private static final int DEFAULT_CAPACITY = 10;
// 计算该容器应该满足的最小容量
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>集合从<strong>第二次扩容</strong>开始，数组长度将扩容为原来的 <code>1.5</code> 倍，即：<code>newLength = oldLength * 1.5</code></li>
</ul>
<p><img src="image-20200804234033263.png" alt="image-20200804234033263"></p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 底层采用<code>双向链表</code>数据结构存储元素，由于链表的内存地址<code>非连续</code>，所以它不具备随机访问的特点，但由于它利用指针连接各个元素，所以插入、删除元素只需要<code>操作指针</code>，不需要<code>移动元素</code>，故具有<strong>增删快、查询慢</strong>的特点。它也是一个非线程安全的集合。</p>
<p><img src="image-20200804234048371.png" alt="image-20200804234048371"></p>
<p>由于以双向链表作为数据结构，它是<strong>线程不安全</strong>的集合；存储的每个节点称为一个<code>Node</code>，下图可以看到 Node 中保存了<code>next</code>和<code>prev</code>指针，<code>item</code>是该节点的值。在插入和删除时，时间复杂度都保持为 <code>O(1)</code></p>
<p><img src="image-20200804234100539.png" alt="image-20200804234100539"></p>
<p>关于 LinkedList，除了它是以链表实现的集合外，还有一些特殊的特性需要注意的。</p>
<ul>
<li>优势：LinkedList 底层没有<code>扩容机制</code>，使用<code>双向链表</code>存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景</li>
<li>劣势：LinkedList 不具备<code>随机访问</code>的特点，查找某个元素只能从 <code>head</code> 或 <code>tail</code> 指针一个一个比较，所以<strong>查找中间的元素时效率很低</strong></li>
<li>查找优化：LinkedList 查找某个下标 <code>index</code> 的元素时<strong>做了优化</strong>，若 <code>index &gt; (size / 2)</code>，则从 <code>head</code> 往后查找，否则从 <code>tail</code> 开始往前查找，代码如下所示：</li>
</ul>
<pre class="line-numbers language-Java"><code class="language-Java">LinkedList.Node<E> node(int index) {
    LinkedList.Node x;
    int i;
    if (index < this.size >> 1) { // 查找的下标处于链表前半部分则从头找
        x = this.first;
        for(i = 0; i < index; ++i) { x = x.next; }
        return x;
    } else { // 查找的下标处于数组的后半部分则从尾开始找
        x = this.last;
        for(i = this.size - 1; i > index; --i) { x = x.prev; }
        return x;
    }
}
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>双端队列：使用双端链表实现，并且实现了 <code>Deque</code> 接口，使得 LinkedList 可以用作<strong>双端队列</strong>。下图可以看到 Node 是集合中的元素，提供了前驱指针和后继指针，还提供了一系列操作<code>头结点</code>和<code>尾结点</code>的方法，具有双端队列的特性。</li>
</ul>
<p><img src="image-20200804234116787.png" alt="image-20200804234116787"></p>
<p>LinkedList 集合最让人树枝的是它的链表结构，但是我们同时也要注意它是一个双端队列型的集合。</p>
<pre class="line-numbers language-java"><code class="language-java">Deque<span class="token operator">&lt;</span>Object<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p><code>Queue</code>队列，在 JDK 中有两种不同类型的集合实现：<strong>单向队列</strong>（AbstractQueue） 和 <strong>双端队列</strong>（Deque）</p>
<p><img src="image-20200804234130343.png" alt="image-20200804234130343"></p>
<p>Queue 中提供了两套增加、删除元素的 API，当插入或删除元素失败时，会有<strong>两种不同的失败处理策略</strong>。</p>
<table>
<thead>
<tr>
<th>方法及失败策略</th>
<th>插入方法</th>
<th>删除方法</th>
<th>查找方法</th>
</tr>
</thead>
<tbody><tr>
<td>抛出异常</td>
<td>add()</td>
<td>remove()</td>
<td>get()</td>
</tr>
<tr>
<td>返回失败默认值</td>
<td>offer()</td>
<td>poll()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p>选取哪种方法的决定因素：插入和删除元素失败时，希望<code>抛出异常</code>还是返回<code>布尔值</code></p>
<p><code>add()</code> 和 <code>offer()</code> 对比：</p>
<p>在队列长度大小确定的场景下，队列放满元素后，添加下一个元素时，add() 会抛出 <code>IllegalStateException</code>异常，而 <code>offer()</code> 会返回 <code>false</code> 。</p>
<p>但是它们两个方法在插入<strong>某些不合法的元素</strong>时都会抛出三个相同的异常。</p>
<p><img src="image-20200804234143071.png" alt="image-20200804234143071"></p>
<p><code>remove()</code> 和 <code>poll()</code> 对比：</p>
<p>在<strong>队列为空</strong>的场景下， <code>remove()</code> 会抛出 <code>NoSuchElementException</code>异常，而 <code>poll()</code> 则返回 <code>null</code> 。</p>
<p><code>get()</code>和<code>peek()</code>对比：</p>
<p>在队列为空的情况下，<code>get()</code>会抛出<code>NoSuchElementException</code>异常，而<code>peek()</code>则返回<code>null</code>。</p>
<h3 id="Deque-接口"><a href="#Deque-接口" class="headerlink" title="Deque 接口"></a>Deque 接口</h3><p><code>Deque</code> 接口的实现非常好理解：从<strong>单向</strong>队列演变为<strong>双向</strong>队列，内部额外提供<strong>双向队列的操作方法</strong>即可：</p>
<p><img src="image-20200804234155781.png" alt="image-20200804234155781"></p>
<p>Deque 接口额外提供了<strong>针对队列的头结点和尾结点</strong>操作的方法，而<strong>插入、删除方法同样也提供了两套不同的失败策略</strong>。除了<code>add()</code>和<code>offer()</code>，<code>remove()</code>和<code>poll()</code>以外，还有<code>get()</code>和<code>peek()</code>出现了不同的策略</p>
<h3 id="AbstractQueue-抽象类"><a href="#AbstractQueue-抽象类" class="headerlink" title="AbstractQueue 抽象类"></a>AbstractQueue 抽象类</h3><p>AbstractQueue 类中提供了各个 API 的基本实现，主要针对各个不同的处理策略给出基本的方法实现，定义在这里的作用是让<code>子类</code>根据其<code>方法规范</code>（操作失败时抛出异常还是返回默认值）实现具体的业务逻辑。</p>
<p><img src="image-20200804234207442.png" alt="image-20200804234207442"></p>
<h3 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 在上面已经详细解释了，它实现了 <code>Deque</code> 接口，提供了针对头结点和尾结点的操作，并且每个结点都有<strong>前驱</strong>和<strong>后继</strong>指针，具备了双向队列的所有特性。</p>
<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>使用<strong>数组</strong>实现的双端队列，它是<strong>无界</strong>的双端队列，最小的容量是<code>8</code>（JDK 1.8）。在 JDK 11 看到它默认容量已经是 <code>16</code>了。</p>
<p><img src="image-20200804234300261.png" alt="image-20200804234300261"></p>
<p><code>ArrayDeque</code> 在日常使用得不多，值得注意的是它与 <code>LinkedList</code> 的对比：<code>LinkedList</code> 采用<strong>链表</strong>实现双端队列，而 <code>ArrayDeque</code> 使用<strong>数组</strong>实现双端队列。</p>
<blockquote>
<p>在文档中作者写到：<strong>ArrayDeque 作为栈时比 Stack 性能好，作为队列时比 LinkedList 性能好</strong></p>
</blockquote>
<p>由于双端队列<strong>只能在头部和尾部</strong>操作元素，所以删除元素和插入元素的时间复杂度大部分都稳定在 <code>O(1)</code> ，除非在扩容时会涉及到元素的批量复制操作。但是在大多数情况下，使用它时应该指定一个大概的数组长度，避免频繁的扩容。</p>
<blockquote>
<p>个人观点：链表的插入、删除操作涉及到<strong>指针的操作，我个人认为作者是觉得数组下标的移动要比指针的操作要廉价，而且数组</strong>采用<strong>连续</strong>的内存地址空间，而<strong>链表</strong>元素的内存地址是<strong>不连续</strong>的，所以数组操作元素的效率在<strong>寻址上</strong>会比链表要快。请批判看待观点。</p>
</blockquote>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue 基于<strong>优先级堆实现</strong>的优先级队列，而堆是采用<strong>数组</strong>实现：</p>
<p><img src="image-20200804234312965.png" alt="image-20200804234312965"></p>
<p>文档中的描述告诉我们：该数组中的元素通过传入 <code>Comparator</code> 进行定制排序，如果不传入<code>Comparator</code>时，则按照元素本身<code>自然排序</code>，但要求元素实现了<code>Comparable</code>接口，所以 PriorityQueue <strong>不允许存储 NULL 元素</strong>。</p>
<p>PriorityQueue 应用场景：元素本身具有优先级，需要按照<strong>优先级处理元素</strong></p>
<ul>
<li>例如游戏中的VIP玩家与普通玩家，VIP 等级越高的玩家越先安排进入服务器玩耍，减少玩家流失。</li>
</ul>
<pre class="line-numbers language-Java"><code class="language-Java">public static void main(String[] args) {
    Student vip1 = new Student("张三", 1);
    Student vip3 = new Student("洪七", 2);
    Student vip4 = new Student("老八", 4);
    Student vip2 = new Student("李四", 1);
    Student normal1 = new Student("王五", 0);
    Student normal2 = new Student("赵六", 0);
    // 根据玩家的 VIP 等级进行降序排序
    PriorityQueue<Student> queue = new PriorityQueue<>((o1, o2) ->  o2.getScore().compareTo(o1.getScore()));
    queue.add(vip1);queue.add(vip4);queue.add(vip3);
    queue.add(normal1);queue.add(normal2);queue.add(vip2);
    while (!queue.isEmpty()) {
        Student s1 = queue.poll();
        System.out.println(s1.getName() + "进入游戏; " + "VIP等级: " + s1.getScore());
    }
}
 public static class Student implements Comparable<Student> {
     private String name;
     private Integer score;
     public Student(String name, Integer score) {
         this.name = name;
         this.score = score;
     }
     @Override
     public int compareTo(Student o) {
         return this.score.compareTo(o.getScore());
     }
 }
复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行上面的代码可以得到下面这种有趣的结果，可以看到<code>氪金</code>使人带来快乐。</p>
<p><img src="image-20200804234328376.png" alt="image-20200804234328376"></p>
<p>VIP 等级越高（优先级越高）就越优先安排进入游戏（优先处理），类似这种有优先级的场景还有非常多，各位可以发挥自己的想象力。</p>
<p>PriorityQueue 总结：</p>
<ul>
<li>PriorityQueue 是基于<strong>优先级堆</strong>实现的优先级队列，而堆是用<strong>数组</strong>维护的</li>
<li>PriorityQueue 适用于<strong>元素按优先级处理</strong>的业务场景，例如用户在请求人工客服需要排队时，根据用户的<strong>VIP等级</strong>进行 <code>插队</code> 处理，等级越高，越先安排客服。</li>
</ul>
<p>章节结束各集合总结：（以 JDK1.8 为例）</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>插入、删除时间复杂度</th>
<th>查询时间复杂度</th>
<th>底层数据结构</th>
<th>是否线程安全</th>
</tr>
</thead>
<tbody><tr>
<td>Vector</td>
<td>O(N)</td>
<td>O(1)</td>
<td>数组</td>
<td>是（已淘汰）</td>
</tr>
<tr>
<td>ArrayList</td>
<td>O(N)</td>
<td>O(1)</td>
<td>数组</td>
<td>否</td>
</tr>
<tr>
<td>LinkedList</td>
<td>O(1)</td>
<td>O(N)</td>
<td>双向链表</td>
<td>否</td>
</tr>
<tr>
<td>HashSet</td>
<td>O(1)</td>
<td>O(1)</td>
<td>数组+链表+红黑树</td>
<td>否</td>
</tr>
<tr>
<td>TreeSet</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>红黑树</td>
<td>否</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>O(1)</td>
<td>O(1)~O(N)</td>
<td>数组 + 链表 + 红黑树</td>
<td>否</td>
</tr>
<tr>
<td>ArrayDeque</td>
<td>O(N)</td>
<td>O(1)</td>
<td>数组</td>
<td>否</td>
</tr>
<tr>
<td>PriorityQueue</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>堆（数组实现）</td>
<td>否</td>
</tr>
<tr>
<td>HashMap</td>
<td>O(1) ~ O(N)</td>
<td>O(1) ~ O(N)</td>
<td>数组+链表+红黑树</td>
<td>否</td>
</tr>
<tr>
<td>TreeMap</td>
<td>O(logN)</td>
<td>O(logN)</td>
<td>数组+红黑树</td>
<td>否</td>
</tr>
<tr>
<td>HashTable</td>
<td>O(1) / O(N)</td>
<td>O(1) / O(N)</td>
<td>数组+链表</td>
<td>是（已淘汰）</td>
</tr>
</tbody></table>
<h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>这一篇文章对各个集合都有些<code>点到即止</code>的味道，此文的目的是对整个集合框架有一个较为整体的了解，分析了最常用的集合的相关特性，以及某些特殊集合的应用场景例如<code>TreeSet</code>、<code>TreeMap</code>这种可定制排序的集合。</p>
<ul>
<li><code>Collection</code> 接口提供了整个集合框架<strong>最通用</strong>的增删改查以及集合自身操作的抽象方法，让子类去实现</li>
<li><code>Set</code> 接口决定了它的子类都是<strong>无序、无重复元素</strong>的集合，其主要实现有HashSet、TreeSet、LinkedHashSet。<ul>
<li><code>HashSet</code> 底层采用 <code>HashMap</code> 实现，而 <code>TreeSet</code> 底层使用 <code>TreeMap</code> 实现，大部分 Set 集合的操作都会转换为 Map 的操作，TreeSet 可以将元素按照规则进行<strong>排序</strong>。</li>
</ul>
</li>
<li><code>List</code> 接口决定了它的子类都是<strong>有序、可存储重复元素</strong>的集合，常见的实现有 ArrayList，LinkedList，Vector<ul>
<li><code>ArrayList</code> 使用<strong>数组</strong>实现，而 LinkedList 使用<strong>链表</strong>实现，所以它们两个的使用场景几乎是相反的，<strong>频繁查询</strong>的场景使用 ArrayList，而<strong>频繁插入删除</strong>的场景最好使用 LinkedList</li>
<li><code>LinkedList</code> 和 <code>ArrayDeque</code> 都可用于<strong>双端队列</strong>，而 <em>Josh Bloch and Doug Lea</em> 认为 <code>ArrayDeque</code> 具有比 <code>LinkedList</code> 更好的性能，<code>ArrayDeque</code>使用<strong>数组</strong>实现双端队列，<code>LinkedList</code>使用<strong>链表</strong>实现双端队列。</li>
</ul>
</li>
<li><code>Queue</code> 接口定义了队列的基本操作，子类集合都会拥有队列的特性：<strong>先进先出</strong>，主要实现有：LinkedList，ArrayDeque<ul>
<li><code>PriorityQueue</code> 底层使用<strong>二叉堆</strong>维护的优先级队列，而二叉堆是由<strong>数组</strong>实现的，它可以按照元素的优先级进行排序，<strong>优先级越高的元素，排在队列前面，优先被弹出处理</strong>。</li>
</ul>
</li>
<li><code>Map</code>接口定义了该种集合类型是以<code>&lt;key,value&gt;</code>键值对形式保存，其主要实现有：HashMap，TreeMap，LinkedHashMap，Hashtable<ul>
<li>LinkedHashMap 底层多加了一条双向链表，设置<code>accessOrder</code>为<code>true</code>并重写方法则可以实现<code>LRU</code>缓存</li>
<li>TreeMap 底层采用数组+红黑树实现，集合内的元素默认按照自然排序，也可以传入<code>Comparator</code>定制排序</li>
</ul>
</li>
</ul>
<p>看到这里非常不容易，感谢你愿意阅读我的文章，希望能对你有所帮助，你可以参考着文末总结的顺序，每当我提到一个集合时，回想它的重要知识点是什么，主要就是<code>底层数据结构</code>，<code>线程安全性</code>，<code>该集合的一两个特有性质</code>，只要能够回答出来个大概，我相信之后运用这些数据结构，你能够熟能生巧。</p>
<p>本文对整个集合体系的所有常用的集合类都分析了，这里并没有对集合内部的实现深入剖析，我想先从最宏观的角度让大家了解每个集合的的作用，应用场景，以及简单的对比，之后会抽时间对常见的集合进行源码剖析，尽情期待，感谢阅读！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E5%AE%B9%E5%99%A8/" rel="tag"># java容器</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/03/old/SumInOne-1-SpringCore/" rel="prev" title="SumInOne#1-SpringCore">
      <i class="fa fa-chevron-left"></i> SumInOne#1-SpringCore
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/17/old/%E9%81%97%E6%BC%8F%E7%9A%84%E5%AE%B9%E5%99%A8%E2%80%94WeakHashMap/" rel="next" title="遗漏的容器—WeakHashMap">
      遗漏的容器—WeakHashMap <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#集合框架总览"><span class="nav-text">集合框架总览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator-Iterable-ListIterator"><span class="nav-text">Iterator  Iterable ListIterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-和-Collection-接口"><span class="nav-text">Map 和 Collection 接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-集合体系详解"><span class="nav-text">Map 集合体系详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap"><span class="nav-text">LinkedHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakHashMap"><span class="nav-text">WeakHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hashtable"><span class="nav-text">Hashtable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection-集合体系详解"><span class="nav-text">Collection 集合体系详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-接口"><span class="nav-text">Set 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractSet-抽象类"><span class="nav-text">AbstractSet 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SortedSet-接口"><span class="nav-text">SortedSet 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet"><span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashSet"><span class="nav-text">LinkedHashSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet"><span class="nav-text">TreeSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List-接口"><span class="nav-text">List 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractList-和-AbstractSequentialList"><span class="nav-text">AbstractList  和 AbstractSequentialList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vector"><span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack"><span class="nav-text">Stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList"><span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList"><span class="nav-text">LinkedList</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue接口"><span class="nav-text">Queue接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Deque-接口"><span class="nav-text">Deque 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractQueue-抽象类"><span class="nav-text">AbstractQueue 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList-1"><span class="nav-text">LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayDeque"><span class="nav-text">ArrayDeque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityQueue"><span class="nav-text">PriorityQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文末总结"><span class="nav-text">文末总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">261</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">142</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
