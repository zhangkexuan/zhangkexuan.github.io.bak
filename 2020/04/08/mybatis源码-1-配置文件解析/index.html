<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="我们在使用 MyBatis 框架时,通常会进行一定的设置,使其能更好的满足我们的需求。对于一个框架来说,提供较为丰富的配置文件,也是其灵活性的体现。本章将会介绍 MyBatis 配置文件中的大部分节点解析过程,包含但不限于 properties、settings、typeAliase、typeHandlers 等.">
<meta property="og:type" content="article">
<meta property="og:title" content="mybatis源码#1-配置文件解析">
<meta property="og:url" content="http://yoursite.com/2020/04/08/mybatis%E6%BA%90%E7%A0%81-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="我们在使用 MyBatis 框架时,通常会进行一定的设置,使其能更好的满足我们的需求。对于一个框架来说,提供较为丰富的配置文件,也是其灵活性的体现。本章将会介绍 MyBatis 配置文件中的大部分节点解析过程,包含但不限于 properties、settings、typeAliase、typeHandlers 等.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/04/08/mybatis%E6%BA%90%E7%A0%81-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/1586596943749.png">
<meta property="og:image" content="http://yoursite.com/2020/04/08/mybatis%E6%BA%90%E7%A0%81-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/1586596547775.png">
<meta property="article:published_time" content="2020-04-08T09:23:25.000Z">
<meta property="article:modified_time" content="2021-05-19T02:14:35.221Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="java">
<meta property="article:tag" content="mybatis">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/04/08/mybatis%E6%BA%90%E7%A0%81-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/1586596943749.png">

<link rel="canonical" href="http://yoursite.com/2020/04/08/mybatis%E6%BA%90%E7%A0%81-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>mybatis源码#1-配置文件解析 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/mybatis%E6%BA%90%E7%A0%81-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mybatis源码#1-配置文件解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 17:23:25" itemprop="dateCreated datePublished" datetime="2020-04-08T17:23:25+08:00">2020-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>我们在使用 MyBatis 框架时,通常会进行一定的设置,使其能更好的满足我们的需求。对于一个框架来说,提供较为丰富的配置文件,也是其灵活性的体现。本章将会介绍 MyBatis 配置文件中的大部分节点解析过程,包含但不限于 <code>properties</code>、<code>settings</code>、<code>typeAliase</code>、<code>typeHandlers</code> 等.</p>
<span id="more"></span>

<h1 id="配置文件解析过程分析"><a href="#配置文件解析过程分析" class="headerlink" title="配置文件解析过程分析"></a>配置文件解析过程分析</h1><p>我们在使用 MyBatis 时,第一步要做的事情一般是根据配置文件构建 <code>SqlSessionFactory</code>对象。相关代码大致如下:</p>
<pre><code class="java">String resource = &quot;mybatis-config.xml&quot;;
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory =
    new SqlSessionFactoryBuilder().build(inputStream);
</code></pre>
<p>在上面代码中,我们首先会使用 MyBatis 提供的工具类 <code>Resources</code> 加载配置文件,得到一个输入流。然后再通过 <code>SqlSessionFactoryBuilder</code> 对象的 <code>build</code> 方法构建<code>SqlSessionFactory</code>对象。这里的 build 方法是我们分析配置文件解析过程的入口方法。下面我们来看一下这个方法的代码:</p>
<pre><code class="java">// -☆- SqlSessionFactoryBuilder
public SqlSessionFactory build(InputStream inputStream) &#123;
    // 调用重载方法
    return build(inputStream, null, null);
&#125;
public SqlSessionFactory build(InputStream inputStream, String environment,
                               Properties properties) &#123;
    try &#123;
        // 创建配置文件解析器
        XMLConfigBuilder parser =
            new XMLConfigBuilder(inputStream, environment, properties);
        // 调用 parse 方法解析配置文件,生成 Configuration 对象
        return build(parser.parse());
    &#125; catch (Exception e) &#123;
        throw ExceptionFactory.wrapException(&quot;......&quot;, e);
    &#125; finally &#123;
        ErrorContext.instance().reset();
        try &#123;
            inputStream.close();
        &#125; catch (IOException e) &#123;......&#125;
    &#125;
&#125;
public SqlSessionFactory build(Configuration config) &#123;
    // 创建 DefaultSqlSessionFactory
    return new DefaultSqlSessionFactory(config);
&#125;
</code></pre>
<p>从上面的代码中,我们大致可以猜出 MyBatis 配置文件是通过 <code>XMLConfigBuilder</code> 进行解析的。不过目前这里还没有非常明确的解析逻辑,所以我们继续往下看。这次来看一下<code>XMLConfigBuilder</code> 的 <code>parse</code> 方法,如下:</p>
<pre><code class="java">// -☆- XMLConfigBuilder
public Configuration parse() &#123;
    if (parsed) &#123;
        throw new BuilderException(&quot;......&quot;);
    &#125;   
    parsed = true;
    // 解析配置
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    return configuration;
&#125;
</code></pre>
<p>到这里大家可以看到一些端倪了,注意一个 <code>xpath</code> 表达式—— <code>/configuration</code>。这个表达式代表的是 MyBatis 配置文件的 <code>&lt;configuration&gt;</code> 节点,这里通过 <code>xpath</code> 选中这个节点,并传递给 <code>parseConfiguration</code> 方法。我们继续跟下去。</p>
<pre><code class="java">private void parseConfiguration(XNode root) &#123;
    try &#123;
        // 解析 properties 配置
        propertiesElement(root.evalNode(&quot;properties&quot;));
        // 解析 settings 配置,并将其转换为 Properties 对象
        Properties settings =
            settingsAsProperties(root.evalNode(&quot;settings&quot;));
        // 加载 vfs
        loadCustomVfs(settings);
        // 解析 typeAliases 配置
        typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
        atch// 解析 plugins 配置
            pluginElement(root.evalNode(&quot;plugins&quot;));
        // 解析 objectFactory 配置
        objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
        // 解析 objectWrapperFactory 配置
        objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
        // 解析 reflectorFactory 配置
        reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
        // settings 中的信息设置到 Configuration 对象中
        settingsElement(settings);
        // 解析 environments 配置
        environmentsElement(root.evalNode(&quot;environments&quot;));
        // 解析 databaseIdProvider,获取并设置 databaseId 到 Configuration 对象
        databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
        // 解析 typeHandlers 配置
        typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
        // 解析 mappers 配置
        mapperElement(root.evalNode(&quot;mappers&quot;));
    &#125;catch(Exception e)&#123;
        throw new BuilderException(&quot;...&quot;);
    &#125;
&#125;
</code></pre>
<p>到此,一个完整的配置解析过程就呈现出来了,每个节点的的解析逻辑均封装在了相应的方法中。我在分析这些方法时,并不会按照上面代码中所呈现的解析顺序进行分析,而是做了一定的调整。</p>
<h2 id="解析-lt-properties-gt-节点"><a href="#解析-lt-properties-gt-节点" class="headerlink" title="解析&lt;properties&gt;节点"></a>解析<code>&lt;properties&gt;</code>节点</h2><p>&lt;properties&gt;节点的解析工作由 <code>propertiesElement</code> 这个方法完成的,在分析方法的源码前,我们先来看一下&lt;properties&gt;节点是如何配置的。如下:</p>
<pre><code class="XML">&lt;properties resource=&quot;jdbc.properties&quot;&gt;
    &lt;property name=&quot;jdbc.username&quot; value=&quot;coolblog&quot;/&gt;
    &lt;property name=&quot;hello&quot; value=&quot;world&quot;/&gt;
&lt;/properties&gt;
</code></pre>
<p>上面配置包含了一个 <code>resource</code> 属性,和两个子节点。接下面,我们参照上面的配置,来分析 <code>propertiesElement</code> 方法的逻辑。如下:</p>
<pre><code class="java">// -☆- XMLConfigBuilder
private void propertiesElement(XNode context) throws Exception &#123;
    if (context != null) &#123;
        // 解析 propertis 的子节点,并将这些节点内容转换为属性对象 Properties
        Properties defaults = context.getChildrenAsProperties();
        // 获取 propertis 节点中的 resource 和 url 属性值
        String resource = context.getStringAttribute(&quot;resource&quot;);
        String url = context.getStringAttribute(&quot;url&quot;);
        // 两者都不用空,则抛出异常
        if (resource != null &amp;&amp; url != null) &#123;
            throw new BuilderException(&quot;...&quot;);
        &#125;
        if (resource != null) &#123;
            // 从文件系统中加载并解析属性文件
            defaults.putAll(Resources.getResourceAsProperties(resource));
        &#125; else if (url != null) &#123;
            // 通过 url 加载并解析属性文件
            defaults.putAll(Resources.getUrlAsProperties(url));
        &#125;
        Properties vars = configuration.getVariables();
        if (vars != null) &#123;
            defaults.putAll(vars);
        &#125;
        parser.setVariables(defaults);
        // 将属性值设置到 configuration 中
        configuration.setVariables(defaults);
    &#125;
&#125;
</code></pre>
<p>跟进一下<code>getChildrenAsProperties</code> 有：</p>
<pre><code class="java">public Properties getChildrenAsProperties() &#123;
    Properties properties = new Properties();
    // 获取并遍历子节点
    for (XNode child : getChildren()) &#123;
        // 获取 property 节点的 name 和 value 属性
        String name = child.getStringAttribute(&quot;name&quot;);
        String value = child.getStringAttribute(&quot;value&quot;);
        if (name != null &amp;&amp; value != null) &#123;
            // 设置属性到属性对象中
            properties.setProperty(name, value);
        &#125;
    &#125;
    return properties;
&#125;
</code></pre>
<p><code>getChildren</code>再跟进：</p>
<pre><code class="java">// -☆- XNode
public List&lt;XNode&gt; getChildren() &#123;
    List&lt;XNode&gt; children = new ArrayList&lt;XNode&gt;();
    // 获取子节点列表
    NodeList nodeList = node.getChildNodes();
    if (nodeList != null) &#123;
        for (int i = 0, n = nodeList.getLength(); i &lt; n; i++) &#123;
            Node node = nodeList.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) &#123;
                // 将节点对象封装到 XNode 中,并将 XNode 对象放入 children 列表中
                children.add(new XNode(xpathParser, node, variables));
            &#125;
        &#125;
    &#125;
    return children;
&#125;
</code></pre>
<p>上面就是<code>&lt;properties&gt;</code>节点解析过程,不是很复杂。主要包含三个步骤,一是解析<code>&lt;properties&gt;</code>节点的子节点,并将解析结果设置到 <code>Properties</code> 对象中。二是从文件系统或通过网络读取属性配置,这取决于<code>&lt;properties&gt;</code>节点的 <code>resource</code> 和 <code>url</code> 是否为空。第二步对应的代码比较简单,这里就不分析了。最后一步则是将包含属性信息的<code>Properties</code> 对象设置到<code>XPathParser</code> 和 <code>Configuration</code> 中。</p>
<p>需要注意的是,<code>propertiesElement</code> 方法是先解析<code>&lt;properties&gt;</code>节点的子节点内容,然后再从文件系统或者网络读取属性配置, 并将所有的属性及属性值都放入到 <code>defaults</code> 属性对象中。</p>
<p><strong>这会导致同名属性覆盖的问题,也就是从文件系统,或者网络上读取到的属性和属性值会覆盖掉<code>&lt;properties&gt;</code>子节点中同名的属性和及值。</strong></p>
<h2 id="解析-lt-settings-gt-节点"><a href="#解析-lt-settings-gt-节点" class="headerlink" title="解析&lt;settings&gt;节点"></a>解析<code>&lt;settings&gt;</code>节点</h2><p><code>&lt;settings&gt;</code>相关配置是 MyBatis 中非常重要的配置,这些配置用于调整 MyBatis 运行时的行为。<code>settings</code> 配置繁多,在对这些配置不熟悉的情况下,保持默认配置即可。关于<code>&lt;settings&gt;</code>相关配置,MyBatis 官网上进行了比较详细的描述,大家可以去了解一下。在本节中,暂时还用不到这些配置,所以即使不了解这些配置也没什么关系。下面先来看一个比较简单的配置,如下:</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>接下来,对照上面的配置,来分析相关源码:</p>
<pre><code class="java">// -☆- XMLConfigBuilder
private Properties settingsAsProperties(XNode context) &#123;
    if (context == null) &#123;
        return new Properties();
    &#125;
    // 获取 settings 子节点中的内容
    Properties props = context.getChildrenAsProperties();
    // 创建 Configuration 类的“元信息”对象
    MetaClass metaConfig = MetaClass.forClass(
        Configuration.class, localReflectorFactory);
    for (Object key : props.keySet()) &#123;
        // 检测 Configuration 中是否存在相关属性,不存在则抛出异常
        if (!metaConfig.hasSetter(String.valueOf(key))) &#123;
            throw new BuilderException(&quot;......&quot;);
        &#125;
    &#125;
    return props;
&#125;
</code></pre>
<p>如上,<code>settingsAsProperties </code>方法看起来并不复杂,不过这是一个假象。在上面的代码中出现了一个陌生的类 <code>MetaClass</code>,这个类是用来做什么的呢?答案是用来解析目标类的一些元信息,比如类的成员变量,getter/setter 方法等。关于这个类的逻辑,待会我会详细解析。<br>接下来,简单总结一下上面代码的逻辑。</p>
<ol>
<li>解析 <code>settings</code> 子节点的内容,并将解析结果转成 <code>Properties</code> 对象</li>
<li>为 <code>Configuration</code> 创建元信息对象</li>
<li>通过 <code>MetaClass</code> 检测 <code>Configuration</code> 中是否存在某个属性的 setter 方法,不存在则抛异常</li>
<li>若通过 <code>MetaClass</code> 的检测,则返回<code> Properties</code> 对象,方法逻辑结束</li>
</ol>
<p>下面,我们重点关注一下第 2 步和第 3 步的流程。这两步流程对应的代码较为复杂,需要一点耐心阅读。</p>
<h3 id="元信息对象创建过程"><a href="#元信息对象创建过程" class="headerlink" title="元信息对象创建过程"></a>元信息对象创建过程</h3><p>元信息类 <code>MetaClass</code> 的构造方法为私有类型,所以不能直接创建,但是它有个<code>public方法forClass</code>，必须使用其提供的<code>forClass</code> 方法进行创建。它的创建逻辑如下:</p>
<pre><code class="Java">public class MetaClass &#123;
    private final ReflectorFactory reflectorFactory;
    private final Reflector reflector;
    private MetaClass(Class&lt;?&gt; type, ReflectorFactory reflectorFactory) &#123;
        this.reflectorFactory = reflectorFactory;
        // 根据类型创建 Reflector
        this.reflector = reflectorFactory.findForClass(type);
    &#125;
    public static MetaClass forClass(
        Class&lt;?&gt; type, ReflectorFactory reflectorFactory) &#123;
        // 调用构造方法
        return new MetaClass(type, reflectorFactory);
    &#125;
&#125;
// 省略其他方法
</code></pre>
<p>上 面的代 码看起 来很简单,不过 这只是冰山一 角。上 面代码出现了两个新的类<code>ReflectorFactory </code>和 <code>Reflector</code>,<code>MetaClass </code>通过引入这些新类帮助它完成功能。下面我们看一下 <code>hasSetter</code> 方法的源码就知道是怎么回事了。</p>
<pre><code class="java">// -☆- MetaClass
public boolean hasSetter(String name) &#123;
    // 属性分词器,用于解析属性名
    PropertyTokenizer prop = new PropertyTokenizer(name);
    // hasNext 返回 true,则表明 name 是一个复合属性,后面会进行分析
    if (prop.hasNext()) &#123;
        // 调用 reflector 的 hasSetter 方法
        if (reflector.hasSetter(prop.getName())) &#123;
            // 为属性创建创建 MetaClass
            MetaClass metaProp = metaClassForProperty(prop.getName());
            // 再次调用 hasSetter
            return metaProp.hasSetter(prop.getChildren());
        &#125; else &#123;
            return false;
        &#125;
    &#125; else &#123;
        // 调用 reflector 的 hasSetter 方法
        return reflector.hasSetter(prop.getName());
    &#125;
&#125;
</code></pre>
<p>从上面的代码中,我们可以看出 <code>MetaClass</code> 中的 <code>hasSetter</code> 方法最终调用了 <code>Reflector</code> 的<code>hasSetter</code> 方法。关于 <code>Reflector</code> 的 <code>hasSetter</code> 方法,这里先不进行分析,<code>Reflector</code> 这个类的逻辑较为复杂,本节会在随后进行详细说明。下面来简单介绍一下上面代码中出现的几个类:</p>
<ol>
<li><code>ReflectorFactory</code>:顾名思义,<code>Reflector</code> 的工厂类,兼有缓存 <code>Reflector </code>对象的功能</li>
<li><code>Reflector</code>:反射器,用于解析和存储目标类中的元信息</li>
<li><code>PropertyTokenizer</code>:属性名分词器,用于处理较为复杂的属性名</li>
</ol>
<p>上面的描述比较简单,仅通过上面的描述还不能让大家对这几个类有更深入的理解。所以下面单独分析一下这几个类的逻辑,首先是 <code>ReflectorFactory</code>。 <code>ReflectorFactory</code> 是一个接口,MyBatis 中目前只有一个实现类 <code>DefaultReflectorFactory</code>,它的分析如下:</p>
<h3 id="DefaultReflectorFactory"><a href="#DefaultReflectorFactory" class="headerlink" title="DefaultReflectorFactory"></a>DefaultReflectorFactory</h3><p><code>DefaultReflectorFactory</code> 用于创建 <code>Reflector</code>,同时兼有缓存的功能,它的源码如下:</p>
<pre><code class="java">public class DefaultReflectorFactory implements ReflectorFactory &#123;
    private boolean classCacheEnabled = true;
    /** 目标类和反射器映射缓存 */
    private final ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap =
        new ConcurrentHashMap&lt;Class&lt;?&gt;, Reflector&gt;();
    // 省略部分代码
    @Override
    public Reflector findForClass(Class&lt;?&gt; type) &#123;
        // classCacheEnabled 默认为 true
        if (classCacheEnabled) &#123;
            // 从缓存中获取 Reflector 对象
            Reflector cached = reflectorMap.get(type);
            // 缓存为空,则创建一个新的 Reflector 实例,并放入缓存中
            if (cached == null) &#123;
                cached = new Reflector(type);
                // 将 &lt;type, cached&gt; 映射缓存到 map 中,方便下次取用
                reflectorMap.put(type, cached);
            &#125;
            return cached;
        &#125; else &#123;
            // 创建一个新的 Reflector 实例
            return new Reflector(type);
        &#125;
    &#125;
&#125;
</code></pre>
<p>如上,<code>DefaultReflectorFactory</code> 的 <code>findForClass </code>方法逻辑包含两个访存操作,和一个对象创建操作。逻辑不是很复杂,代码注释的比较详细了,就不多说了。</p>
<h3 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h3><p>Reflector 这个类的用途主要是是通过反射获取目标类的 getter 方法及其返回值类型,setter 方法及其参数值类型等元信息。并将获取到的元信息缓存到相应的集合中,供后续使用。 Reflector 本身代码比较多,这里不能一一分析。我将会分析该类的部分逻辑,分别如下:</p>
<ol>
<li>Reflector 构造方法及成员变量分析</li>
<li>getter 方法解析过程</li>
<li>setter 方法解析过程</li>
</ol>
<p>下面我们按照上面的顺序进行分析,先来分析 <code>Reflector</code> 的构造方法。</p>
<h4 id="Reflector-构造方法及成员变量分析"><a href="#Reflector-构造方法及成员变量分析" class="headerlink" title="Reflector 构造方法及成员变量分析"></a>Reflector 构造方法及成员变量分析</h4><p><code>Reflector</code> 构造方法中包含了很多初始化逻辑,目标类的元信息解析过程也是在构造方法中完成的,这些元信息最终会被保存到 <code>Reflector</code> 的成员变量中。下面我们先来看看 <code>Reflector</code>的构造方法和相关的成员变量定义,如下:</p>
<pre><code class="java">public class Reflector &#123;
    private final Class&lt;?&gt; type;
    private final String[] readablePropertyNames;
    private final String[] writeablePropertyNames;
    private final Map&lt;String, Invoker&gt; setMethods =
        new HashMap&lt;String, Invoker&gt;();
    private final Map&lt;String, Invoker&gt; getMethods =
        new HashMap&lt;String, Invoker&gt;();
    private final Map&lt;String, Class&lt;?&gt;&gt; setTypes =
        new HashMap&lt;String, Class&lt;?&gt;&gt;();
    private final Map&lt;String, Class&lt;?&gt;&gt; getTypes =
        new HashMap&lt;String, Class&lt;?&gt;&gt;();
    private Constructor&lt;?&gt; defaultConstructor;
    private Map&lt;String, String&gt; caseInsensitivePropertyMap =
        new HashMap&lt;String, String&gt;();
    public Reflector(Class&lt;?&gt; clazz) &#123;
        type = clazz;
        // 解析目标类的默认构造方法,并赋值给 defaultConstructor 变量
        addDefaultConstructor(clazz);
        // 解析 getter 方法,并将解析结果放入 getMethods 中
        addGetMethods(clazz);
        // 解析 setter 方法,并将解析结果放入 setMethods 中
        addSetMethods(clazz);
        // 解析属性字段,并将解析结果添加到 setMethods 或 getMethods 中
        addFields(clazz);
        // 从 getMethods 映射中获取可读属性名数组
        readablePropertyNames = getMethods.keySet()
            .toArray(new String[getMethods.keySet().size()]);
        // 从 setMethods 映射中获取可写属性名数组
        writeablePropertyNames = setMethods.keySet()
            .toArray(new String[setMethods.keySet().size()]);
        // 将所有属性名的大写形式作为键,属性名作为值,
        // 存入到 caseInsensitivePropertyMap 中
        for (String propName : readablePropertyNames) &#123;
            caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
        &#125;
        for (String propName : writeablePropertyNames) &#123;
            caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
        &#125;
    &#125;
    // 省略其他方法
&#125;
</code></pre>
<p>如上,<code>Reflector</code> 的构造方法逻辑比较多,看起来比较复杂。不过好在一些较为复杂的逻辑都封装在了相应的方法中,这样整体的逻辑就比较清晰了。<code>Reflector</code> 构造方法所做的事情均已进行了注释,大家对照着注释先看一下。构造方法中所调用的其他方法的细节待会会进行分析。下面使用表格列举一下 <code>Reflector</code> 部分成员变量的用途。如下:</p>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>readablePropertyNames</code></td>
<td align="center">可读属性名称数组,用于保存 getter 方法对应的属性名称</td>
</tr>
<tr>
<td align="center"><code>writeablePropertyNames</code></td>
<td align="center">可写属性名称数组,用于保存 setter 方法对应的属性名称</td>
</tr>
<tr>
<td align="center"><code>setMethods</code></td>
<td align="center">用于保存属性名称到 Invoke 的映射。setter 方法会被封装到 MethodInvoker 对象中,Invoke 实现类比较简单,大家自行分析</td>
</tr>
<tr>
<td align="center"><code>getMethods</code></td>
<td align="center">用于保存属性名称到 Invoke 的映射。同上,getter 方法也会被封装到 MethodInvoker 对象中</td>
</tr>
<tr>
<td align="center"><code>setTypes</code></td>
<td align="center">用于保存 setter 对应的属性名与参数类型的映射</td>
</tr>
<tr>
<td align="center"><code>getTypes</code></td>
<td align="center">用于保存 getter 对应的属性名与返回值类型的映射</td>
</tr>
<tr>
<td align="center"><code>caseInsensitivePropertyMap</code></td>
<td align="center">用于保存大写属性名与属性名之间的映射,比如 &lt;NAME,name&gt;</td>
</tr>
</tbody></table>
<p>上面列举了一些集合变量,这些变量用于缓存各种原信息。关于这些变量,这里描述的不太好懂,主要是这些变量用途不太好解释。要想了解这些变量更多的细节,还是要深入到源码才行。所以我们成热打铁,继续往下分析。</p>
<h4 id="getter-方法解析过程"><a href="#getter-方法解析过程" class="headerlink" title="getter 方法解析过程"></a>getter 方法解析过程</h4><p>getter 方法解析的逻辑被封装在了 <code>addGetMethods</code> 方法中,这个方法除了会解析形如<code>getXXX</code> 的方法,同时也会解析 <code>isXXX</code> 方法。该方法的源码分析如下:</p>
<pre><code class="java">private void addGetMethods(Class&lt;?&gt; cls) &#123;
    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters =
        new HashMap&lt;String, List&lt;Method&gt;&gt;();
    // 获取当前类,接口,以及父类中的方法。该方法逻辑不是很复杂,这里就不展开了
    Method[] methods = getClassMethods(cls);
    for (Method method : methods) &#123;
        // getter 方法不应该有参数,若存在参数,则忽略当前方法
        if (method.getParameterTypes().length &gt; 0) &#123;
            continue;
        &#125;
        String name = method.getName();
        // 过滤出以 get 或 is 开头的方法
        if ((name.startsWith(&quot;get&quot;) &amp;&amp; name.length() &gt; 3)
            || (name.startsWith(&quot;is&quot;) &amp;&amp; name.length() &gt; 2)) &#123;
            // 将 getXXX 或 isXXX 等方法名转成相应的属性,比如 getName -&gt; name
            name = PropertyNamer.methodToProperty(name);
            /*
            * 将冲突的方法添加到 conflictingGetters 中。考虑这样一种情况:
            *
            * getTitle 和 isTitle 两个方法经过 methodToProperty 处理,
            * 均得到 name = title,这会导致冲突。
            *
            * 对于冲突的方法,这里先统一起存起来,后续再解决冲突
            */
            addMethodConflict(conflictingGetters, name, method);
        &#125;
    &#125;
    // 解决 getter 冲突
    resolveGetterConflicts(conflictingGetters);
&#125;
</code></pre>
<p>addGetMethods 方法的代码不是很多,但是逻辑有点多。这里总结一下:</p>
<ol>
<li>获取当前类,接口,以及父类中的方法</li>
<li>遍历上一步获取的方法数组,并过滤出以 get 和 is 开头的方法</li>
<li>将方法名转换成相应的属性名</li>
<li>将属性名和方法对象添加到冲突集合中</li>
<li>解决冲突</li>
</ol>
<p>在上面的执行流程中,前三步比较简单,大家自行分析吧。第 4 步也不复杂,下面我会把源码贴出来,大家看一下就能懂。在这几步中,第 5 步逻辑比较复杂,这一步逻辑我们重点关注一下。</p>
<pre><code class="java">/* Reflector

  /**
   * //  添加属性名和方法对象到冲突集合中
   * @param conflictingMethods
   * @param name
   * @param method
   */
private void addMethodConflict(Map&lt;String, List&lt;Method&gt;&gt; conflictingMethods, String name, Method method) &#123;
    List&lt;Method&gt; list = conflictingMethods.get(name);
    if (list == null) &#123;
        list = new ArrayList&lt;Method&gt;();
        conflictingMethods.put(name, list);
    &#125;
    list.add(method);
&#125;
/**
   * 解决冲突
   * @param conflictingGetters
   */
private void resolveGetterConflicts(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters) &#123;
    for (String propName : conflictingGetters.keySet()) &#123;
        List&lt;Method&gt; getters = conflictingGetters.get(propName);
        Iterator&lt;Method&gt; iterator = getters.iterator();
        Method firstMethod = iterator.next();
        if (getters.size() == 1) &#123;
            addGetMethod(propName, firstMethod);
        &#125; else &#123;
            Method getter = firstMethod;
            //        获取返回值类型
            Class&lt;?&gt; getterType = firstMethod.getReturnType();
            while (iterator.hasNext()) &#123;
                Method method = iterator.next();
                Class&lt;?&gt; methodType = method.getReturnType();
                /**
           * 两个方法的返回值类型一致，若两个方法返回值类型均为boolean,则选取isXXX方法
           * 为getterType,则无法决定哪个方法更为合适，只能抛出异常
           *
           * */
                if (methodType.equals(getterType)) &#123;
                    throw new ReflectionException(&quot;Illegal overloaded getter method with ambiguous type for property &quot; + propName + &quot; in class &quot; +firstMethod.getDeclaringClass()
+ &quot;.  This breaks the JavaBeans &quot; + &quot;specification and can cause unpredicatble results.&quot;);
                    /**
             * getterType是methodType的子类，类型上更为具体
             * 则认为当前的getter 是合适的，无需做什么事情
             *
             * */
                &#125; else if (methodType.isAssignableFrom(getterType)) &#123;
                    // OK getter type is descendant
                    /**
            * methodType 是getterType的子类，此时认为method方法更为合适，
             * 故将getter更新为method
             */
                &#125; else if (getterType.isAssignableFrom(methodType)) &#123;
                    getter = method;
                    getterType = methodType;
                &#125; else &#123;
                    throw new ReflectionException(&quot;Illegal overloaded getter method with ambiguous type for property &quot;  + propName + &quot; in class &quot; +firstMethod.getDeclaringClass()+ &quot;.  This breaks the JavaBeans &quot; + &quot;specification and can cause unpredicatble results.&quot;);
                &#125;
            &#125;
            //       将筛选出的方法添加到getMethods中，并将方法返回值添加到getType中
            addGetMethod(propName, getter);
        &#125;
    &#125;
&#125;
private void addGetMethod(String name, Method method) &#123;
    if (isValidPropertyName(name)) &#123;
        //      解析返回值类型
        getMethods.put(name, new MethodInvoker(method));
        //      将返回值类型由Type 转为Class,并将转换后的结果缓存到getTypes中
        getTypes.put(name, method.getReturnType());
    &#125;
&#125;
</code></pre>
<p>以上就是解除冲突的过程,代码有点长,不太容易看懂。这里大家只要记住解决冲突的规则即可理解上面代码的逻辑。相关规则如下:</p>
<ol>
<li>冲突方法返回值类型具有继承关系,子类返回值对应方法被认为是更合适的选择</li>
<li>冲突方法的返回值类型相同,如果返回值类型为 boolean,那么以 is 开头的方法则是更合适的选择</li>
<li>冲突方法的返回值类型相同,但类型非 boolean,此时出现歧义,抛出异常</li>
<li>冲突方法的返回值类型不相关,无法确定哪个是更好的选择,此时直接抛异常</li>
</ol>
<p>分析完 getter 方法的解析过程,下面继续分析 setter 方法的解析过程。</p>
<h4 id="setter-方法解析过程"><a href="#setter-方法解析过程" class="headerlink" title="setter 方法解析过程"></a>setter 方法解析过程</h4><p>与 getter 方法解析过程相比, setter 方法的解析过程与此有一定的区别。主要体现在冲突出现的原因,以及冲突的解决方法上。下面,我们深入源码来找出两者之间的区别。</p>
<pre><code class="java">private void addSetMethods(Class&lt;?&gt; cls) &#123;
    Map&lt;String, List&lt;Method&gt;&gt; conflictingSetters =
        new HashMap&lt;String, List&lt;Method&gt;&gt;();
    // 获取当前类,接口,以及父类中的方法。该方法逻辑不是很复杂,这里就不展开了
    Method[] methods = getClassMethods(cls);
    for (Method method : methods) &#123;
        String name = method.getName();
        // 过滤出 setter 方法,且方法仅有一个参数
        if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3) &#123;
            if (method.getParameterTypes().length == 1) &#123;
                name = PropertyNamer.methodToProperty(name);
                // setter 方法发生冲突原因是:可能存在重载情况,比如:
                //
                void setSex(int sex);
                //
                void setSex(SexEnum sex);
                addMethodConflict(conflictingSetters, name, method);
            &#125;
        &#125;
    &#125;
    // 解决 setter 冲突
    resolveSetterConflicts(conflictingSetters);
&#125;
</code></pre>
<p>从上面的代码和注释中,我们可知道 setter 方法之间出现冲突的原因。 即方法存在重载,方法重载导致 <code>methodToProperty </code>方法解析出的属性名完全一致。而 <code>getter</code> 方法之间出现冲突的原因是 <code>getXXX</code> 和 <code>isXXX </code>对应的属性名一致。既然冲突发生了,要进行调停,那接下来继续来看看调停冲突的逻辑。</p>
<pre><code class="java">private void resolveSetterConflicts(
    Map&lt;String, List&lt;Method&gt;&gt; conflictingSetters) &#123;
    for (String propName : conflictingSetters.keySet()) &#123;
        List&lt;Method&gt; setters = conflictingSetters.get(propName);
        /*
* 获取 getter 方法的返回值类型,由于 getter 方法不存在重载的情况,
* 所以可以用它的返回值类型反推哪个 setter 的更为合适
*/
        Class&lt;?&gt; getterType = getTypes.get(propName);
        Method match = null;
        ReflectionException exception = null;
        for (Method setter : setters) &#123;
            // 获取参数类型
            Class&lt;?&gt; paramType = setter.getParameterTypes()[0];
            if (paramType.equals(getterType)) &#123;
                // 参数类型和返回类型一致,则认为是最好的选择,并结束循环
                match = setter;
                break;
            &#125;
            if (exception == null) &#123;
                try &#123;
                    // 选择一个更为合适的方法
                    match = pickBetterSetter(match, setter, propName);
                &#125; catch (ReflectionException e) &#123;
                    match = null;
                    exception = e;
                &#125;
            &#125;
        &#125;
        // 若 match 为空,表示没找到更为合适的方法,此时抛出异常
        if (match == null) &#123;
            throw exception;
        &#125; else &#123;
            // 将筛选出的方法放入 setMethods 中,并将方法参数值添加到 setTypes 中
            addSetMethod(propName, match);
        &#125;
    &#125;
&#125;

/** 从两个 setter 方法中选择一个更为合适方法 */
private Method pickBetterSetter(Method setter1,
                                Method setter2, String property) &#123;
    if (setter1 == null) &#123;
        return setter2;
    &#125;
    Class&lt;?&gt; paramType1 = setter1.getParameterTypes()[0];
    Class&lt;?&gt; paramType2 = setter2.getParameterTypes()[0];
    // 如果参数 2 可赋值给参数 1,即参数 2 是参数 1 的子类,
    // 则认为参数 2 对应的 setter 方法更为合适
    if (paramType1.isAssignableFrom(paramType2)) &#123;
        return setter2;
        // 这里和上面情况相反
    &#125; else if (paramType2.isAssignableFrom(paramType1)) &#123;
        return setter1;
    &#125;
    // 两种参数类型不相关,这里抛出异常
    throw new ReflectionException(&quot;......&quot;);
&#125;

private void addSetMethod(String name, Method method) &#123;
    if (isValidPropertyName(name)) &#123;
        setMethods.put(name, new MethodInvoker(method));
        // 解析参数类型列表
        Type[] paramTypes = TypeParameterResolver
            .resolveParamTypes(method, type);
        // 将参数类型由 Type 转为 Class,并将转换后的结果缓存到 setTypes
        setTypes.put(name, typeToClass(paramTypes[0]));
    &#125;
&#125;
</code></pre>
<p>关于 setter 方法冲突的解析规则,这里也总结一下吧。如下:</p>
<ol>
<li>冲突方法的参数类型与 getter 的返回类型一致,则认为是最好的选择</li>
<li>冲突方法的参数类型具有继承关系,子类参数对应的方法被认为是更合适的选择</li>
<li>冲突方法的参数类型不相关,无法确定哪个是更好的选择,此时直接抛异常</li>
</ol>
<p>到此关于 setter 方法的解析过程就说完了。我在前面说过 MetaClass 的 hasSetter 最终调用了 Refactor 的 hasSetter 方法,那么现在是时候分析 Refactor 的 hasSetter 方法了。代码如下如下:</p>
<pre><code class="java">public boolean hasSetter(String propertyName) &#123;
    return setMethods.keySet().contains(propertyName);
&#125;
</code></pre>
<h3 id="PropertyTokenizer"><a href="#PropertyTokenizer" class="headerlink" title="PropertyTokenizer"></a>PropertyTokenizer</h3><p>对于较为复杂的属性,需要进行进一步解析才能使用。那什么样的属性是复杂属性呢?<br>来看个测试代码就知道了。</p>
<pre><code class="java">public class MetaClassTest &#123;
    private class Author &#123;
        private Integer id;
        private String name;
        private Integer age;
        /** 一个作者对应多篇文章 */
        private Article[] articles;
    &#125;
    // 省略 getter/setter
    private class Article &#123;
        private Integer id;
        private String title;
        private String content;
        /** 一篇文章对应一个作者 */
        private Author author;
    &#125;
    // 省略 getter/setter
    @Test
    public void testHasSetter() &#123;
        // 为 Author 创建元信息对象
        MetaClass authorMeta = MetaClass.forClass(
            Author.class, new DefaultReflectorFactory());
        System.out.println(&quot;------------☆ Author ☆------------&quot;);
        System.out.println(&quot;id -&gt; &quot; + authorMeta.hasSetter(&quot;id&quot;));
        System.out.println(&quot;name -&gt; &quot; + authorMeta.hasSetter(&quot;name&quot;));
        System.out.println(&quot;age -&gt; &quot; + authorMeta.hasSetter(&quot;age&quot;));
        // 检测 Author 中是否包含 Article[] 的 setter
        System.out.println(&quot;articles-&gt;&quot; + authorMeta.hasSetter(&quot;articles&quot;));
        System.out.println(&quot;articles[] -&gt; &quot; +
                           authorMeta.hasSetter(&quot;articles[]&quot;));
        System.out.println(&quot;title -&gt; &quot; + authorMeta.hasSetter(&quot;title&quot;));
        // 为 Article 创建元信息对象
        MetaClass articleMeta = MetaClass.forClass(
            Article.class, new DefaultReflectorFactory());
        System.out.println(&quot;\n------------☆ Article ☆------------&quot;);
        System.out.println(&quot;id -&gt; &quot; + articleMeta.hasSetter(&quot;id&quot;));
        System.out.println(&quot;title -&gt; &quot; + articleMeta.hasSetter(&quot;title&quot;));
        System.out.println(&quot;content -&gt; &quot; +
                           articleMeta.hasSetter(&quot;content&quot;));
        // 下面两个均为复杂属性,分别检测 Article 类中的 Author 类
        // 是否包含 id 和 name 的 setter 方法
        System.out.println(&quot;author.id-&gt;&quot;+
                           articleMeta.hasSetter(&quot;author.id&quot;));
        System.out.println(&quot;author.name-&gt;&quot; +
                           articleMeta.hasSetter(&quot;author.name&quot;));
    &#125;
&#125;
</code></pre>
<p>如上,Article 类中包含了一个 <code>Author</code> 引用。然后我们调用 <code>articleMeta</code> 的 <code>hasSetter</code> 检测<code>author.id</code> 和 <code>author.name</code> 属性是否存在,我们的期望结果为 true。测试结果如下:</p>
<p><img src="1586596943749.png" alt="1586596943749"></p>
<p>如上,标记5处的输出均为 true,我们的预期达到了。标记2处检测 Article 数组的是否存在 setter 方法,结果也均为 true。这说明<code> PropertyTokenize</code>r 对数组和复合属性均进行了处理。那它是如何处理的呢?答案如下:</p>
<pre><code class="java">public class PropertyTokenizer implements Iterator&lt;PropertyTokenizer&gt; &#123;
    private String name;
    private final String indexedName;
    private String index;
    private final String children;
    public PropertyTokenizer(String fullname) &#123;
        // 检测传入的参数中是否包含字符 &#39;.&#39;
        int delim = fullname.indexOf(&#39;.&#39;);
        if (delim &gt; -1) &#123;
            /*
            * 以点位为界,进行分割。比如:
            *
            fullname = www.coolblog.xyz
            *
            * 以第一个点为分界符:
            *
            name = www
            *
            children = coolblog.xyz
            */
            name = fullname.substring(0, delim);
            children = fullname.substring(delim + 1);
        &#125; else &#123;
            // fullname 中不存在字符 &#39;.&#39;
            name = fullname;
            children = null;
        &#125;
        indexedName = name;
        // 检测传入的参数中是否包含字符 &#39;[&#39;
        delim = name.indexOf(&#39;[&#39;);
        if (delim &gt; -1) &#123;
            /*
            * 获取中括号里的内容,比如:
            1. 对于数组或 List 集合:[] 中的内容为数组下标,
            比如 fullname = articles[1],index = 1
            2. 对于 Map:[] 中的内容为键,
            比如 fullname = xxxMap[keyName],index = keyName
            */
            index = name.substring(delim + 1, name.length() - 1);
            // 获取分解符前面的内容,比如
            // fullname = articles[1],name = articles
            name = name.substring(0, delim);
        &#125;
    &#125;
    // 省略 getter
    @Override
    public boolean hasNext() &#123;
        return children != null;
    &#125;
    @Override
    public PropertyTokenizer next() &#123;
        // 对 children 进行再次切分,用于解析多重复合属性
        return new PropertyTokenizer(children);
    &#125;
&#125;
</code></pre>
<p>以上是<code> PropertyTokenizer</code> 的源码分析,注释的比较多,应该分析清楚了。大家如果看懂了上面的分析,可自行举例进行测试,以加深理解。<br>本节为了分析<code> MetaClass</code> 的 <code>hasSetter</code> 方法,并把与这个方法相关的源码均分析了一遍。</p>
<p>其实,如果想简单点分析,可直接把<code> MetaClass</code> 当成一个黑盒,然后用一句话告诉大家<code>hasSetter</code> 方法有什么用即可。但是这样做我觉的内容太虚,没什么深度。关于<code> MetaClass</code> 及相关源码大家第一次看可能会有点吃力,看不懂可以先放一放。后面多看几遍,动手写点测试代码调试一下,可以帮助理解。<br>好了,关于<code>&lt;settings&gt;</code>节点的解析过程就先分析到这里,继续往下分析。</p>
<h2 id="设置-lt-settings-gt-内容到-Configuration-中"><a href="#设置-lt-settings-gt-内容到-Configuration-中" class="headerlink" title="设置&lt;settings&gt;内容到 Configuration 中"></a>设置<code>&lt;settings&gt;</code>内容到 Configuration 中</h2><p>上一节讲了<code>&lt;settings&gt;</code>节点的解析过程,节点内容解析出来后,需要有一个存放的地方,以使其他代码可以找到这些配置。这个存放地方就是 <code>Configuration</code> 对象,本节来看一下将<code>&lt;settings&gt;</code>节点内容设置到 <code>Configuration</code> 对象中的过程。如下:</p>
<pre><code class="java">private void settingsElement(Properties props) throws Exception &#123;
    // 设置 autoMappingBehavior 属性,默认值为 PARTIAL
    configuration.setAutoMappingBehavior(AutoMappingBehavior
                                         .valueOf(props.getProperty(&quot;autoMappingBehavior&quot;, &quot;PARTIAL&quot;)));
    configuration.setAutoMappingUnknownColumnBehavior(
        AutoMappingUnknownColumnBehavior.valueOf(
            props.getProperty(&quot;autoMappingUnknownColumnBehavior&quot;, &quot;NONE&quot;)));
    // 设置 cacheEnabled 属性,默认值为 true
    configuration.setCacheEnabled(
        booleanValueOf(props.getProperty(&quot;cacheEnabled&quot;),  true));
    // 解析默认的枚举处理器
    Class&lt;? extends TypeHandler&gt; typeHandler=(Class&lt;? extends TypeHandler&gt;)
        resolveClass(props.getProperty(&quot;defaultEnumTypeHandler&quot;));
    // 设置默认枚举处理器
    configuration.setDefaultEnumTypeHandler(typeHandler);
    configuration.setCallSettersOnNulls(
        booleanValueOf(props.getProperty(&quot;callSettersOnNulls&quot;), false));
    configuration.setUseActualParamName(
        booleanValueOf(props.getProperty(&quot;useActualParamName&quot;), true));
&#125;
</code></pre>
<p>上面代码处理调用 Configuration 的 setter 方法,没太多其他逻辑。这里来看一下上面出现的一个调用 <code>resolveClass</code>,它的源码如下:</p>
<pre><code class="java">// -☆- BaseBuilder
protected Class&lt;?&gt; resolveClass(String alias) &#123;
    if (alias == null) &#123;
        return null;
    &#125;
    try &#123;
        // 通过别名解析
        return resolveAlias(alias);
    &#125; catch (Exception e) &#123;
        throw new BuilderException(&quot;Error resolving class. Cause: &quot; + e, e);
    &#125;
&#125;
protected final TypeAliasRegistry typeAliasRegistry;
protected Class&lt;?&gt; resolveAlias(String alias) &#123;
    // 通过别名注册器解析别名对于的类型 Class
    return typeAliasRegistry.resolveAlias(alias);
&#125;
</code></pre>
<p>这里出现了一个新的类 <code>TypeAliasRegistry</code>,大家对于它可能会觉得陌生,但是对于<code>typeAlias</code> 应该不会陌生。<code>TypeAliasRegistry</code> 的用途就是将别名和类型进行映射,这样就可以用别名表示某个类了,方便使用。既然聊到了别名,那下面我们不妨看看别名的配置的解析过程。</p>
<h2 id="解析-lt-typeAliases-gt-节点"><a href="#解析-lt-typeAliases-gt-节点" class="headerlink" title="解析&lt;typeAliases&gt;节点"></a>解析<code>&lt;typeAliases&gt;</code>节点</h2><p>在 MyBatis 中,我们可以为自己写的一些类定义一个别名。这样在使用的时候,只需要输入别名即可,无需再把全限定的类名写出来。在 MyBatis 中,我们有两种方式进行别名配置。</p>
<p>第一种是仅配置包名,让 MyBatis 去扫描包中的类型,并根据类型得到相应的别名。这种方式可配合 <code>Alias</code> 注解使用,即通过注解为某个类配置别名,而不是让 MyBatis 按照默认规则生成别名。这种方式的配置如下:</p>
<pre><code class="xml">&lt;typeAliases&gt;
    &lt;package name=&quot;xyz.coolblog.chapter2.model1&quot;/&gt;
    &lt;package name=&quot;xyz.coolblog.chapter2.model2&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>第二种方式是通过手动的方式,明确为某个类型配置别名。这种方式的配置如下:</p>
<pre><code class="xml">&lt;typeAliases&gt;
    &lt;typeAlias alias=&quot;article&quot; type=&quot;xyz.coolblog.chapter2.model.Article&quot; /&gt;
    &lt;typeAlias alias=&quot;author&quot; type=&quot;xyz.coolblog.chapter2.model.Author&quot; /&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>对比这两种方式,第一种自动扫描的方式配置起来比较简单,缺点也不明显。唯一能想到缺点可能就是 MyBatis 会将某个包下所有符合要求的类的别名都解析出来,并形成映射关系。如果你不想让某些类被扫描,这个好像做不到,没发现 MyBatis 提供了相关的排除机制。不过我觉得这并不是什么大问题,最多是多解析并缓存了一些别名到类型的映射,在时间和空间上产生了一些的消耗而已。当然,如果无法忍受这些消耗,可以使用第二种配置方式,通过手工的方式精确配置某些类型的别名。不过这种方式比较繁琐,特别是配置项比较多时。至于两种方式怎么选择,这个看具体的情况了。配置项非常少时,两种皆可。比较多的话,还是让 MyBatis 自行扫描吧。</p>
<p>以上介绍了两种不同的别名配置方式,下面我们来看一下两种不同的别名配置是怎样解析的。代码如下:</p>
<pre><code class="java">// -☆- XMLConfigBuilder
private void typeAliasesElement(XNode parent) &#123;
    if (parent != null) &#123;
        for (XNode child : parent.getChildren()) &#123;
            // ⭐ 从指定的包中解析别名和类型的映射
            if (&quot;package&quot;.equals(child.getName())) &#123;
                String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);
                configuration.getTypeAliasRegistry()
                    .registerAliases(typeAliasPackage);
                // ⭐ 从 typeAlias 节点中解析别名和类型的映射
            &#125; else &#123;
                // 获取 alias 和 type 属性值,alias 不是必填项,可为空
                String alias = child.getStringAttribute(&quot;alias&quot;);
                String type = child.getStringAttribute(&quot;type&quot;);
                try &#123;
                    // 加载 type 对应的类型
                    Class&lt;?&gt; clazz = Resources.classForName(type);
                    // 注册别名到类型的映射
                    if (alias == null) &#123;
                        typeAliasRegistry.registerAlias(clazz);
                    &#125; else &#123;
                        typeAliasRegistry.registerAlias(alias, clazz);
                    &#125;
                &#125; catch (ClassNotFoundException e) &#123;
                    throw new BuilderException(&quot;......&quot;);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>如上,上面的代码通过一个 if-else 条件分支来处理两种不同的配置,这里我用⭐ 标注了出来。下面我们来分别看一下这两种配置方式的解析过程.</p>
<h3 id="从typeAlias节点中解析并注册别名"><a href="#从typeAlias节点中解析并注册别名" class="headerlink" title="从typeAlias节点中解析并注册别名"></a>从typeAlias节点中解析并注册别名</h3><p>在别名的配置中,type 属性是必须要配置的,而 alias 属性则不是必须的。这个在配置文件的 DTD 中有所规定。如果使用者未配置 alias 属性,则需要 MyBatis 自行为目标类型生成别名。对于别名为空的情况,注册别名的任务交由 registerAlias(Class<?>) 方法处理。若不为空,则由 registerAlias(String,Class<?>) 进行别名注册。这两个方法的分析如下:</p>
<pre><code class="java">public void registerAlias(Class&lt;?&gt; type) &#123;
    // 获取全路径类名的简称
    String alias = type.getSimpleName();
    Alias aliasAnnotation = type.getAnnotation(Alias.class);
    if (aliasAnnotation != null) &#123;
        // 从注解中取出别名
        alias = aliasAnnotation.value();
    &#125;
    // 调用重载方法注册别名和类型映射
    registerAlias(alias, type);
&#125;
public void registerAlias(String alias, Class&lt;?&gt; value) &#123;
    if (alias == null) &#123; throw new TypeException(&quot;...&quot;); &#125;
    // 将别名转成小写
    String key = alias.toLowerCase(Locale.ENGLISH);
    // 如果 TYPE_ALIASES 中存在了某个类型映射,这里判断当前类型与映射中的类型
    // 是否一致,不一致则抛出异常,不允许一个别名对应两种类型
    if (TYPE_ALIASES.containsKey(key) &amp;&amp; TYPE_ALIASES.get(key) != null
        &amp;&amp; !TYPE_ALIASES.get(key).equals(value)) &#123;
        throw new TypeException(&quot;......&quot;);
    &#125;
    // 缓存别名到类型映射
    TYPE_ALIASES.put(key, value);
&#125;
</code></pre>
<p>如上,若用户未明确配置 alias 属性,MyBatis 会使用类名的小写形式作为别名。比如,全限定类名 <code>xyz.coolblog.model.Author</code> 的别名为 author。若类中有@Alias 注解,则从注解中取值作为别名。上面代码的逻辑不是很复杂,注释的也比较清楚了,就不多说了。继续分析注册别名的第二种方式。</p>
<h3 id="从指定的包中解析并注册别名"><a href="#从指定的包中解析并注册别名" class="headerlink" title="从指定的包中解析并注册别名"></a>从指定的包中解析并注册别名</h3><p>从指定的包中解析并注册别名过程主要由别名的解析和注册两步组成。下面来看一下相关代码:</p>
<pre><code class="java">public void registerAliases(String packageName) &#123;
    // 调用重载方法注册别名
    registerAliases(packageName, Object.class);
&#125;
public void registerAliases(String packageName, Class&lt;?&gt; superType) &#123;
    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;();
    // 查找某个包下的父类为 superType 的类。从调用栈来看,这里的
    // superType = Object.class,所以 ResolverUtil 将查找所有的类。
    // 查找完成后,查找结果将会被缓存到内部集合中。
    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
    // 获取查找结果
    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();
    for (Class&lt;?&gt; type : typeSet) &#123;
        // 忽略匿名类,接口,内部类
        if (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp;
            !type.isMemberClass()) &#123;
            // 为类型注册别名
            registerAlias(type);
        &#125;
    &#125;
&#125;
</code></pre>
<p>上面的代码不多,相关流程也不复杂,可简单总结为下面两个步骤:一是查找指定包下的所有类;二是遍历查找到的类型集合,为每个类型注册别名</p>
<p>在这两步流程中,第 2 步流程对应的代码上一节已经分析过了,这里不再赘述。第 1 步的功能理解起来不难,但是背后对应的代码有点多。限于篇幅原因,这里我不打算详细分析这一部分的代码,只做简单的流程总结。如下:</p>
<ol>
<li>通过 VFS(虚拟文件系统)获取指定包下的所有文件的路径名,</li>
<li>比如 xyz/coolblog/model/Article.class</li>
<li>筛选以.class 结尾的文件名</li>
<li>将路径名转成全限定的类名,通过类加载器加载类名</li>
<li>对类型进行匹配,若符合匹配规则,则将其放入内部集合中</li>
</ol>
<h3 id="注册-MyBatis-内部类及常见类型的别名"><a href="#注册-MyBatis-内部类及常见类型的别名" class="headerlink" title="注册 MyBatis 内部类及常见类型的别名"></a>注册 MyBatis 内部类及常见类型的别名</h3><p>最后,我们来看一下一些 MyBatis 内部类及一些常见类型的别名注册过程。如下:</p>
<pre><code class="java">// -☆- Configuration
public Configuration() &#123;
    // 注册事务工厂的别名
    typeAliasRegistry.registerAlias(&quot;JDBC&quot;, JdbcTransactionFactory.class);
    // 省略部分代码,下同
    // 注册数据源的别名
    typeAliasRegistry.registerAlias(
        &quot;POOLED&quot;, PooledDataSourceFactory.class);
    // 注册缓存策略的别名
    typeAliasRegistry.registerAlias(&quot;FIFO&quot;, FifoCache.class);
    typeAliasRegistry.registerAlias(&quot;LRU&quot;, LruCache.class);
    // 注册日志类的别名
    typeAliasRegistry.registerAlias(&quot;SLF4J&quot;,typeAliasRegistry.registerAlias(&quot;LOG4J&quot;,Slf4jImpl.class);
                                    Log4jImpl.class);
    // 注册动态代理工厂的别名
    typeAliasRegistry.registerAlias(&quot;CGLIB&quot;, CglibProxyFactory.class);
    typeAliasRegistry.registerAlias(
        &quot;JAVASSIST&quot;, JavassistProxyFactory.class);
&#125;

// -☆- TypeAliasRegistry
public TypeAliasRegistry() &#123;
    // 注册 String 的别名
    registerAlias(&quot;string&quot;, String.class);
    // 注册基本类型包装类的别名
    registerAlias(&quot;byte&quot;, Byte.class);
    // 省略部分代码,下同
    // 注册基本类型包装类数组的别名
    registerAlias(&quot;byte[]&quot;, Byte[].class);
    // 注册基本类型的别名
    registerAlias(&quot;_byte&quot;, byte.class);
    // 注册基本类型包装类的别名
    registerAlias(&quot;_byte[]&quot;, byte[].class);
    // 注册 Date, BigDecimal, Object 等类型的别名
    registerAlias(&quot;date&quot;, Date.class);
    registerAlias(&quot;decimal&quot;, BigDecimal.class);
    registerAlias(&quot;object&quot;, Object.class);
    // 注册 Date, BigDecimal, Object 等数组类型的别名
    registerAlias(&quot;date[]&quot;, Date[].class);
    registerAlias(&quot;decimal[]&quot;, BigDecimal[].class);
    registerAlias(&quot;object[]&quot;, Object[].class);
    // 注册集合类型的别名
    registerAlias(&quot;map&quot;, Map.class);
    registerAlias(&quot;list&quot;, List.class);
    registerAlias(&quot;collection&quot;, Collection.class);
    registerAlias(&quot;iterator&quot;, Iterator.class);
    // 注册 ResultSet 的别名
    registerAlias(&quot;ResultSet&quot;, ResultSet.class);
&#125;
</code></pre>
<p>我记得以前配置&lt;select/&gt;标签的 resultType 属性,由于不知道有别名这回事,傻傻的使用全限定类名进行配置。当时还觉得这样配置一定不会出错吧,很放心。现在想想有点搞笑。好了,以上就是别名解析的全部流程,大家看懂了吗?如果觉得没啥障碍的话,那继续往下看呗。</p>
<h2 id="解析-lt-plugins-gt-节点"><a href="#解析-lt-plugins-gt-节点" class="headerlink" title="解析&lt;plugins&gt;节点"></a>解析<code>&lt;plugins&gt;</code>节点</h2><p>插件是 MyBatis 提供的一个拓展机制,通过插件机制我们可在 SQL 执行过程中的某些点上做一些自定义操作。实现一个插件需要比简单,首先需要让插件类实现 <code>Interceptor</code>接口。然后在插件类上添加<code>@Intercepts</code> 和<code>@Signature</code> 注解,用于指定想要拦截的目标方法。MyBatis 允许拦截下面接口中的一些方法:</p>
<ul>
<li>Executor: update,query,flushStatements,commit,rollback,getTransaction,close,isClosed</li>
<li>ParameterHandler: getParameterObject,setParameters</li>
<li>ResultSetHandler: handleResultSets,handleOutputParameters</li>
<li>StatementHandler: prepare,parameterize,batch,update,query</li>
</ul>
<p>比较常见的插件有分页插件、分表插件等,有兴趣的朋可以去了解下。在分析插件的配置的解析过程之前,我们先来了解一下插件的配置。如下:</p>
<pre><code class="xml">&lt;plugins&gt;
    &lt;plugin interceptor=&quot;xyz.coolblog.mybatis.ExamplePlugin&quot;&gt;
        &lt;property name=&quot;key&quot; value=&quot;value&quot;/&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>
<p>解析过程如下:</p>
<pre><code class="java">private void pluginElement(XNode parent) throws Exception &#123;
    if (parent != null) &#123;
        for (XNode child : parent.getChildren()) &#123;
            String interceptor = child.getStringAttribute(&quot;interceptor&quot;);
            // 获取配置信息
            Properties properties = child.getChildrenAsProperties();
            // 解析拦截器的类型,并创建拦截器
            Interceptor interceptorInstance =
                (Interceptor) resolveClass(interceptor).newInstance();
            // 设置属性
            interceptorInstance.setProperties(properties);
            // 添加拦截器到 Configuration 中
            configuration.addInterceptor(interceptorInstance);

        &#125;
    &#125;
&#125;
</code></pre>
<p>如上,插件解析的过程还是比较简单的。首先是获取配置,然后再解析拦截器类型,并实例化拦截器。最后向拦截器中设置属性,并将拦截器添加到<code>Configuration</code>中。好了,关于插件配置的分析就先到这。</p>
<h2 id="解析-lt-environments-gt-节点"><a href="#解析-lt-environments-gt-节点" class="headerlink" title="解析&lt;environments&gt;节点"></a>解析<code>&lt;environments&gt;</code>节点</h2><p>在 MyBatis 中,事务管理器和数据源是配置在<code>&lt;environments&gt;</code>节点中的。它们的配置大致如下:</p>
<pre><code class="xml">&lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;/&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;
</code></pre>
<p>接下来我们对照上面的配置进行分析。</p>
<pre><code class="java">private void environmentsElement(XNode context) throws Exception &#123;
    if(context != null) &#123;
        if (environment == null) &#123;
            // 获取 default 属性
            environment = context.getStringAttribute(&quot;default&quot;);
        &#125;
        for (XNode child : context.getChildren()) &#123;
            // 获取 id 属性
            String id = child.getStringAttribute(&quot;id&quot;);
            // 检测当前 environment 节点的 id 与其父节点 environments 的
            // 属性 default 内容是否一致,一致则返回 true,否则返回 false
            if (isSpecifiedEnvironment(id)) &#123;
                // 解析 transactionManager 节点
                TransactionFactory txFactory = transactionManagerElement(
                    child.evalNode(&quot;transactionManager&quot;));
                // 解析 dataSource 节点,逻辑和插件的解析逻辑很相似,不在赘述
                DataSourceFactory dsFactory =
                    dataSourceElement(child.evalNode(&quot;dataSource&quot;));
                // 创建 DataSource 对象
                DataSource dataSource = dsFactory.getDataSource();
                Environment.Builder environmentBuilder =
                    new Environment.Builder(id)
                    .transactionFactory(txFactory)
                    .dataSource(dataSource);
                // 构建 Environment 对象,并设置到 configuration 中
                configuration.setEnvironment(environmentBuilder.build());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><code>&lt;environments&gt;</code>节点的解析过程没什么特别之处,按部就班解析就行了,不多说了。</p>
<h2 id="解析-lt-typeHandlers-gt-节点"><a href="#解析-lt-typeHandlers-gt-节点" class="headerlink" title="解析&lt;typeHandlers&gt;节点"></a>解析<code>&lt;typeHandlers&gt;</code>节点</h2><p>在向数据库存储或读取数据时, 我们需要将数据库字段类型和 Java 类型进行一个转换。比如数据库中有 CHAR 和 VARCHAR 等类型,但 Java 中没有这些类型,不过 Java 有 String类型。所以我们在从数据库中读取 CHAR 和 VARCHAR 类型的数据时,就可以把它们转成String。在 MyBatis 中,数据库类型和 Java 类型之间的转换任务是委托给类型处理器TypeHandler 去处理的。MyBatis 提供了一些常见类型的类型处理器,除此之外,我们还可以自定义类型处理器以非常见类型转换的需求。这里我就不演示自定义类型处理器的编写方法了,没用过或者不熟悉的同学可以 MyBatis 官方文档,或者我在第一章中所写的示例。下面,我们来看一下类型处理器的配置方法:</p>
<pre><code class="xml">&lt;!-- 自动扫描 --&gt;
&lt;typeHandlers&gt;
    &lt;package name=&quot;xyz.coolblog.handlers&quot;/&gt;
&lt;/typeHandlers&gt;
&lt;!-- 手动配置 --&gt;
&lt;typeHandlers&gt;
    &lt;typeHandler jdbcType=&quot;TINYINT&quot;
                 javaType=&quot;xyz.coolblog.constant.ArticleTypeEnum&quot;
                 handler=&quot;xyz.coolblog.mybatis.ArticleTypeHandler&quot;/&gt;
&lt;/typeHandlers&gt;
</code></pre>
<p>使用自动扫描的方式注册类型处理器时,应使用<code>@MappedTypes</code> 和<code>@MappedJdbcTypes</code>注解配置 javaType 和 jdbcType。关于注解,这里就不演示了,比较简单,大家自行尝试。下面开始分析代码。</p>
<pre><code class="java">private void typeHandlerElement(XNode parent) throws Exception &#123;
    if (parent != null) &#123;
        for (XNode child : parent.getChildren()) &#123;
            // 从指定的包中注册 TypeHandler
            if (&quot;package&quot;.equals(child.getName())) &#123;
                String typeHandlerPackage = child.getStringAttribute(&quot;name&quot;);
                // 注册方法 1
                typeHandlerRegistry.register(typeHandlerPackage);
            &#125; else &#123; // 从 typeHandler 节点中解析别名到类型的映射
                String javaTypeName = child.getStringAttribute(&quot;javaType&quot;);
                String jdbcTypeName = child.getStringAttribute(&quot;jdbcType&quot;);
                String handlerTypeName = child.getStringAttribute(&quot;handler&quot;);
                // 解析上面获取到的属性值
                Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName);
                JdbcType jdbcType = resolveJdbcType(jdbcTypeName);
                Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName);
                // 根据 javaTypeClass 和 jdbcType 值的情况进行不同的注册策略
                if (javaTypeClass != null) &#123;
                    if (jdbcType == null) &#123;
                        // 注册方法 2
                        typeHandlerRegistry.register(
                            javaTypeClass, typeHandlerClass);
                    &#125; else &#123;
                        // 注册方法 3
                        typeHandlerRegistry.register(
                            javaTypeClass, jdbcType, typeHandlerClass);
                    &#125;
                &#125; else &#123;
                    // 注册方法 4
                    typeHandlerRegistry.register(typeHandlerClass);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>上面代码中用于解析 XML 部分的代码比较简单,没什么需要特别说明的。除此之外,上面的代码中调用了 4 个不同的类型处理器注册方法。这些注册方法的逻辑不难理解,但是重载方法很多,上面调用的注册方法只是重载方法的一部分。由于重载太多且重载方法之间互相调用,导致这一块的代码有点凌乱。我一开始在整理这部分代码时,也很抓狂。后来把重载方法的调用图画了出来,才理清了代码。如下图。</p>
<p><img src="1586596547775.png" alt="1586596547775"></p>
<p>在上面的调用图中,每个蓝色背景框下都有一个标签。每个标签上面都已一个编号,这些编号与上面代码中的标签是一致的。这里我把蓝色背景框内的方法称为开始方法,红色背景框内的方法称为终点方法,白色背景框内的方法称为中间方法。下面我会分析从每个开始方法向下分析,为了避免冗余分析,我会按照3→2→4→1的顺序进行分析。大家在阅读代码分析时,可以参照上面的图片,辅助理解。</p>
<h3 id="register-Class-JdbcType-Class-方法分析"><a href="#register-Class-JdbcType-Class-方法分析" class="headerlink" title="register(Class,JdbcType,Class)方法分析"></a>register(Class,JdbcType,Class)方法分析</h3><p>当代码执行到此方法时,表示<code>javaTypeClass != null &amp;&amp; jdbcType != null</code>条件成立,即使用者明确配置了 <code>javaType </code>和<code> jdbcType 属性</code>的值。下面我们来看一下该方法的分析。</p>
<pre><code class="java">public void register(Class&lt;?&gt; javaTypeClass,
                     JdbcType jdbcType, Class&lt;?&gt; typeHandlerClass) &#123;
    // 调用终点方法
    register(javaTypeClass, jdbcType,
             getInstance(javaTypeClass, typeHandlerClass));
&#125;
</code></pre>
<pre><code class="java">/** 类型处理器注册过程的终点 */
private void register(Type javaType,
                      JdbcType jdbcType, TypeHandler&lt;?&gt; handler) &#123;
    if (javaType != null) &#123;
        // JdbcType 到 TypeHandler 的映射
        Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType);
        if (map == null || map == NULL_TYPE_HANDLER_MAP) &#123;
            map = new HashMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;();
            // 存储 javaType 到 Map&lt;JdbcType, TypeHandler&gt; 的映射
            TYPE_HANDLER_MAP.put(javaType, map);
        &#125;
        map.put(jdbcType, handler);
    &#125;
    // 存储所有的 TypeHandler
    ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler);
&#125;
</code></pre>
<p>上面的代码只有两层调用,比较简单。同时,所谓的注册过程也就是把类型和处理器进行映射而已,没什么特别之处。关于这个方法就先分析到这里,继续往下分析。下面的方法应注册方法2。</p>
<h3 id="register-Class-Class-方法分析"><a href="#register-Class-Class-方法分析" class="headerlink" title="register(Class,Class)方法分析"></a>register(Class,Class)方法分析</h3><p>当代码执行到此方法时,表示 javaTypeClass != null &amp;&amp; jdbcType == null 条件成立,即使用者仅设置了 javaType 属性的值。下面我们来看一下该方法的分析。</p>
<pre><code class="java">public void register(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass) &#123;
    // 调用中间方法 register(Type, TypeHandler)
    register(javaTypeClass, getInstance(javaTypeClass, typeHandlerClass));
&#125;
</code></pre>
<pre><code class="java">private &lt;T&gt; void register(Type javaType,
                          TypeHandler&lt;? extends T&gt; typeHandler) &#123;
    // 获取 @MappedJdbcTypes 注解
    MappedJdbcTypes mappedJdbcTypes =
        typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);
    if (mappedJdbcTypes != null) &#123;
        // 遍历 @MappedJdbcTypes 注解中配置的值
        for (JdbcType handledJdbcType : mappedJdbcTypes.value()) &#123;
            // 调用终点方法,参考上一小节的分析
            register(javaType, handledJdbcType, typeHandler);
        &#125;
        if (mappedJdbcTypes.includeNullJdbcType()) &#123;
            // 调用终点方法,jdbcType = null
            register(javaType, null, typeHandler);
        &#125;
    &#125; else &#123;
        // 调用终点方法,jdbcType = null
        register(javaType, null, typeHandler);
    &#125;
&#125;
</code></pre>
<p>上面的代码包含三层调用,其中终点方法的逻辑上一节已经分析过,这里不再赘述。上面的逻辑也比较简单,主要做的事情是尝试从注解中获取 JdbcType 的值。这个方法就分析这么多,下面分析注册方法4。</p>
<h3 id="register-Class-方法分析"><a href="#register-Class-方法分析" class="headerlink" title="register(Class)方法分析"></a>register(Class)方法分析</h3><p>当代码执行到此方法时,表示 javaTypeClass==null&amp;&amp;jdbcType!=null 条件成立,即使用者未配置 javaType 和 jdbcType 属性的值。该方法的分析如下。</p>
<pre><code class="java">public void register(Class&lt;?&gt; typeHandlerClass) &#123;
    boolean mappedTypeFound = false;
    // 获取 @MappedTypes 注解
    MappedTypes mappedTypes = typeHandlerClass
        .getAnnotation(MappedTypes.class);
    if (mappedTypes != null) &#123;
        // 遍历 @MappedTypes 注解中配置的值
        for (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123;
            // 调用注册方法 2
            register(javaTypeClass, typeHandlerClass);
            mappedTypeFound = true;
        &#125;
    &#125;
    if (!mappedTypeFound) &#123;
        // 调用中间方法 register(TypeHandler)
        register(getInstance(null, typeHandlerClass));
    &#125;
&#125;

public &lt;T&gt; void register(TypeHandler&lt;T&gt; typeHandler) &#123;
    boolean mappedTypeFound = false;
    // 获取 @MappedTypes 注解
    MappedTypes mappedTypes =
        typeHandler.getClass().getAnnotation(MappedTypes.class);
    if (mappedTypes != null) &#123;
        for (Class&lt;?&gt; handledType : mappedTypes.value()) &#123;
            // 调用中间方法 register(Type, TypeHandler)
            register(handledType, typeHandler);
            mappedTypeFound = true;
        &#125;
    &#125;
    // 自动发现映射类型
    if (!mappedTypeFound &amp;&amp; typeHandler instanceof TypeReference) &#123;
        try &#123;
            TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler;
            // 获取参数模板中的参数类型,并调用中间方法 register(Type, TypeHandler)
            register(typeReference.getRawType(), typeHandler);
            mappedTypeFound = true;
        &#125; catch (Throwable t) &#123;
        &#125;
    &#125;
    if (!mappedTypeFound) &#123;
        // 调用中间方法 register(Class, TypeHandler)
        register((Class&lt;T&gt;) null, typeHandler);
    &#125;
&#125;
public &lt;T&gt; void register(
    Class&lt;T&gt; javaType, TypeHandler&lt;? extends T&gt; typeHandler) &#123;
    // 调用中间方法 register(Type, TypeHandler)
    register((Type) javaType, typeHandler);
&#125;
</code></pre>
<p>上面的代码比较多,不过不用太担心。不管是通过注解的方式,还是通过反射的方式,它们最终目的是为了解析出 javaType 的值。解析完成后,这些方法会调用中间方法<code>register(Type,TypeHandler)</code>,这个方法负责解析 jdbcType,该方法上一节已经分析过。一个负责解析 javaType,另一个负责解析 jdbcType,逻辑比较清晰了。那我们趁热打铁,继续分析下一个注册方法,编号为1。</p>
<h3 id="register-String-方法分析"><a href="#register-String-方法分析" class="headerlink" title="register(String)方法分析"></a>register(String)方法分析</h3><p>本节代码的主要是用于自动扫描类型处理器,并调用其他方法注册扫描结果。该方法的分析如下:</p>
<pre><code class="java">public void register(String packageName) &#123;
    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;();
    // 从指定包中查找 TypeHandler
    resolverUtil.find(new ResolverUtil.IsA(TypeHandler.class), packageName);
    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; handlerSet = resolverUtil.getClasses();
    for (Class&lt;?&gt; type : handlerSet) &#123;
        // 忽略内部类,接口,抽象类等
        if (!type.isAnonymousClass() &amp;&amp; !type.isInterface()
            &amp;&amp; !Modifier.isAbstract(type.getModifiers())) &#123;
            // 调用注册方法 4
            register(type);
        &#125;
    &#125;
&#125;
</code></pre>
<p>上面代码的逻辑比较简单,其中注册方法4已经在上一节分析过了,这里就不多说了。由以上分析可知,类型处理器的解析过程不复杂,但是注册过程由于重载方法间相互调用,导致调用路线比较复杂。这个时候需要想办法理清方法的调用路线,理清后,整个逻辑就清晰明了了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章对 MyBatis 配置文件中<code>&lt;properties&gt;</code>、<code>&lt;settings&gt;</code>、<code>&lt;typeAliase&gt;</code>、<code>&lt;typeHandlers&gt;</code>等节点的解析过程进行了详细的分析。本章所关注的点不局限于这些节点的解析过程,在此过程中,本章额外分析了其他模块的一些源码。这些模块在随后的章节中还会出现,大家应尽量搞懂这些模块源码</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/mybatis/" rel="tag"># mybatis</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/07/leetcode-1/" rel="prev" title="leetcode#1">
      <i class="fa fa-chevron-left"></i> leetcode#1
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/09/spring-4-xml%E5%92%8Canno%E7%9A%84%E5%8D%95%E8%A1%A8CRUD/" rel="next" title="spring#4-xml和anno的单表CRUD">
      spring#4-xml和anno的单表CRUD <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">配置文件解析过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-lt-properties-gt-%E8%8A%82%E7%82%B9"><span class="nav-text">解析&lt;properties&gt;节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-lt-settings-gt-%E8%8A%82%E7%82%B9"><span class="nav-text">解析&lt;settings&gt;节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E4%BF%A1%E6%81%AF%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-text">元信息对象创建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DefaultReflectorFactory"><span class="nav-text">DefaultReflectorFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflector"><span class="nav-text">Reflector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflector-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90"><span class="nav-text">Reflector 构造方法及成员变量分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getter-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-text">getter 方法解析过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setter-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-text">setter 方法解析过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PropertyTokenizer"><span class="nav-text">PropertyTokenizer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE-lt-settings-gt-%E5%86%85%E5%AE%B9%E5%88%B0-Configuration-%E4%B8%AD"><span class="nav-text">设置&lt;settings&gt;内容到 Configuration 中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-lt-typeAliases-gt-%E8%8A%82%E7%82%B9"><span class="nav-text">解析&lt;typeAliases&gt;节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8EtypeAlias%E8%8A%82%E7%82%B9%E4%B8%AD%E8%A7%A3%E6%9E%90%E5%B9%B6%E6%B3%A8%E5%86%8C%E5%88%AB%E5%90%8D"><span class="nav-text">从typeAlias节点中解析并注册别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8C%85%E4%B8%AD%E8%A7%A3%E6%9E%90%E5%B9%B6%E6%B3%A8%E5%86%8C%E5%88%AB%E5%90%8D"><span class="nav-text">从指定的包中解析并注册别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C-MyBatis-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%AB%E5%90%8D"><span class="nav-text">注册 MyBatis 内部类及常见类型的别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-lt-plugins-gt-%E8%8A%82%E7%82%B9"><span class="nav-text">解析&lt;plugins&gt;节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-lt-environments-gt-%E8%8A%82%E7%82%B9"><span class="nav-text">解析&lt;environments&gt;节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90-lt-typeHandlers-gt-%E8%8A%82%E7%82%B9"><span class="nav-text">解析&lt;typeHandlers&gt;节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#register-Class-JdbcType-Class-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">register(Class,JdbcType,Class)方法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#register-Class-Class-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">register(Class,Class)方法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#register-Class-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">register(Class)方法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#register-String-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">register(String)方法分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
