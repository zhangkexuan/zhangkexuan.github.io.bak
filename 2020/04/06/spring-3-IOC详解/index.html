<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="详解spring的核心IOC">
<meta property="og:type" content="article">
<meta property="og:title" content="spring#3-IOC详解">
<meta property="og:url" content="http://yoursite.com/2020/04/06/spring-3-IOC%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="详解spring的核心IOC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/container-magic.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/singleton.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/prototype.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/aop-proxy-plain-pojo-call.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/aop-proxy-call.jpg">
<meta property="article:published_time" content="2020-04-06T14:31:55.000Z">
<meta property="article:modified_time" content="2021-05-19T02:17:38.521Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="java">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="IOC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/container-magic.jpg">

<link rel="canonical" href="http://yoursite.com/2020/04/06/spring-3-IOC%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>spring#3-IOC详解 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/06/spring-3-IOC%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          spring#3-IOC详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 22:31:55" itemprop="dateCreated datePublished" datetime="2020-04-06T22:31:55+08:00">2020-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>详解spring的核心IOC</p>
<span id="more"></span>

<h1 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h1><h2 id="1-IoC-容器"><a href="#1-IoC-容器" class="headerlink" title="1. IoC 容器"></a>1. IoC 容器</h2><p>本章介绍 Spring 的控制反转(IoC)容器。</p>
<h3 id="1-1-Spring-IoC-容器和-Beans-简介"><a href="#1-1-Spring-IoC-容器和-Beans-简介" class="headerlink" title="1.1. Spring IoC 容器和 Beans 简介"></a>1.1. Spring IoC 容器和 Beans 简介</h3><p>本章介绍了控制反转(IoC)原理的 Spring Framework implementation。 (参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/overview.html#background-ioc">控制反转</a> .) IoC 也称为依赖注入(DI)。它是一个 process，其中 objects 仅通过构造函数 arguments，工厂方法的 arguments 或者属性的 properties 来定义它们的依赖项(即，它们使用的其他 objects)。在构造或从工厂方法返回后，在 object 实例上设置。然后容器在创建 bean 时注入这些依赖项。这个 process 基本上是 bean 本身控制实例化的逆(故名，控制反转)或者通过使用 classes 的直接构造或诸如 Service Locator pattern 之类的机制来确定其依赖关系的位置。</p>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是 Spring Framework 的 IoC 容器的基础。 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html">BeanFactory</a>接口提供了一种高级 configuration 机制，能够管理任何类型的 object。 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html">ApplicationContext</a>是<code>BeanFactory</code>的 sub-interface。它补充说：</p>
<ul>
<li>使用 Spring 的 AOP features 更容易整合</li>
<li>消息资源处理(用于国际化)</li>
<li>Event 出版</li>
<li>Application-layer 特定的上下文，例如用于 web applications。</li>
</ul>
<p>简而言之，<code>BeanFactory</code>提供 configuration framework 和基本功能，<code>ApplicationContext</code>添加更多 enterprise-specific 功能。 <code>ApplicationContext</code>是<code>BeanFactory</code>的完整超集，在本章中专门用于 Spring 的 IoC 容器的描述。有关使用<code>BeanFactory</code>而不是<code>ApplicationContext</code>的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanfactory">BeanFactory</a>。</p>
<p>在 Spring 中，构成 application 主干并由 Spring IoC 容器管理的 objects 称为 beans。 _ bean 是一个 object，它由 Spring IoC 容器实例化，组装和管理。否则，bean 只是 application 中许多 object 之一。 Beans 及其之间的依赖关系反映在容器使用的 configuration 元数据中。</p>
<h3 id="1-2-容器概述"><a href="#1-2-容器概述" class="headerlink" title="1.2. 容器概述"></a>1.2. 容器概述</h3><p><code>org.springframework.context.ApplicationContext</code>接口表示 Spring IoC 容器，负责实例化，配置和组装 beans。容器通过读取 configuration 元数据获取有关 objects 实例化，配置和汇编的指令。 configuration 元数据以 XML，Java annotations 或 Java code 表示。它允许您表达组成您的 application 的 objects 以及这些 objects 之间丰富的相互依赖关系。</p>
<p>Spring 提供了<code>ApplicationContext</code>接口的几个 implementation。在 stand-alone applications 中，通常创建 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html">ClassPathXmlApplicationContext</a> 或 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html">FileSystemXmlApplicationContext</a> 实例。虽然 XML 是定义配置元数据的传统格式，但您可以通过提供少量 XML 配置来声明性地启用对 Java 注解或者代码这些其他元数据格式的支持。</p>
<p>在大多数 application 场景中，不需要用户显示的实例化 Spring IoC 容器的一个或多个实例。例如，在 web application 场景中，application 的<code>web.xml</code>文件中的简单八行(或左右)的样板代码通常就足够了(参见 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#context-create">Convenient ApplicationContext Instantiation for Web Applications</a>)。如果使用<a target="_blank" rel="noopener" href="https://spring.io/tools/sts">Spring 工具套件</a>(STS, Eclipse-powered 开发环境)，只需单击几下鼠标或按键即可轻松创建此样板配置文件。</p>
<p>下图显示了 Spring 如何工作的 high-level 视图。您的 application classes 与 configuration 元数据结合使用，以便在创建和初始化<code>ApplicationContext</code>之后，您拥有一个完全配置且可执行的系统或应用。</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/container-magic.jpg" alt="容器魔术"></p>
<p>图 1. Spring IoC 容器</p>
<h4 id="1-2-1-Configuration-元数据"><a href="#1-2-1-Configuration-元数据" class="headerlink" title="1.2.1. Configuration 元数据"></a>1.2.1. Configuration 元数据</h4><p>如上图所示，Spring IoC 容器使用一种 configuration 元数据。此 configuration 元数据表示作为 application 开发人员如何告诉 Spring 容器在 application 中实例化，配置和组装 objects。</p>
<p>Configuration 元数据传统上以简单直观的 XML 格式提供，本章大部分内容用于传达 Spring IoC 容器的 key 概念和 features。</p>
<blockquote>
<p>基于 XML 的元数据不是唯一允许的配置元数据形式。 Spring IoC 容器本身与实际编写此 configuration 元数据的格式完全分离。现在，许多开发人员选择 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-java">基于Java的配置</a> 作为他们开发的 Spring 应用。</p>
</blockquote>
<p>有关在 Spring 容器中使用其他形式的元数据的信息，请参阅：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-annotation-config">基于注解的配置</a>：Spring 2.5 引入了对 annotation-based configuration 元数据的支持。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-java">基于Java的配置</a>：从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多 features 成为 Spring Framework 核心的一部分。因此，您可以使用 Java 而不是 XML 文件定义 application classes 外部的 beans。要使用这些新的 features，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html">@Import</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html">@DependsOn</a> 注释。</li>
</ul>
<p>Spring 配置方式至少包含一种并且通常容器必须管理多个 bean 定义。 基于 XML 配置的元数据将 beans 配置为 top-level <code>&lt;beans/&gt;</code>元素内的<code>&lt;bean/&gt;</code>元素。 Java 配置通常在<code>@Configuration</code> 标记的类中使用<code>@Bean</code> 注释的方法。</p>
<p>这些 bean 定义对应于构成应用的实际对象。通常，您定义服务层对象，数据访问对象(DAO)，表示对象(如 Struts <code>Action</code>实例)，基础结构对象(如 Hibernate <code>SessionFactories</code>，JMS <code>Queues</code>等)。通常，不会在容器中配置 fine-grained domain objects，因为它通常是 DAO 和业务逻辑负责创建和加载 domain objects。但是，您可以通过 Spring 与 AspectJ 整合来配置在 IoC 容器控制之外创建的 objects。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-atconfigurable">使用 AspectJ 与 Spring 注入 domain objects</a>。</p>
<p>以下示例展示了基于 XML 配置的元数据的基本结构：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  (1) (2)
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions go here --&gt;

&lt;/beans&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>id</code>属性是一个 string，用于标识单个 bean 定义。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><code>class</code>属性定义 bean 的类型并需要使用完全限定的类名。</td>
</tr>
</tbody></table>
<p><code>id</code>属性的 value 指的是协作 objects。用于引用协作 objects 的 XML 未在此示例中显示。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-dependencies">依赖</a>。</p>
<h4 id="1-2-2-实例化容器"><a href="#1-2-2-实例化容器" class="headerlink" title="1.2.2. 实例化容器"></a>1.2.2. 实例化容器</h4><p>提供给<code>ApplicationContext</code>构造函数的一个或多个字符串类型的位置路径，它允许容器从各种外部资源(例如本地文件系统，Java <code>CLASSPATH</code>等)加载 configuration 元数据。</p>
<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
</code></pre>
<blockquote>
<p>在了解 Spring 的 IoC 容器之后，您可能想要了解更多关于 Spring 的<code>Resource</code>抽象(如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources">资源</a>中所述)，它提供了一种从 URI 语法中定义的位置读取 InputStream 的便捷机制。特别是，<code>Resource</code> 路径用于构造 applications 上下文，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-app-ctx">Application Contexts 和 Resource Paths</a>中所述。</p>
</blockquote>
<p>以下示例显示了服务层对象 <code>(services.xml)</code> 配置文件：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!-- services --&gt;

    &lt;bean id=&quot;petStore&quot; class=&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;&gt;
        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;
        &lt;property name=&quot;itemDao&quot; ref=&quot;itemDao&quot;/&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for services go here --&gt;

&lt;/beans&gt;
</code></pre>
<p>以下示例显示了数据访问对象(DAO) <code>daos.xml</code>文件：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;accountDao&quot;
        class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;itemDao&quot; class=&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for data access objects go here --&gt;

&lt;/beans&gt;
</code></pre>
<p>在前面的示例中，服务层由<code>PetStoreServiceImpl</code> class 和两个类型<code>JpaAccountDao</code>和<code>JpaItemDao</code>的数据访问对象(DAO)组成(基于 JPA Object-Relational Mapping 标准)。 <code>property name</code>元素引用 JavaBean property 的 name，<code>ref</code>元素引用另一个 bean 定义的 name。 <code>id</code>和<code>ref</code>元素之间的这种联系表达了协作 objects 之间的依赖关系。有关配置 object 依赖项的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-dependencies">依赖</a>。</p>
<h5 id="撰写基于-XML-配置的元数据"><a href="#撰写基于-XML-配置的元数据" class="headerlink" title="撰写基于 XML 配置的元数据"></a>撰写基于 XML 配置的元数据</h5><p>使 bean 定义在多个 XML 文件中非常有用。通常，每个单独的 XML 配置文件代表应用架构中的逻辑层或模块。</p>
<p>您可以使用 application context 构造函数从所有这些 XML 片段加载 bean 定义。此构造函数传递多个<code>Resource</code>路径，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-instantiation">上一节</a>中所示。或者，使用一个或多个<code>&lt;import/&gt;</code>元素来从一个文件或多个文件加载 bean 定义。以下示例显示了如何执行此操作：</p>
<pre><code>&lt;beans&gt;
    &lt;import resource=&quot;services.xml&quot;/&gt;
    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;
    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;

    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;
    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>在前面的 example 中，外部 bean 定义从三个 files 加载：<code>services.xml</code>，<code>messageSource.xml</code>和<code>themeSource.xml</code>。所有位置路径都与执行 importing 的定义文件相关，因此 <code>services.xml</code> 必须与执行 importing 的文件位于同一目录或 classpath 位置，而<code>messageSource.xml</code>和<code>themeSource.xml</code>必须位于 importing 文件位置下方的<code>resources</code>位置。如您所见，忽略前导斜杠。但是，鉴于这些_path 是相对的，最好不要使用斜杠。根据 Spring Schema，导入的 files 的内容(包括 top level <code>&lt;beans/&gt;</code>元素)必须是有效的 XML bean 定义。</p>
<blockquote>
<p>使用相对“../”路径在 parent 目录中 reference files 是可行的，但不建议这样做。这样做会对当前 application 之外的文件创建依赖关系。特别是，不建议对<code>classpath:</code> URL(对于 example，<code>classpath:../services.xml</code>)使用该方式，其中运行时解析 process 选择“最近的”classpath 根，然后查看其 parent 目录。 Classpath configuration 更改可能导致选择不同的，不正确的目录。</p>
</blockquote>
<p>您始终可以使用完全限定的资源位置而不是相对路径：例如，<code>file:C:/config/services.xml</code>或<code>classpath:/config/services.xml</code>。但是，请注意您的 application 的配置文件将与特定的绝对位置耦合。通常最好为这样的绝对位置保持间接 - 例如，通过在运行时针对 JVM 系统 properties 解析的“$ {}”占位符。</p>
<p>命名空间本身提供 import 指令功能。 Spring 提供的一系列 XML 命名空间（例如，context 和 util 名称空间）中提供了普通 bean 定义之外的其他配置功能。</p>
<h5 id="Groovy-Bean-定义-DSL"><a href="#Groovy-Bean-定义-DSL" class="headerlink" title="Groovy Bean 定义 DSL"></a>Groovy Bean 定义 DSL</h5><p>作为外部化配置元数据的进一步示例，bean 定义也可以在 Spring 的 Groovy Bean Definition DSL 中表示，如 Grails framework 中所知。通常，此类 configuration 存在于“.groovy”文件中，其结构如下所示：</p>
<pre><code>beans &#123;
    dataSource(BasicDataSource) &#123;
        driverClassName = &quot;org.hsqldb.jdbcDriver&quot;
        url = &quot;jdbc:hsqldb:mem:grailsDB&quot;
        username = &quot;sa&quot;
        password = &quot;&quot;
        settings = [mynew:&quot;setting&quot;]
    &#125;
    sessionFactory(SessionFactory) &#123;
        dataSource = dataSource
    &#125;
    myService(MyService) &#123;
        nestedBean = &#123; AnotherBean bean -&gt;
            dataSource = dataSource
        &#125;
    &#125;
&#125;
</code></pre>
<p>这种 configuration 样式在很大程度上等同于 XML bean 定义，甚至支持 Spring 的 XML configuration 命名空间。它还允许通过<code>importBeans</code>指令 importing XML bean definition files。</p>
<h4 id="1-2-3-使用容器"><a href="#1-2-3-使用容器" class="headerlink" title="1.2.3. 使用容器"></a>1.2.3. 使用容器</h4><p><code>ApplicationContext</code>是高级工厂的接口，能够维护不同 beans 及其依赖项的注册表。通过使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，您可以检索 beans 的实例。</p>
<p><code>ApplicationContext</code>允许您读取 bean 定义并访问它们，如下面的 example 所示：</p>
<pre><code>// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);

// retrieve configured instance
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);

// use configured instance
List&lt;String&gt; userList = service.getUsernameList();
</code></pre>
<p>使用 Groovy configuration，bootstrapping 看起来非常相似。它有一个不同的 context implementation class，它是 Groovy-aware(但也理解 XML bean 定义)。以下 example 显示了 Groovy configuration：</p>
<pre><code>ApplicationContext context = new GenericGroovyApplicationContext(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
</code></pre>
<p>最灵活的变体是<code>GenericApplicationContext</code>与 reader 委托相结合 - 例如，表示 XML files，如下面的 example 所示：</p>
<pre><code>GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;);
context.refresh();
</code></pre>
<p>您还可以使用<code>GroovyBeanDefinitionReader</code> for Groovy files，如下面的 example 所示：</p>
<pre><code>GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
context.refresh();
</code></pre>
<p>您可以在同一个<code>ApplicationContext</code>上混合和 match 这样的 reader 委托，从不同的 configuration 源读取 bean 定义。</p>
<p>然后，您可以使用<code>getBean</code>来检索 beans 的实例。 <code>ApplicationContext</code>接口还有一些其他方法可以检索 beans，但理想情况下，application code 应该永远不会使用它们。实际上，你的 application code 根本不应该对<code>getBean()</code>方法有 calls，因此根本不依赖于 Spring API。例如，Spring 与 web 框架的 integration 为各种 web framework 组件(如控制器和 JSF-managed beans)提供依赖注入，让您通过元数据(例如自动装配 annotation)声明对特定 bean 的依赖。</p>
<h3 id="1-3-Bean-概述"><a href="#1-3-Bean-概述" class="headerlink" title="1.3. Bean 概述"></a>1.3. Bean 概述</h3><p>Spring IoC 容器管理一个或多个 beans。这些 beans 是使用您提供给容器的 configuration 元数据创建的(对于 example，以 XML <code>&lt;bean/&gt;</code>定义的形式)。</p>
<p>在容器本身中，这些 bean 定义表示为<code>BeanDefinition</code> objects，其中包含(以及其他信息)以下元数据：</p>
<ul>
<li>package-qualified class name：通常是bean 被定义的实际实现类。</li>
<li>Bean 行为 configuration 元素，它们 state bean 应该如何在容器中运行(范围，生命周期回调等)。</li>
<li>引用 bean 执行其工作所需的其他 beans。这些 references 也称为协作者或依赖项。</li>
<li>要在新创建的 object 中设置的其他 configuration 设置 - 用于 example，池的大小限制或在管理连接池的 bean 中使用的连接数。</li>
</ul>
<p>此元数据转换为构成每个 bean 定义的一组 properties。以下 table 描述了这些 properties：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>解释在……</th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class">实例化 Beans</a></td>
</tr>
<tr>
<td>Name</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanname">命名 Beans</a></td>
</tr>
<tr>
<td>Scope</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">Bean的作用域</a></td>
</tr>
<tr>
<td>Constructor arguments</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators=">依赖注入</a></td>
</tr>
<tr>
<td>Properties</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators">依赖注入</a></td>
</tr>
<tr>
<td>Autowiring mode</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">自动化协作者</a></td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lazy-init">Lazy-initialized Beans</a></td>
</tr>
<tr>
<td>Initialization method</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">初始化回调</a></td>
</tr>
<tr>
<td>Destruction method</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean">毁灭回调</a></td>
</tr>
</tbody></table>
<p>除了包含有关如何创建特定 bean 的信息的 bean 定义之外，<code>ApplicationContext</code> implementations 还允许注册在容器外部(由用户)创建的现有 objects。这是通过<code>getBeanFactory()</code>方法访问 ApplicationContext 的 BeanFactory 来完成的，该方法返回 BeanFactory <code>DefaultListableBeanFactory</code> implementation。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法支持此注册。但是，典型的 applications 只能使用通过常规 bean 定义元数据定义的 beans。</p>
<blockquote>
<p>Bean 元数据和手动提供的 singleton 实例需要尽早注册，以便容器在自动装配和其他内省步骤中正确推理它们。虽然在某种程度上支持覆盖现有元数据和现有 singleton 实例，但是在运行时注册新的 beans(与对工厂的实时访问同时)并未得到官方支持，并且可能导致并发访问 exceptions，bean 容器中的 state 不一致，或者都。</p>
</blockquote>
<h4 id="1-3-1-命名-Beans"><a href="#1-3-1-命名-Beans" class="headerlink" title="1.3.1. 命名 Beans"></a>1.3.1. 命名 Beans</h4><p>每个 bean 都有一个或多个标识符。这些标识符在承载 bean 的容器中必须是唯一的。 bean 通常只有一个标识符。但是，如果它需要多个，则额外的可以被视为别名。</p>
<p>在 XML-based configuration 元数据中，使用<code>id</code>属性，<code>name</code>属性或两者来指定 bean 标识符。 <code>id</code>属性允许您指定一个 id。通常，这些名称是字母数字(‘myBean’，’someService’，etc.)，但它们也可以包含特殊字符。如果要为 bean 引入其他别名，您还可以在<code>name</code>属性中指定它们，由 a 分隔逗号(<code>,</code>)，分号(<code>;</code>)或空格。作为历史记录，在 Spring 3.1 之前的版本中，<code>id</code>属性被定义为<code>xsd:ID</code>类型，它约束了可能的字符。从 3.1 开始，它被定义为<code>xsd:string</code> type。请注意，bean <code>id</code> uniqueness 仍由容器强制执行，但不再由 XML 解析器强制执行。</p>
<p>您不需要为 bean 提供<code>name</code>或<code>id</code>。如果您没有显式提供<code>name</code>或<code>id</code>，则容器会为该 bean 生成唯一的 name。但是，如果要通过 name 引用 bean，通过使用<code>ref</code>元素或<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-servicelocator">服务定位器</a>样式查找，则必须提供 name。不提供 name 的动机与使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-inner-beans">内豆</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">自动装配合作者</a>有关。</p>
<p>Bean 命名约定</p>
<p>约定是在命名 beans 时使用标准 Java 约定作为实例字段名称。也就是说，bean 名称以小写字母开头，并且从那里开始 camel-cased。此类名称的示例包括<code>accountManager</code>，<code>accountService</code>，<code>userDao</code>，<code>loginController</code>等。</p>
<p>命名 beans 始终使您的 configuration 更容易阅读和理解。此外，如果您使用 Spring AOP，则在将建议应用于 name 相关的一组 beans 时会有很大帮助。</p>
<blockquote>
<p>使用 classpath 中的 component 扫描，Spring 按照前面描述的规则为未命名的组件生成 bean 名称：基本上，使用简单的 class name 并将其初始字符转换为 lower-case。但是，在(不常见的)特殊情况下，当有多个字符且第一个和第二个字符都是大写字母时，原始外壳将被保留。这些规则与<code>java.beans.Introspector.decapitalize</code>(Spring 在此处使用)中定义的规则相同。</p>
</blockquote>
<h5 id="在-Bean-定义之外别名-Bean"><a href="#在-Bean-定义之外别名-Bean" class="headerlink" title="在 Bean 定义之外别名 Bean"></a>在 Bean 定义之外别名 Bean</h5><p>在 bean 定义本身中，通过使用<code>id</code>属性指定的最多一个 name 和<code>name</code>属性中的任意数量的其他名称，可以为 bean 提供多个 name。这些名称可以是同一 bean 的等效别名，并且在某些情况下很有用，例如让 application 中的每个 component 通过使用特定于该 component 本身的 bean name 来引用 common 依赖项。</p>
<p>但是，指定实际定义 bean 的所有别名并不总是足够的。有时需要为其他地方定义的 bean 引入别名。在大型系统中通常就是这种情况，其中 configuration 在每个子系统之间分配，每个子系统都有自己的 object 定义集。在 XML-based configuration 元数据中，您可以使用<code>&lt;alias/&gt;</code>元素来完成此操作。以下 example 显示了如何执行此操作：</p>
<pre><code>&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;
</code></pre>
<p>在这种情况下，在使用此别名定义之后，名为<code>fromName</code>的 bean(在同一容器中)也可以称为<code>toName</code>。</p>
<p>例如，子系统 A 的 configuration 元数据可以通过<code>subsystemA-dataSource</code>的 name 引用 DataSource。子系统 B 的 configuration 元数据可以通过<code>subsystemB-dataSource</code>的 name 引用 DataSource。在编写使用这两个子系统的主 application 时，main application 通过<code>myApp-dataSource</code>的 name 引用 DataSource。要使所有三个名称引用相同的 object，可以将以下别名定义添加到 configuration 元数据中：</p>
<pre><code>&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt;
&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;
</code></pre>
<p>现在每个 component 和 main application 都可以通过 name 来引用 dataSource，该 name 是唯一的，并且保证不与任何其他定义冲突(有效地创建命名空间)，但它们引用相同的 bean。</p>
<p>Java-configuration</p>
<p>如果使用 Javaconfiguration，则<code>@Bean</code> annotation 可用于提供别名。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-bean-annotation">使用 @Bean Annotation</a>。</p>
<h4 id="1-3-2-实例化-Beans"><a href="#1-3-2-实例化-Beans" class="headerlink" title="1.3.2. 实例化 Beans"></a>1.3.2. 实例化 Beans</h4><p>bean 定义本质上是 creating 一个或多个 objects 的配方。容器在询问时查看命名 bean 的配方，并使用由 bean 定义封装的 configuration 元数据来创建(或获取)实际的 object。</p>
<p>如果使用 XML-based configuration 元数据，则指定要在<code>&lt;bean/&gt;</code>元素的<code>class</code>属性中实例化的 object 的类型(或 class)。这个<code>class</code>属性(内部是<code>BeanDefinition</code>实例上的<code>Class</code> property)通常是强制性的。 (对于 exceptions，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class-instance-factory-method">使用实例工厂方法实例化</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-child-bean-definitions">Bean 定义继承</a> .)您可以通过以下两种方式之一使用<code>Class</code> property：</p>
<ul>
<li>通常，要指定在容器本身通过反射调用其构造函数直接创建 bean 的情况下构造的 bean class，有点等同于运算符的 Java code。</li>
<li>要指定包含工厂方法的实际 class，该方法被调用以创建 object，在较少 common 的情况下，容器在 class 上调用<code>static</code>工厂方法来创建 bean。从<code>static</code>工厂方法的调用返回的 object 类型可能完全是相同的 class 或另一个 class。</li>
</ul>
<p>内部 class 名称</p>
<p>如果要为<code>static</code>嵌套 class 配置 bean 定义，则必须使用嵌套 class 的二进制 name。</p>
<p>例如，如果在<code>com.example</code>包中有一个名为<code>SomeThing</code>的 class，并且<code>SomeThing</code> class 有一个<code>static</code>嵌套 class，名为<code>OtherThing</code>，则 bean</p>
<p>注意在 name 中使用<code>$</code>字符将嵌套的 class name 与外部 class name 分开。</p>
<h5 id="使用构造函数实例化"><a href="#使用构造函数实例化" class="headerlink" title="使用构造函数实例化"></a>使用构造函数实例化</h5><p>当您通过构造方法创建 bean 时，所有正常的 classes 都可以使用 Spring 并与之兼容。也就是说，正在开发的 class 不需要实现任何特定接口或以特定方式编码。只需指定 bean class 就足够了。但是，根据您为特定 bean 使用的 IoC 类型，您可能需要一个默认(空)构造函数。</p>
<p>Spring IoC 容器几乎可以管理您希望它管理的任何 class。它不仅限于管理 true JavaBeans。大多数 Spring 用户更喜欢实际的 JavaBeans，只有一个默认的(no-argument)构造函数，并且在容器中的 properties 之后建模了适当的 setter 和 getter。您还可以在容器中拥有更多异域 non-bean-style classes。例如，对于 example，您需要使用绝对不符合 JavaBean 规范的 legacy 连接池，Spring 也可以对其进行管理。</p>
<p>使用 XML-based configuration 元数据，您可以指定 bean class，如下所示：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;/&gt;

&lt;bean name=&quot;anotherExample&quot; class=&quot;examples.ExampleBeanTwo&quot;/&gt;
</code></pre>
<p>有关在构造 object 之后向构造函数提供 arguments(如果需要)和设置 object instance properties 的机制的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators">注入依赖关系</a>。</p>
<h5 id="使用静态工厂方法实例化"><a href="#使用静态工厂方法实例化" class="headerlink" title="使用静态工厂方法实例化"></a>使用静态工厂方法实例化</h5><p>定义使用静态工厂方法创建的 bean 时，请使用<code>class</code>属性指定包含<code>static</code>工厂方法的 class 和名为<code>factory-method</code>的属性，以指定工厂方法本身的 name。您应该能够调用此方法(使用可选的 arguments，如稍后所述)并 return live object，后来被视为通过构造函数创建。这种 bean 定义的一个用途是在 legacy code 中调用<code>static</code>工厂。</p>
<p>以下 bean 定义指定通过调用工厂方法来创建 bean。该定义未指定返回的 object 的类型(class)，仅指定包含工厂方法的 class。在此 example 中，<code>createInstance()</code>方法必须是静态方法。以下 example 显示了如何指定工厂方法：</p>
<pre><code>&lt;bean id=&quot;clientService&quot;
    class=&quot;examples.ClientService&quot;
    factory-method=&quot;createInstance&quot;/&gt;
</code></pre>
<p>以下 example 显示了一个可以使用前面的 bean 定义的 class：</p>
<pre><code>public class ClientService &#123;
    private static ClientService clientService = new ClientService();
    private ClientService() &#123;&#125;

    public static ClientService createInstance() &#123;
        return clientService;
    &#125;
&#125;
</code></pre>
<p>有关在工厂返回 object 之后向工厂方法提供(可选)arguments 并设置 object instance properties 的机制的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-properties-detailed">详细信息中的依赖关系和 Configuration</a>。</p>
<h5 id="使用实例工厂方法实例化"><a href="#使用实例工厂方法实例化" class="headerlink" title="使用实例工厂方法实例化"></a>使用实例工厂方法实例化</h5><p>与通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class-static-factory-method">静态工厂方法</a>进行实例化类似，使用实例工厂方法进行实例化会从容器中调用现有 bean 的 non-static 方法来创建新的 bean。要使用此机制，请将<code>class</code>属性保留为空，并在<code>factory-bean</code>属性中，在当前(或 parent 或 ancestor)容器中指定 bean 的 name，该容器包含要调用以创建 object 的实例方法。使用<code>factory-method</code>属性设置工厂方法本身的 name。以下 example 显示了如何配置这样的 bean：</p>
<pre><code>&lt;!-- the factory bean, which contains a method called createInstance() --&gt;
&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;!-- the bean to be created via the factory bean --&gt;
&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;
</code></pre>
<p>以下 example 显示了相应的 Java class：</p>
<pre><code>public class DefaultServiceLocator &#123;

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() &#123;
        return clientService;
    &#125;
&#125;
</code></pre>
<p>一个工厂 class 也可以包含多个工厂方法，如下面的示例所示：</p>
<pre><code>&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;

&lt;bean id=&quot;accountService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createAccountServiceInstance&quot;/&gt;
</code></pre>
<p>以下 example 显示了相应的 Java class：</p>
<pre><code>public class DefaultServiceLocator &#123;

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() &#123;
        return clientService;
    &#125;

    public AccountService createAccountServiceInstance() &#123;
        return accountService;
    &#125;
&#125;
</code></pre>
<p>这种方法表明工厂 bean 本身可以通过依赖注入(DI)进行管理和配置。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-properties-detailed">详细信息中的依赖关系和 Configuration</a>。</p>
<blockquote>
<p>在 Spring 文档中，“factory bean”指的是 Spring 容器中配置的 bean，它通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class-instance-factory-method">例</a>或<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class-static-factory-method">静态</a>工厂方法创建 objects。相比之下，<code>FactoryBean</code>(注意大写)指的是 Spring-specific <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension-factorybean">FactoryBean</a>。</p>
</blockquote>
<h3 id="1-4-依赖"><a href="#1-4-依赖" class="headerlink" title="1.4. 依赖"></a>1.4. 依赖</h3><p>典型的企业应用程序不包含单个 object(或 Spring 用语中的 bean)。即使是最简单的 application 也有一些 objects 可以协同工作来呈现 end-user 所看到的连贯应用程序。下一节将介绍如何定义一些独立的 bean 定义到完全实现的 application，其中 objects 协作实现目标。</p>
<h4 id="1-4-1-依赖注入"><a href="#1-4-1-依赖注入" class="headerlink" title="1.4.1. 依赖注入"></a>1.4.1. 依赖注入</h4><p>依赖注入(DI)是一个 process，其中 objects 仅通过构造函数 arguments，工厂方法的 arguments 或 object 实例在构造之后设置的 properties 定义它们的依赖项(即，它们工作的其他 objects)或者从工厂方法返回。然后容器在创建 bean 时注入这些依赖项。这个 process 基本上是 bean 本身的逆(因此 name，控制反转)，它通过使用 classes 或 Service Locator pattern 的直接构造来控制其依赖项的实例化或位置。</p>
<p>使用 DI 原理，Code 更干净，当 objects 具有依赖关系时，解耦更有效。 object 不查找其依赖项，也不知道依赖项的位置或 class。因此，您的 classes 变得更容易测试，特别是当依赖关系在接口或 abstract base classes 上时，它们允许在单元测试中使用 stub 或 mock implementations。</p>
<p>DI 存在两种主要变体：<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-constructor-injection">Constructor-based 依赖注入</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-setter-injection">Setter-based 依赖注入</a>。</p>
<h5 id="Constructor-based-依赖注入"><a href="#Constructor-based-依赖注入" class="headerlink" title="Constructor-based 依赖注入"></a>Constructor-based 依赖注入</h5><p>Constructor-based DI 由容器调用具有多个 arguments 的构造函数完成，每个 arguments 表示一个依赖项。调用具有特定 arguments 的<code>static</code>工厂方法来构造 bean 几乎是等效的，本讨论同样将 arguments 视为构造函数和<code>static</code>工厂方法。以下 example 显示了一个只能使用构造函数注入 dependency-injected 的 class：</p>
<pre><code>public class SimpleMovieLister &#123;

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    // business logic that actually uses the injected MovieFinder is omitted...
&#125;
</code></pre>
<p>请注意，这个 class 没有什么特别之处。它是一个 POJO，它不依赖于容器特定的接口，base classes 或 annotations。</p>
<h6 id="构造函数参数解析"><a href="#构造函数参数解析" class="headerlink" title="构造函数参数解析"></a>构造函数参数解析</h6><p>通过使用参数的类型进行构造函数参数解析匹配。如果 bean 定义的构造函数 arguments 中不存在潜在的歧义，则在 bean 定义中定义构造函数 arguments 的 order 是 order，其中在实例化 bean 时将这些 arguments 提供给适当的构造函数。考虑以下 class：</p>
<pre><code>package x.y;

public class ThingOne &#123;

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) &#123;
        // ...
    &#125;
&#125;
</code></pre>
<p>假设<code>ThingTwo</code>和<code>ThingThree</code> classes 与继承无关，则不存在潜在的歧义。因此，以下 configuration 工作正常，您不需要在<code>&lt;constructor-arg/&gt;</code>元素中显式指定构造函数参数索引或类型。</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot;&gt;
        &lt;constructor-arg ref=&quot;thingTwo&quot;/&gt;
        &lt;constructor-arg ref=&quot;thingThree&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;thingTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;

    &lt;bean id=&quot;thingThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>当引用另一个 bean 时，类型是已知的，并且可以进行匹配(与前面的 example 的情况一样)。当使用简单类型(例如<code>&lt;value&gt;true&lt;/value&gt;</code>)时，Spring 无法确定 value 的类型，因此无法在没有帮助的情况下按类型匹配。考虑以下 class：</p>
<pre><code>package examples;

public class ExampleBean &#123;

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) &#123;
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    &#125;
&#125;
</code></pre>
<p>构造函数参数类型匹配</p>
<p>在前面的场景中，如果使用<code>type</code>属性显式指定构造函数参数的类型，则容器可以使用与简单类型匹配的类型。如下例所示：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>构造函数参数索引</p>
<p>您可以使用<code>index</code>属性显式指定构造函数 arguments 的索引，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>除了解决多个简单值的歧义之外，指定索引还可以解决构造函数具有两个相同类型的 arguments 的歧义。</p>
<blockquote>
<p>索引是 0-based。</p>
</blockquote>
<p>构造函数参数 name</p>
<p>您还可以使用构造函数参数 name 进行 value 消歧，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>请记住，要使这项工作开箱即用，必须在启用 debug flag 的情况下编译 code，以便 Spring 可以从构造函数中查找参数 name。如果您不能或不想使用 debug flag 编译 code，则可以使用<a target="_blank" rel="noopener" href="https://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a> JDK annotation 显式 name 构造函数 arguments。然后 sample class 必须如下所示：</p>
<pre><code>package examples;

public class ExampleBean &#123;

    // Fields omitted

    @ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)
    public ExampleBean(int years, String ultimateAnswer) &#123;
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    &#125;
&#125;
</code></pre>
<h5 id="Setter-based-依赖注入"><a href="#Setter-based-依赖注入" class="headerlink" title="Setter-based 依赖注入"></a>Setter-based 依赖注入</h5><p>Setter-based DI 是在调用 no-argument 构造函数或 no-argument <code>static</code>工厂方法来实例化 bean 之后，在 beans 上调用 setter 方法的容器来完成的。</p>
<p>以下 example 显示了一个 class，它只能通过使用纯 setter 注入来 dependency-injected。这个 class 是传统的 Java。它是一个 POJO，它不依赖于容器特定的接口，base classes 或 annotations。</p>
<pre><code>public class SimpleMovieLister &#123;

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    // business logic that actually uses the injected MovieFinder is omitted...
&#125;
</code></pre>
<p><code>ApplicationContext</code>支持它管理的 beans 的 constructor-based 和 setter-based DI。在通过构造函数方法注入了一些依赖项之后，它还支持 setter-based DI。您可以以<code>BeanDefinition</code>的形式配置依赖项，并将其与<code>PropertyEditor</code>实例结合使用，以将 properties 从一种格式转换为另一种格式。但是，大多数 Spring 用户不直接使用这些 classes(即以编程方式)，而是使用 XML <code>bean</code>定义，带注释的组件(即用，<code>@Controller</code>等注释的 classes)，或 Java-based <code>@Configuration</code> classes 中的<code>@Bean</code>方法。然后，这些源在内部转换为<code>BeanDefinition</code>的实例，并用于加载整个 Spring IoC 容器实例。</p>
<p>Constructor-based 或 setter-based DI？</p>
<p>由于您可以混合使用 constructor-based 和 setter-based DI，因此将构造函数用于强制依赖项和 setter 方法或使用 configuration 方法作为可选依赖项是一个很好的经验法则。请注意，在 setter 方法上使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-required-annotation">@Required</a> annotation 可用于使 property 成为必需的依赖项。</p>
<p>Spring 团队通常提倡构造函数注入，因为它允许您将 application 组件实现为不可变 objects 并确保所需的依赖项不是<code>null</code>。此外，constructor-injected 组件始终返回到完全初始化的 state 中的 client(调用)code。作为旁注，大量的构造函数 arguments 是一个糟糕的 code 气味，暗示 class 可能有太多的责任，应该重构以更好地解决关注点的正确分离。</p>
<p>Setter 注入应主要仅用于可在 class 中指定合理默认值的可选依赖项。否则，必须在 code 使用依赖项的任何位置执行 not-null 检查。 setter 注入的一个好处是 setter 方法使 class 的 objects 适合重新配置或 re-injection 以后。 因此，通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx">JMX MBeans</a>管理是一个引人注目的用于二传手注射的用例。</p>
<p>使用对特定 class 最有意义的 DI 样式。有时，在处理没有源的 third-party classes 时，会选择您。例如，如果 third-party class 没有公开任何 setter 方法，那么构造函数注入可能是唯一可用的 DI 形式。</p>
<h5 id="依赖性解决-Process"><a href="#依赖性解决-Process" class="headerlink" title="依赖性解决 Process"></a>依赖性解决 Process</h5><p>容器执行 bean 依赖项解析，如下所示：</p>
<ul>
<li>使用描述所有 beans 的 configuration 元数据创建和初始化<code>ApplicationContext</code>。 Configuration 元数据可以由 XML，Java code 或 annotations 指定。</li>
<li>对于每个 bean，其依赖关系以 properties，constructor arguments 或_ar_ments 的形式表示(如果使用它而不是普通的构造函数)。当实际创建 bean 时，这些依赖项将提供给 bean。</li>
<li>每个 property 或构造函数参数都是要设置的 value 的实际定义，或者是容器中另一个 bean 的 reference。</li>
<li>作为 value 的每个 property 或构造函数参数都从其指定的格式转换为该 property 或 constructor 参数的实际类型。默认情况下，Spring 可以将 string 格式提供的 value 转换为所有 built-in 类型，例如<code>int</code>，<code>long</code>，<code>String</code>，<code>boolean</code>等。</li>
</ul>
<p>Spring 容器在创建容器时验证每个 bean 的 configuration。但是，在实际创建 bean 之前，不会设置 bean properties 本身。创建容器时会创建 singleton-scoped 并设置为 pre-instantiated(默认值)的 Beans。范围在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">Bean 范围</a>中定义。否则，只有在请求时才会创建 bean。创建 bean 可能会导致创建 beans 图，因为 bean 的依赖项及其依赖项的依赖项(依此类推)会被创建和分配。请注意，这些依赖项之间的解决方案不匹配可能会显示较晚 - 也就是说，首次创建受影响的 bean 时。</p>
<p>循环依赖</p>
<p>如果您主要使用构造函数注入，则可以创建无法解析的循环依赖关系场景。</p>
<p>对于 example：Class A 需要通过构造函数注入实现 class B，而 class B 需要通过构造函数注入实现 class A.如果为 classes A 和 B 配置 beans 以相互注入，则 Spring IoC 容器会在运行时检测到此循环 reference，并抛出<code>BeanCurrentlyInCreationException</code>。</p>
<p>一种可能的解决方案是编辑某些 classes 的 source code，以便由 setter 而不是构造函数配置。或者，避免构造函数注入并仅使用 setter 注入。换句话说，尽管不推荐使用，但您可以使用 setter 注入配置循环依赖项。</p>
<p>与典型情况(没有循环依赖)不同，bean A 和 bean B 之间的循环依赖强制其中一个 beans 在完全初始化之前被注入另一个(经典的 chicken-and-egg 场景)。</p>
<p>您通常可以信任 Spring 做正确的事情。它在容器 load-time 处检测 configuration 问题，例如 reference to non-existent beans 和循环依赖项。 Spring sets properties 并在实际创建 bean 时尽可能晚地解析依赖项。这意味着正确加载的 Spring 容器以后可以在请求 object 时生成 exception，如果有问题创建 object 或其中一个依赖项 - 对于 example，bean 因缺少或无效而抛出 exception 属性。这可能会延迟一些 configuration 问题的可见性，这就是为什么<code>ApplicationContext</code> implementations 默认为 pre-instantiate singleton beans。以某些前期 time 和 memory 为代价，在实际需要之前创建这些 beans，您会在创建<code>ApplicationContext</code>时发现 configuration 问题，而不是以后。您仍然可以覆盖此默认行为，以便 singleton beans 懒惰地初始化，而不是 pre-instantiated。</p>
<p>如果不存在循环依赖关系，则当一个或多个协作 beans 被注入依赖 bean 时，每个协作 bean 在被注入依赖 bean 之前完全配置。这意味着，如果 bean A 依赖于 bean B，Spring IoC 容器在 bean A 上调用 setter 方法之前完全配置 bean B.换句话说，bean 被实例化(如果它不是 pre-instantiated singleton)，设置其依赖项，并调用相关的生命周期方法(例如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">配置的 init 方法</a>或<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">InitializingBean 回调方法</a>)。</p>
<h5 id="依赖注入的示例"><a href="#依赖注入的示例" class="headerlink" title="依赖注入的示例"></a>依赖注入的示例</h5><p>以下 example 使用 setter-based 配置元数据用于 setter-based DI。 Spring XML configuration 文件的一小部分指定了一些 bean 定义，如下所示：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;!-- setter injection using the nested ref element --&gt;
    &lt;property name=&quot;beanOne&quot;&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/property&gt;

    &lt;!-- setter injection using the neater ref attribute --&gt;
    &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;property name=&quot;integerProperty&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre>
<p>以下 example 显示了相应的<code>ExampleBean</code> class：</p>
<pre><code>public class ExampleBean &#123;

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) &#123;
        this.beanOne = beanOne;
    &#125;

    public void setBeanTwo(YetAnotherBean beanTwo) &#123;
        this.beanTwo = beanTwo;
    &#125;

    public void setIntegerProperty(int i) &#123;
        this.i = i;
    &#125;
&#125;
</code></pre>
<p>在前面的 example 中，setter 被声明为与 XML 文件中指定的 properties 进行 match。以下示例使用 constructor-based DI：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;!-- constructor injection using the nested ref element --&gt;
    &lt;constructor-arg&gt;
        &lt;ref bean=&quot;anotherExampleBean&quot;/&gt;
    &lt;/constructor-arg&gt;

    &lt;!-- constructor injection using the neater ref attribute --&gt;
    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;

    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre>
<p>以下 example 显示了相应的<code>ExampleBean</code> class：</p>
<pre><code>public class ExampleBean &#123;

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    &#125;
&#125;
</code></pre>
<p>bean 定义中指定的构造函数 arguments 用作<code>ExampleBean</code>的构造函数的 arguments。</p>
<p>现在考虑这个 example 的变体，其中，不是使用构造函数，而是告诉 Spring 调用<code>static</code>工厂方法来 return object 的实例：</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; factory-method=&quot;createInstance&quot;&gt;
    &lt;constructor-arg ref=&quot;anotherExampleBean&quot;/&gt;
    &lt;constructor-arg ref=&quot;yetAnotherBean&quot;/&gt;
    &lt;constructor-arg value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;anotherExampleBean&quot; class=&quot;examples.AnotherBean&quot;/&gt;
&lt;bean id=&quot;yetAnotherBean&quot; class=&quot;examples.YetAnotherBean&quot;/&gt;
</code></pre>
<p>以下 example 显示了相应的<code>ExampleBean</code> class：</p>
<pre><code>public class ExampleBean &#123;

    // a private constructor
    private ExampleBean(...) &#123;
        ...
    &#125;

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    &#125;
&#125;
</code></pre>
<p>工厂方法的 Arguments 由<code>&lt;constructor-arg/&gt;</code>元素提供，与实际使用构造函数的方式完全相同。工厂方法返回的 class 的类型不必与包含<code>static</code>工厂方法的 class 的类型相同(尽管，在此 example 中，它是)。实例(non-static)工厂方法可以以基本相同的方式使用(除了使用<code>factory-bean</code>属性而不是<code>class</code>属性)，因此我们不在此讨论这些细节。</p>
<h4 id="1-4-2-详细信息中的依赖关系和-Configuration"><a href="#1-4-2-详细信息中的依赖关系和-Configuration" class="headerlink" title="1.4.2. 详细信息中的依赖关系和 Configuration"></a>1.4.2. 详细信息中的依赖关系和 Configuration</h4><p>如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators">上一节</a>中所述，您可以将 bean properties 和 constructor arguments 定义为对其他托管 beans(协作者)的 references 或作为内联定义的值。为此，Spring 的 XML-based configuration 元数据在其<code>&lt;property/&gt;</code>和<code>&lt;constructor-arg/&gt;</code>元素中支持 sub-element 类型。</p>
<h5 id="直线值-Primitives，Strings-等"><a href="#直线值-Primitives，Strings-等" class="headerlink" title="直线值(Primitives，Strings 等)"></a>直线值(Primitives，Strings 等)</h5><p><code>&lt;property/&gt;</code>元素的<code>value</code>属性将 property 或构造函数参数指定为 human-readable string 表示。 Spring 的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#core-convert-ConversionService-API">转换服务</a>用于将这些值从<code>String</code>转换为 property 或参数的实际类型。以下 example 显示了设置的各种值：</p>
<pre><code>&lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;!-- results in a setDriverClassName(String) call --&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydb&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;masterkaoli&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>以下 example 使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-p-namespace">p-namespace</a>进行更简洁的 XML configuration：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;
        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;
        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;
        p:username=&quot;root&quot;
        p:password=&quot;masterkaoli&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>前面的 XML 更简洁。但是，在运行时发现拼写错误而不是设计 time，除非您在创建 bean 定义时使用支持自动 property 完成的 IDE(例如<a target="_blank" rel="noopener" href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a>或<a target="_blank" rel="noopener" href="https://spring.io/tools/sts">Spring 工具套件</a>)。强烈建议使用此类 IDE 帮助。</p>
<p>您还可以配置<code>java.util.Properties</code>实例，如下所示：</p>
<pre><code>&lt;bean id=&quot;mappings&quot;
    class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;

    &lt;!-- typed as a java.util.Properties --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;value&gt;
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>Spring 容器通过使用 JavaBeans <code>PropertyEditor</code>机制将<code>&lt;value/&gt;</code>元素内的文本转换为<code>java.util.Properties</code>实例。这是一个很好的快捷方式，是 Spring 团队支持在<code>value</code>属性样式上使用嵌套<code>&lt;value/&gt;</code>元素的少数几个地方之一。</p>
<h6 id="idref-元素"><a href="#idref-元素" class="headerlink" title="idref 元素"></a>idref 元素</h6><p><code>idref</code>元素只是一种 error-proof 方式，用于将容器中另一个 bean 的<code>id</code>(string value - 而不是 reference)传递给<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>元素。以下 example 显示了如何使用它：</p>
<pre><code>&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot;/&gt;

&lt;bean id=&quot;theClientBean&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;targetName&quot;&gt;
        &lt;idref bean=&quot;theTargetBean&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的 bean 定义代码段与以下代码段完全等效(在运行时)：</p>
<pre><code>&lt;bean id=&quot;theTargetBean&quot; class=&quot;...&quot; /&gt;

&lt;bean id=&quot;client&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>第一种形式优于第二种形式，因为使用<code>idref</code>标记允许容器在部署 time 时验证引用的名为 bean 的实际存在。在第二个变体中，不会对传递给<code>client</code> bean 的<code>targetName</code> property 的 value 执行验证。当<code>client</code> bean 实际被实例化时，才会发现错别字(最有可能致命的结果)。如果<code>client</code> bean 是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">原型</a> bean，则只能在部署容器后 long 发现此错误和结果 exception。</p>
<blockquote>
<p>4.0 beans XSD 不再支持<code>idref</code>元素上的<code>local</code>属性，因为它不再提供常规<code>bean</code> reference 的 value。升级到 4.0 schema 时，将现有的<code>idref local</code> references 更改为<code>idref bean</code>。</p>
</blockquote>
<p><code>&lt;idref/&gt;</code>元素带来 value 的 common 位置(至少在 Spring 2.0 之前的版本中)位于<code>ProxyFactoryBean</code> bean 定义的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-pfb-1">AOP 拦截器</a>的 configuration 中。指定拦截器名称时使用<code>&lt;idref/&gt;</code>元素可防止拼写错误的拦截器 ID。</p>
<h5 id="References-to-Other-Beans-Collaborators"><a href="#References-to-Other-Beans-Collaborators" class="headerlink" title="References to Other Beans(Collaborators)"></a>References to Other Beans(Collaborators)</h5><p><code>ref</code>元素是<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>定义元素中的最后一个元素。在这里，您将 bean 的指定 property 的 value 设置为由容器管理的另一个 bean(协作者)的 reference。引用的 bean 是要设置 property 的 bean 的依赖项，并且在设置 property 之前根据需要初始化它。 (如果协作者是 singleton bean，它可能已经被 container.)初始化所有 references 最终都是 reference 给另一个 object。作用域和验证取决于你是否通过<code>bean</code>，<code>local,</code>或<code>parent</code>指定另一个 object 的 ID 或 name 属性。</p>
<p>通过<code>&lt;ref/&gt;</code>标记的<code>bean</code>属性指定目标 bean 是最常用的形式，并允许在同一容器或 parent 容器中创建 reference 给任何 bean，无论它是否在同一 XML 文件中。 <code>bean</code>属性的 value 可以与 target bean 的<code>id</code>属性相同，也可以与 target bean 的<code>name</code>属性中的一个值相同。以下 example 显示了如何使用<code>ref</code>元素：</p>
<pre><code>&lt;ref bean=&quot;someBean&quot;/&gt;
</code></pre>
<p>通过<code>parent</code>属性指定目标 bean 会创建一个 reference 给位于当前容器的 parent 容器中的 bean。 <code>parent</code>属性的 value 可以与 target bean 的<code>id</code>属性相同，也可以与 target bean 的<code>name</code>属性中的一个值相同。目标 bean 必须位于当前容器的 parent 容器中。您应该使用此 bean reference 变体，主要是当您有容器层次结构并且希望将现有 bean 包装在 parent 容器中时，该容器具有与 parent bean 具有相同 name 的代理。以下一对列表显示了如何使用<code>parent</code>属性：</p>
<pre><code>&lt;!-- in the parent context --&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.something.SimpleAccountService&quot;&gt;
    &lt;!-- insert dependencies as required as here --&gt;
&lt;/bean&gt;
</code></pre>
<pre><code>&lt;!-- in the child (descendant) context --&gt;
&lt;bean id=&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;
    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;ref parent=&quot;accountService&quot;/&gt; &lt;!-- notice how we refer to the parent bean --&gt;
    &lt;/property&gt;
    &lt;!-- insert other configuration and dependencies as required here --&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>4.0 beans XSD 不再支持<code>ref</code>元素上的<code>local</code>属性，因为它不再提供常规<code>bean</code> reference 的 value。升级到 4.0 schema 时，将现有的<code>ref local</code> references 更改为<code>ref bean</code>。</p>
</blockquote>
<h5 id="内部-Beans"><a href="#内部-Beans" class="headerlink" title="内部 Beans"></a>内部 Beans</h5><p><code>&lt;property/&gt;</code>或<code>&lt;constructor-arg/&gt;</code>元素中的<code>&lt;bean/&gt;</code>元素定义内部 bean，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;outer&quot; class=&quot;...&quot;&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name=&quot;name&quot; value=&quot;Fiona Apple&quot;/&gt;
            &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>内部 bean 定义不需要定义的 ID 或 name。如果指定，则容器不使用这样的 value 作为标识符。容器也会在创建时忽略<code>scope</code> flag，因为内部 beans 始终是匿名的，并且始终使用外部 bean 创建。不可能独立访问内部 beans 或者将它们注入到协作 beans 而不是封闭的 bean 中。</p>
<p>作为一个极端情况，可以从自定义范围接收销毁回调 - 对于 example，包含在 singleton bean 中的 request-scoped inner bean。内部 bean 实例的创建与其包含 bean 相关联，但是销毁回调允许它参与请求范围的生命周期。这不是一个常见的场景。内部 beans 通常只是共享其包含 bean 的范围。</p>
<h5 id="收藏"><a href="#收藏" class="headerlink" title="收藏"></a>收藏</h5><p><code>&lt;list/&gt;</code>，<code>&lt;set/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素分别设置 Java <code>Collection</code>类型<code>List</code>，<code>Set</code>，<code>Map</code>和<code>Properties</code>的 properties 和 arguments。以下 example 显示了如何使用它们：</p>
<pre><code>&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;[emailprotected]&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;[emailprotected]&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;[emailprotected]&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>map key 或 value 或 set value 的 value 也可以是以下任何元素：</p>
<pre><code>bean | ref | idref | list | set | map | props | value | null
</code></pre>
<h6 id="收集合并"><a href="#收集合并" class="headerlink" title="收集合并"></a>收集合并</h6><p>Spring 容器还支持合并集合。 application 开发人员可以定义 parent <code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素，并使 child <code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code>或<code>&lt;props/&gt;</code>元素继承并覆盖 parent 集合中的值。也就是说，child 集合的值是合并 parent 和 child 集合的元素的结果，其中 child 的集合元素覆盖 parent 集合中指定的值。</p>
<p>关于合并的这一部分讨论了 parent-child bean 机制。 不熟悉 parent 和 child bean 定义的读者可能希望在继续之前阅读<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-child-bean-definitions">相关部分</a>。</p>
<p>以下 example 演示了集合合并：</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;example.ComplexObject&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;administrator&quot;&gt;[emailprotected]&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;[emailprotected]&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;!-- the merge is specified on the child collection definition --&gt;
            &lt;props merge=&quot;true&quot;&gt;
                &lt;prop key=&quot;sales&quot;&gt;[emailprotected]&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;[emailprotected]&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;
</code></pre>
<p>注意在<code>child</code> bean 定义的<code>adminEmails</code> property 的<code>&lt;props/&gt;</code>元素上使用<code>merge=true</code>属性。当<code>child</code> bean 由容器解析并实例化时，生成的实例有一个<code>adminEmails</code> <code>Properties</code>集合，其中包含将 child 的<code>adminEmails</code>集合与 parent 的<code>adminEmails</code>集合合并的结果。以下清单显示了结果：</p>
<pre><code>[emailprotected]
[emailprotected]
[emailprotected]
</code></pre>
<p>child <code>Properties</code>集合的 value 集合从 parent <code>&lt;props/&gt;</code>继承所有 property 元素，child _ value 的 child 的 value 覆盖 parent 集合中的 value。</p>
<p>此合并行为同样适用于<code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;set/&gt;</code>集合类型。在<code>&lt;list/&gt;</code>元素的特定情况下，保持与<code>List</code>集合类型相关联的语义(即，<code>ordered</code>值集合的概念)。 parent 的值在所有 child 列表的值之前。对于<code>Map</code>，<code>Set</code>和<code>Properties</code>集合类型，不存在 ordering。因此，没有 ordering 语义对集合类型有效，这些集合类型是容器在内部使用的关联<code>Map</code>，<code>Set</code>和<code>Properties</code> implementation 类型的基础。</p>
<h6 id="收集合并的限制"><a href="#收集合并的限制" class="headerlink" title="收集合并的限制"></a>收集合并的限制</h6><p>您无法合并不同的集合类型(例如<code>Map</code>和<code>List</code>)。如果您尝试这样做，则会抛出适当的<code>Exception</code>。必须在较低的，继承的 child 定义上指定<code>merge</code>属性。在 parent 集合定义上指定<code>merge</code>属性是多余的，并且不会导致所需的合并。</p>
<h6 id="Strongly-typed-集合"><a href="#Strongly-typed-集合" class="headerlink" title="Strongly-typed 集合"></a>Strongly-typed 集合</h6><p>通过在 Java 5 中引入泛型类型，您可以使用强类型集合。也就是说，可以声明<code>Collection</code>类型，使其只能包含(对于 example)<code>String</code>元素。如果使用 Spring dependency-inject strongly-typed <code>Collection</code>进入 bean，则可以利用 Spring 的 type-conversion 支持，以便在添加到<code>Collection</code>之前将 strongly-typed <code>Collection</code>实例的元素转换为适当的类型。以下 Java class 和 bean 定义显示了如何执行此操作：</p>
<pre><code>public class SomeClass &#123;

    private Map&lt;String, Float&gt; accounts;

    public void setAccounts(Map&lt;String, Float&gt; accounts) &#123;
        this.accounts = accounts;
    &#125;
&#125;
</code></pre>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;something&quot; class=&quot;x.y.SomeClass&quot;&gt;
        &lt;property name=&quot;accounts&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;one&quot; value=&quot;9.99&quot;/&gt;
                &lt;entry key=&quot;two&quot; value=&quot;2.75&quot;/&gt;
                &lt;entry key=&quot;six&quot; value=&quot;3.99&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>当<code>something</code> bean 的<code>accounts</code> property 准备好进行注入时，可以通过反射获得有关 strongly-typed <code>Map&lt;String, Float&gt;</code>的元素类型的泛型信息。因此，Spring 的类型转换基础结构将各种 value 元素识别为<code>Float</code>类型，并将 string 值(<code>9.99, 2.75</code>和<code>3.99</code>)转换为实际的<code>Float</code>类型。</p>
<h5 id="Null-和-Empty-String-值"><a href="#Null-和-Empty-String-值" class="headerlink" title="Null 和 Empty String 值"></a>Null 和 Empty String 值</h5><p>Spring 将 properties 等的空 arguments 视为空<code>Strings</code>。以下 XML-based configuration 元数据片段_set <code>email</code> property 为空<code>String</code> value(“”)。</p>
<pre><code>&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的 example 等效于以下 Java code：</p>
<pre><code>exampleBean.setEmail(&quot;&quot;);
</code></pre>
<p><code>&lt;null/&gt;</code>元素处理<code>null</code>值。以下清单显示了一个 example：</p>
<pre><code>&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot;&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的 configuration 相当于以下 Java code：</p>
<pre><code>exampleBean.setEmail(null);
</code></pre>
<h5 id="带-p-namespace-的-XML-快捷方式"><a href="#带-p-namespace-的-XML-快捷方式" class="headerlink" title="带 p-namespace 的 XML 快捷方式"></a>带 p-namespace 的 XML 快捷方式</h5><p>p-namespace 允许您使用<code>bean</code>元素的属性(而不是嵌套的<code>&lt;property/&gt;</code>元素)来描述 property 值协作 beans，或两者。</p>
<p>Spring 支持可扩展的 configuration 格式<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas">使用命名空间</a>，它们基于 XML Schema 定义。本章中讨论的<code>beans</code> configuration 格式在 XML Schema 文档中定义。但是，p-namespace 未在 XSD 文件中定义，仅存在于 Spring 的核心中。</p>
<p>以下 example 显示了两个 XML 片段(第一个使用标准 XML 格式，第二个使用 p-namespace)解析为相同的结果：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;
        &lt;property name=&quot;email&quot; value=&quot;[emailprotected]&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;
        p:email=&quot;[emailprotected]&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>example 在 bean中显示了一个名为<code>email</code>的属性，该属性在 bean 定义中。这告诉 Spring 包含 property 声明。如前所述，p-namespace 没有 schema 定义，因此您可以将属性的 name 设置为 property name。</p>
<p>下一个 example 包含两个 bean 定义，它们都有一个 reference 给另一个 bean：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;
        &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;john-modern&quot;
        class=&quot;com.example.Person&quot;
        p:name=&quot;John Doe&quot;
        p:spouse-ref=&quot;jane&quot;/&gt;

    &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Jane Doe&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>此 example 不仅包含使用 p-namespace 的 property value，还使用特殊格式声明 property references。第一个 bean 定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>从 bean <code>john</code>到 bean <code>jane</code>创建 reference，而第二个 bean 定义使用<code>p:spouse-ref=&quot;jane&quot;</code>作为属性来完成同样的事情。在这种情况下，<code>spouse</code>是 property name，而<code>-ref</code>部分表示这不是一个直的 value 而是 reference 给另一个 bean。</p>
<blockquote>
<p>p-namespace 不如标准 XML 格式灵活。例如，声明 property references 的格式与以<code>Ref</code>结尾的 properties 冲突，而标准 XML 格式则不然。我们建议您仔细选择您的方法并将其传达给您的团队成员，以避免产生在同一时间使用所有三种方法的 XML 文档。</p>
</blockquote>
<h5 id="带-c-namespace-的-XML-快捷方式"><a href="#带-c-namespace-的-XML-快捷方式" class="headerlink" title="带 c-namespace 的 XML 快捷方式"></a>带 c-namespace 的 XML 快捷方式</h5><p>与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-p-namespace">p-namespace 的 XML 快捷方式</a>类似，Spring 3.1 中引入的 c-namespace 允许内联属性来配置构造函数 arguments 而不是嵌套的<code>constructor-arg</code>元素。</p>
<p>以下 example 使用<code>c:</code>名称空间来执行与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-constructor-injection">Constructor-based 依赖注入</a>相同的操作：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingTwo&quot;/&gt;
    &lt;bean id=&quot;thingTwo&quot; class=&quot;x.y.ThingThree&quot;/&gt;

    &lt;!-- traditional declaration --&gt;
    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot;&gt;
        &lt;constructor-arg ref=&quot;thingTwo&quot;/&gt;
        &lt;constructor-arg ref=&quot;thingThree&quot;/&gt;
        &lt;constructor-arg value=&quot;[emailprotected]&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- c-namespace declaration --&gt;
    &lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;thingTwo&quot; c:thingThree-ref=&quot;thingThree&quot; c:email=&quot;[emailprotected]&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p><code>c:</code>名称空间使用与<code>p:</code>一样的约定(bean references 的尾随<code>-ref</code>)，用于按名称设置构造函数 arguments。同样，它需要声明，即使它没有在 XSD schema 中定义(它存在于 Spring 核心内)。</p>
<p>对于构造函数参数名称不可用的罕见情况(通常在没有调试信息的情况下编译字节码)，您可以使用回退到参数索引，如下所示：</p>
<pre><code>&lt;!-- c-namespace index declaration --&gt;
&lt;bean id=&quot;thingOne&quot; class=&quot;x.y.ThingOne&quot; c:_0-ref=&quot;thingTwo&quot; c:_1-ref=&quot;thingThree&quot;/&gt;
</code></pre>
<blockquote>
<p>由于 XML 语法，索引表示法需要存在前导<code>_</code>，因为 XML 属性名称不能以数字开头(即使某些 IDE 允许它)。</p>
</blockquote>
<p>实际上，构造函数分辨率<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-ctor-arguments-resolution">机制</a>在匹配 arguments 方面非常有效，所以除非你真的需要，否则我们建议使用 name 表示法 through-out your configuration。</p>
<h5 id="化合物属性名称"><a href="#化合物属性名称" class="headerlink" title="化合物属性名称"></a>化合物属性名称</h5><p>将 bean properties 设置为 long 时，可以使用复合或嵌套 property 名称，因为除最终 property name 之外的路径的所有组件都不是<code>null</code>。考虑以下 bean 定义：</p>
<pre><code>&lt;bean id=&quot;something&quot; class=&quot;things.ThingOne&quot;&gt;
    &lt;property name=&quot;fred.bob.sammy&quot; value=&quot;123&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><code>something</code> bean 有一个<code>fred</code> property，它有一个<code>bob</code> property，它有<code>sammy</code> property，最后<code>sammy</code> property 被设置为<code>123</code>的 value。为了使这个工作，的<code>fred</code> property 和<code>fred</code>的<code>bob</code> property 在构造 bean 之后不能是<code>null</code>。否则，抛出<code>NullPointerException</code>。</p>
<h4 id="1-4-3-使用-depends-on"><a href="#1-4-3-使用-depends-on" class="headerlink" title="1.4.3. 使用 depends-on"></a>1.4.3. 使用 depends-on</h4><p>如果 bean 是另一个 bean 的依赖项，那通常意味着一个 bean 被设置为另一个 bean 的 property。通常，您可以使用 XML-based XML-based configuration 元数据完成此操作。但是，有时 beans 之间的依赖关系不那么直接。 示例是需要触发 class 中的静态初始化程序时，例如数据库驱动程序注册。在使用此元素的 bean 初始化之前，<code>depends-on</code>属性可以显式强制初始化一个或多个 beans。以下 example 使用<code>depends-on</code>属性表示对单个 bean 的依赖：</p>
<pre><code>&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;
&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
</code></pre>
<p>要表示对多个 beans 的依赖，请提供 bean 名称列表作为<code>depends-on</code>属性的 value(逗号，空格和分号是有效的分隔符)：</p>
<pre><code>&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager,accountDao&quot;&gt;
    &lt;property name=&quot;manager&quot; ref=&quot;manager&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
&lt;bean id=&quot;accountDao&quot; class=&quot;x.y.jdbc.JdbcAccountDao&quot; /&gt;
</code></pre>
<blockquote>
<p><code>depends-on</code>属性既可以指定 initialization-time 依赖项，也可以指定<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-ref-element">singleton</a> beans，相应的 destruction-time 依赖项。在给定 bean 本身被销毁之前，首先销毁与给定 bean 定义<code>depends-on</code>关系的依赖 beans。因此，<code>depends-on</code>也可以控制 shutdown order。</p>
</blockquote>
<h4 id="1-4-4-Lazy-initialized-Beans"><a href="#1-4-4-Lazy-initialized-Beans" class="headerlink" title="1.4.4. Lazy-initialized Beans"></a>1.4.4. Lazy-initialized Beans</h4><p>默认情况下，<code>ApplicationContext</code> implementations 急切地创建和配置所有<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">singleton</a> beans 作为初始化 process 的一部分。通常，这个 pre-instantiation 是可取的，因为 configuration 或周围环境中的错误会立即被发现，而不是几小时甚至几天。如果不希望出现这种情况，可以通过将 bean 定义标记为 lazy-initialized 来阻止 singleton bean 的 pre-instantiation。 lazy-initialized bean 告诉 IoC 容器在第一次请求时创建 bean 实例，而不是在启动时创建 bean 实例。</p>
<p>在 XML 中，此行为由<code>&lt;bean/&gt;</code>元素上的<code>lazy-init</code>属性控制，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;lazy&quot; class=&quot;com.something.ExpensiveToCreateBean&quot; lazy-init=&quot;true&quot;/&gt;
&lt;bean name=&quot;not.lazy&quot; class=&quot;com.something.AnotherBean&quot;/&gt;
</code></pre>
<p>当前面的 configuration 被<code>ApplicationContext</code>消耗时，<code>ApplicationContext</code> bean 在<code>ApplicationContext</code>启动时并不急切 pre-instantiated，而<code>not.lazy</code> bean 则急切地 pre-instantiated。</p>
<p>但是，当 lazy-initialized bean 是 singleton bean 的依赖关系而不是 lazy-initialized 时，<code>ApplicationContext</code>会在启动时创建 lazy-initialized bean，因为它必须满足 singleton 的依赖关系。 lazy-initialized bean 被注入 singleton bean，而不是 lazy-initialized。</p>
<p>您还可以使用<code>&lt;beans/&gt;</code>元素上的<code>default-lazy-init</code>属性控制容器 level 上的 lazy-initialization，以下 example 显示：</p>
<pre><code>&lt;beans default-lazy-init=&quot;true&quot;&gt;
    &lt;!-- no beans will be pre-instantiated... --&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="1-4-5-自动化协作者"><a href="#1-4-5-自动化协作者" class="headerlink" title="1.4.5. 自动化协作者"></a>1.4.5. 自动化协作者</h4><p>Spring 容器可以自动配合协作 beans 之间的关系。您可以通过检查<code>ApplicationContext</code>的内容让 Spring 自动为您的 bean 解析协作者(其他 beans)。自动装配具有以下优点：</p>
<ul>
<li>自动装配可以显着减少指定 properties 或构造函数 arguments 的需要。 (其他机制，如 bean 模板<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">在本章的其他地方讨论过</a>在此 regard.)也很有价值</li>
<li>随着 objects 的发展，自动装配可以更新 configuration。例如，如果需要向 class 添加依赖项，则可以自动满足该依赖项，而无需修改 configuration。因此，自动装配在开发期间尤其有用，而不会在 code base 变得更稳定时否定切换到显式布线的选项。</li>
</ul>
<p>使用 XML-based configuration 元数据(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-child-bean-definitions">依赖注入</a>)时，可以使用<code>&lt;bean/&gt;</code>元素的<code>autowire</code>属性为 bean 定义指定 autowire 模式。自动装配功能有四种模式。您为每个 bean 指定自动装配，因此可以选择要自动装配的那些。以下 table 描述了四种自动装配模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>no</code></td>
<td>(默认)无自动装配。 Bean references 必须由<code>ref</code>元素定义。不建议对较大的部署更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。</td>
</tr>
<tr>
<td><code>byName</code></td>
<td>property name 自动装配。 Spring 查找 bean，其 name 与需要自动装配的 property 相同。例如，如果 bean 定义由 name 设置为 autowire 并且它包含<code>master</code> property(即，它具有<code>setMaster(..)</code>方法)，则 Spring 将查找名为<code>master</code>的 bean 定义并使用它来设置 property。</td>
</tr>
<tr>
<td><code>byType</code></td>
<td>如果容器中只存在 property 类型的一个 bean，则允许 property 自动装配。如果存在多个，则抛出致命的 exception，这表示您不能对该 bean 使用<code>byType</code>自动装配。如果没有匹配的 beans，则不会发生任何事情(property 未设置)。</td>
</tr>
<tr>
<td><code>constructor</code></td>
<td>类似于<code>byType</code>但适用于构造函数 arguments。如果容器中没有构造函数参数类型的一个 bean，则会引发致命错误。</td>
</tr>
</tbody></table>
<p>使用<code>byType</code>或<code>constructor</code>自动装配模式，您可以连接数组和类型集合。在这种情况下，提供容器中与预期类型匹配的所有 autowire 候选者以满足依赖性。如果预期的 key 类型为<code>String</code>，则可以自动装配 strongly-typed <code>Map</code>实例。自动装配的<code>Map</code>实例的值由 match 预期类型的所有 bean 实例组成，<code>Map</code>实例的键包含相应的 bean 名称。</p>
<h5 id="自动装配的限制和缺点"><a href="#自动装配的限制和缺点" class="headerlink" title="自动装配的限制和缺点"></a>自动装配的限制和缺点</h5><p>当在整个项目中一致地使用自动装配时，自动装配效果最佳。如果一般不使用自动装配，那么开发人员使用它来连接一个或两个 bean 定义可能会让人感到困惑。</p>
<p>考虑自动装配的局限和缺点：</p>
<ul>
<li><code>property</code>和<code>constructor-arg</code>设置中的显式依赖项始终覆盖自动装配。您无法自动装配简单的 properties，例如 primitives，<code>Strings</code>和<code>Classes</code>(以及此类简单 properties 的数组)。这个限制是 by-design。</li>
<li>自动装配不如显式布线精确。虽然如前面的 table 所述，Spring 谨慎避免在可能产生意外结果的模糊性的情况下进行猜测。您的 Spring-managed object 之间的关系不再明确记录。</li>
<li>可能无法为可能从 Spring 容器生成文档的工具提供接线信息。</li>
<li>容器中的多个 bean 定义可以 match 由 setter 方法或构造函数参数指定的类型以进行自动装配。对于数组，集合或<code>Map</code>实例，这不一定是个问题。但是，对于期望单个 value 的依赖关系，这种歧义不是任意解决的。如果没有唯一的 bean 定义，则抛出 exception。</li>
</ul>
<p>在后一种情况下，您有几种选择：</p>
<ul>
<li>放弃自动装配，支持显式布线。</li>
<li>通过将属性设置为<code>false</code>，避免为 bean 定义自动装配，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators">下一节</a>中所述。</li>
<li>通过将元素的<code>primary</code>属性设置为<code>true</code>，将单个 bean 定义指定为主要候选者。</li>
<li>使用 annotation-based configuration 实现更多 fine-grained 控件，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire-candidate">Annotation-based Container Configuration</a>中所述。</li>
</ul>
<h5 id="从自动装配中排除-Bean"><a href="#从自动装配中排除-Bean" class="headerlink" title="从自动装配中排除 Bean"></a>从自动装配中排除 Bean</h5><p>在 per-bean 的基础上，您可以从自动装配中排除 bean。在 Spring 的 XML 格式中，将<code>&lt;bean/&gt;</code>元素的<code>autowire-candidate</code>属性设置为<code>false</code>。容器使特定的 bean 定义对自动装配基础结构不可用(包括 annotation 样式配置，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config">@Autowired</a>)。</p>
<blockquote>
<p><code>autowire-candidate</code>属性旨在仅影响 type-based 自动装配。它不会影响 name 的显式 references，即使指定的 bean 未标记为 autowire 候选，它也会得到解析。因此，如果 name 匹配，name 的自动装配仍会注入 bean。</p>
</blockquote>
<p>您还可以根据 pattern-matching 对 bean 名称限制 autowire 候选者。 top-level <code>&lt;beans/&gt;</code>元素在其<code>default-autowire-candidates</code>属性中接受一个或多个模式。对于 example，要将 autowire 候选状态限制为 name ends with <code>Repository</code>的任何 bean，请提供的 value。要提供多个模式，请在 comma-separated 列表中定义它们。对于 bean 定义的<code>autowire-candidate</code>属性，<code>true</code>或<code>false</code>的显式 value 始终优先。对于此类 beans，pattern 匹配规则不适用。</p>
<p>这些技术对 beans 很有用，你永远不想通过自动装配注入其他 beans。这并不意味着排除的 bean 本身不能通过使用自动装配进行配置。相反，bean 本身不是自动装配其他 beans 的候选者。</p>
<h4 id="1-4-6-方法注入"><a href="#1-4-6-方法注入" class="headerlink" title="1.4.6. 方法注入"></a>1.4.6. 方法注入</h4><p>在大多数 application 场景中，容器中的大多数 beans 都是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-autowired-annotation">单身</a>。当 singleton bean 需要与另一个 singleton bean 协作或 non-singleton bean 需要与另一个 non-singleton bean 协作时，通常通过将一个 bean 定义为另一个的 property 来处理依赖关系。当 bean 生命周期不同时会出现问题。假设 singleton bean A 需要使用 non-singleton(原型)bean B，可能在 A 上的每个方法调用上。容器只创建 singleton bean A 一次，因此只有一次机会来设置 properties。容器不能为 bean A 提供 bean B 的新实例，每个 time B 都需要一个。</p>
<p>解决方案是放弃一些控制反转。您可以<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">make bean 了解容器</a>实现<code>ApplicationContextAware</code>接口，并通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">对容器进行 getBean(“B”)调用</a>请求(一个通常是新的)bean B 实例每 time bean A 需要它。以下 example 显示了这种方法：</p>
<pre><code>// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware &#123;

    private ApplicationContext applicationContext;

    public Object process(Map commandState) &#123;
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    &#125;

    protected Command createCommand() &#123;
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&quot;command&quot;, Command.class);
    &#125;

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException &#123;
        this.applicationContext = applicationContext;
    &#125;
&#125;
</code></pre>
<p>前面的内容是不可取的，因为 business code 知道并耦合到 Spring Framework。方法注入，Spring IoC 容器的一些先进的 feature，让您可以干净地处理这个用例。</p>
<p>您可以在<a target="_blank" rel="noopener" href="https://spring.io/blog/2004/08/06/method-injection/">这篇博客文章</a>中阅读有关方法注入动机的更多信息。</p>
<h5 id="查找方法注入"><a href="#查找方法注入" class="headerlink" title="查找方法注入"></a>查找方法注入</h5><p>Lookup 方法注入是容器覆盖 container-managed beans 方法的能力，_return 查找容器中另一个名为 bean 的查找结果。查找通常涉及原型 bean，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-client">上一节</a>中描述的场景。 Spring Framework 通过使用 CGLIB library 中的字节码生成来动态生成覆盖该方法的子类来实现此方法注入。</p>
<blockquote>
<ul>
<li>为了使这个动态子类工作，Spring bean 容器子类的 class 不能是<code>final</code>，要覆盖的方法也不能是<code>final</code>。</li>
</ul>
</blockquote>
<ul>
<li>Unit-testing 具有<code>abstract</code>方法的 class 要求您自己子类化 class 并提供<code>abstract</code>方法的 stub implementation。</li>
<li>component 扫描也需要具体的方法，这需要具体的 classes 来获取。</li>
<li>另一个 key 限制是查找方法不能与工厂方法一起使用，特别是在 configuration classes 中不能使用<code>@Bean</code>方法，因为在这种情况下，容器不负责 creating 实例，因此无法创建 runtime-generated 子类。飞。</li>
</ul>
<p>对于前一个 code 片段中的<code>CommandManager</code> class，Spring 容器会动态覆盖<code>createCommand()</code>方法的 implementation。 <code>CommandManager</code> class 没有任何 Spring 依赖项，因为重写的 example 显示：</p>
<pre><code>package fiona.apple;

// no more Spring imports!

public abstract class CommandManager &#123;

    public Object process(Object commandState) &#123;
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    &#125;

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
&#125;
</code></pre>
<p>在包含要注入的方法的 client class 中(在本例中为<code>CommandManager</code>)，要注入的方法需要以下形式的签名：</p>
<pre><code>&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);
</code></pre>
<p>如果方法是<code>abstract</code>，则 dynamically-generated 子类实现该方法。否则，dynamically-generated 子类将覆盖原始 class 中定义的具体方法。考虑以下 example：</p>
<pre><code>&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;
    &lt;!-- inject dependencies here as required --&gt;
&lt;/bean&gt;

&lt;!-- commandProcessor uses statefulCommandHelper --&gt;
&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;
    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>bean 标识为<code>commandManager</code> calls 它自己的<code>createCommand()</code>方法，只要它需要一个<code>myCommand</code> bean 的新实例。您必须小心部署<code>myCommand</code> bean 作为原型，如果这实际上是需要的话。如果它是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-method-injection">singleton</a>，则每 time 返回相同的<code>myCommand</code> bean 实例。</p>
<p>或者，在 annotation-based component model 中，您可以通过<code>@Lookup</code> annotation 声明查找方法，如下面的 example 所示：</p>
<pre><code>public abstract class CommandManager &#123;

    public Object process(Object commandState) &#123;
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    &#125;

    @Lookup(&quot;myCommand&quot;)
    protected abstract Command createCommand();
&#125;
</code></pre>
<p>或者，更具惯用性，您可以依赖于查找方法的声明的 return 类型来解析目标 bean：</p>
<pre><code>public abstract class CommandManager &#123;

    public Object process(Object commandState) &#123;
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    &#125;

    @Lookup
    protected abstract MyCommand createCommand();
&#125;
</code></pre>
<p>请注意，您通常应该在 order 中使用具体的 stub implementation 声明这样带注释的查找方法，以使它们与 Spring 的 component 扫描规则兼容，其中 abstract classes 默认被忽略。此限制不适用于显式注册或显式导入的 bean classes。</p>
<blockquote>
<p>访问不同范围的目标 beans 的另一种方法是<code>ObjectFactory</code>/<code>Provider</code>注入点。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">将 Beans 视为依赖关系</a>。</p>
</blockquote>
<p>您可能还会发现<code>ServiceLocatorFactoryBean</code>(在<code>org.springframework.beans.factory.config</code>包中)很有用。</p>
<h5 id="任意方法替换"><a href="#任意方法替换" class="headerlink" title="任意方法替换"></a>任意方法替换</h5><p>与查找方法注入相比，一种不太有用的方法注入形式是能够使用另一种方法 implementation 替换托管 bean 中的任意方法。您可以安全地跳过本节的 rest，直到您真正需要此功能。</p>
<p>使用 XML-based configuration 元数据，您可以使用<code>replaced-method</code>元素将已存在的方法 implementation 替换为另一个，用于已部署的 bean。考虑以下 class，它有一个我们想要覆盖的名为<code>computeValue</code>的方法：</p>
<pre><code>public class MyValueCalculator &#123;

    public String computeValue(String input) &#123;
        // some real code...
    &#125;

    // some other methods...
&#125;
</code></pre>
<p>实现<code>org.springframework.beans.factory.support.MethodReplacer</code>接口的 class 提供了新的方法定义，如下面的 example 所示：</p>
<pre><code>/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer &#123;

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123;
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    &#125;
&#125;
</code></pre>
<p>部署原始 class 并指定方法覆盖的 bean 定义类似于以下 example：</p>
<pre><code>&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;
</code></pre>
<p>您可以在<code>&lt;replaced-method/&gt;</code>元素中使用一个或多个<code>&lt;arg-type/&gt;</code>元素来指示被覆盖的方法的方法签名。仅当方法重载且 class 中存在多个变体时，arguments 的签名才是必需的。为方便起见，参数的类型 string 可以是完全限定类型 name 的子字符串。对于 example，以下所有 match <code>java.lang.String</code>：</p>
<pre><code>java.lang.String
String
Str
</code></pre>
<p>因为 arguments 的数量通常足以区分每个可能的选择，所以通过允许您只键入与参数类型匹配的最短 string，此快捷方式可以节省大量 typing。</p>
<h3 id="1-5-Bean-范围"><a href="#1-5-Bean-范围" class="headerlink" title="1.5. Bean 范围"></a>1.5. Bean 范围</h3><p>创建 bean 定义时，将创建一个配方，用于创建由 bean 定义定义的 class 的实际实例。 bean 定义是配方的 idea 很重要，因为它意味着，与 class 一样，您可以从单个配方创建许多 object 实例。</p>
<p>您不仅可以控制要插入到从特定 bean 定义创建的 object 的各种依赖项和 configuration 值，还可以控制从特定 bean 定义创建的 objects 的范围。这种方法功能强大且灵活，因为您可以选择通过 configuration 创建的 objects 的范围，而不必在 Java class level 的 object 范围内进行烘焙。 Beans 可以定义为部署在多个范围之一中。 Spring Framework 支持六个范围，其中四个范围仅在您使用 web-aware <code>ApplicationContext</code>时可用。你也可以创建<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">自定义范围。</a></p>
<p>以下 table 描述了支持的范围：</p>
<table>
<thead>
<tr>
<th>范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-custom">singleton</a></td>
<td>(默认)为每个 Spring IoC 容器的单个 object 实例定义单个 bean 定义。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">原型</a></td>
<td>为任意数量的 object 实例定义单个 bean 定义。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-prototype">请求</a></td>
<td>将单个 bean 定义范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 bean 实例，该实例是在单个 bean 定义的后面创建的。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-request">session</a></td>
<td>将单个 bean 定义范围限定为 HTTP <code>Session</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-session">应用</a></td>
<td>将单个 bean 定义范围限定为<code>ServletContext</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#beans-factory-scopes-application">WebSocket</a></td>
<td>将单个 bean 定义范围限定为<code>WebSocket</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
</tbody></table>
<blockquote>
<p>从 Spring 3.0 开始，线程范围可用，但默认情况下未注册。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/support/SimpleThreadScope.html">SimpleThreadScope</a>的文档。有关如何注册此范围或任何其他自定义范围的说明，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#websocket-stomp-websocket-scope">使用自定义范围</a>。</p>
</blockquote>
<h4 id="1-5-1-Singleton-范围"><a href="#1-5-1-Singleton-范围" class="headerlink" title="1.5.1. Singleton 范围"></a>1.5.1. Singleton 范围</h4><p>只管理 singleton bean 的一个共享实例，并且 beans 的所有请求都带有一个或多个 match bean 定义的 ID 导致 Spring 容器返回的一个特定 bean 实例。</p>
<p>换句话说，当您定义 bean 定义并将其范围限定为 singleton 时，Spring IoC 容器只创建该 bean 定义定义的 object 的一个实例。此单个实例存储在此类 singleton beans 的缓存中，并且所有后续请求和 references 都指向 bean return 缓存的 object。下图显示了 singleton 范围的工作原理：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/singleton.jpg" alt="singleton"></p>
<p>Spring 的 singleton bean 概念与 singleton pattern 的概念不同，如四人帮(GoF)模式书中所定义的那样。 GoF singleton hard-codes object 的范围，使得每个 ClassLoader 创建一个且只有一个特定 class 的实例。 Spring singleton 的范围最好描述为 per-container 和 per-bean。这意味着，如果在单个 Spring 容器中为特定 class 定义一个 bean，则 Spring 容器将创建该_ bean 定义所定义的 class 的一个且仅一个实例。 singleton 范围是 Spring 中的默认范围。要在中将 bean 定义为 singleton，您可以定义 bean，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot;/&gt;

&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;
&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;
</code></pre>
<h4 id="1-5-2-原型范围"><a href="#1-5-2-原型范围" class="headerlink" title="1.5.2. 原型范围"></a>1.5.2. 原型范围</h4><p>bean 部署的 non-singleton 原型范围导致每次都会创建一个新的 bean 实例，并对该特定 bean 发出请求。也就是说，bean 被注入到另一个 bean 中，或者通过容器上的<code>getBean()</code>方法调用来请求它。通常，您应该为所有有状态 beans 使用原型范围，为 stateless beans 使用 singleton 范围。</p>
<p>下图说明了 Spring 原型范围：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/prototype.jpg" alt="原型"></p>
<p>(数据访问 object(DAO)通常不配置为原型，因为典型的 DAO 不包含任何会话 state。我们更容易重用 singleton diagram.)的核心</p>
<p>以下 example 将 bean 定义为 XML 中的原型：</p>
<pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<p>与其他范围相比，Spring 不管理原型 bean 的完整生命周期。容器实例化，配置和组装原型 object 并将其交给 client，没有该原型实例的进一步 record。因此，尽管无论范围如何都在所有 object 上调用初始化生命周期回调方法，但在原型的情况下，不会调用已配置的销毁生命周期回调。 client code 必须清理 prototype-scoped object 并释放原型 beans 所拥有的昂贵资源。要让 Spring 容器释放 prototype-scoped beans 所拥有的资源，请尝试使用自定义<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-custom-using">bean post-processor</a>，它包含需要清理的 beans 的 reference。</p>
<p>在某些方面，Spring 容器关于 prototype-scoped bean 的角色是 Java <code>new</code> operator 的替代品。超过该点的所有生命周期管理必须由 client 处理。 (有关 Spring 容器中 bean 生命周期的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension-bpp">生命周期回调</a> .)</p>
<h4 id="1-5-3-Singleton-Beans-with-Prototype-bean-Dependencies"><a href="#1-5-3-Singleton-Beans-with-Prototype-bean-Dependencies" class="headerlink" title="1.5.3. Singleton Beans with Prototype-bean Dependencies"></a>1.5.3. Singleton Beans with Prototype-bean Dependencies</h4><p>当您对原型 beans 使用带有依赖关系的 singleton-scoped beans 时，请注意在实例化 time 时解析依赖关系。因此，如果原型实例是提供给 singleton-scoped bean 的唯一实例。</p>
<p>但是，假设您希望 singleton-scoped bean 在运行时重复获取 prototype-scoped bean 的新实例。你不能@ 如果您需要在运行时多次使用原型 bean 的新实例，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle">方法注入</a></p>
<h4 id="1-5-4-Request，Session，Application-和-WebSocket-Scopes"><a href="#1-5-4-Request，Session，Application-和-WebSocket-Scopes" class="headerlink" title="1.5.4. Request，Session，Application 和 WebSocket Scopes"></a>1.5.4. Request，Session，Application 和 WebSocket Scopes</h4><p>仅当您使用 web-aware Spring <code>ApplicationContext</code> implementation(例如<code>XmlWebApplicationContext</code>)时，<code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>范围才可用。如果将这些范围与常规 Spring IoC 容器(例如<code>ClassPathXmlApplicationContext</code>)一起使用，则会抛出抱怨未知 bean 范围的<code>IllegalStateException</code>。</p>
<h5 id="初始-Web-Configuration"><a href="#初始-Web-Configuration" class="headerlink" title="初始 Web Configuration"></a>初始 Web Configuration</h5><p>要在<code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>级别(web-scoped beans)支持 beans 的范围设定，在定义 beans 之前需要一些小的初始 configuration。 (标准范围不需要此初始设置：<code>singleton</code>和<code>prototype</code> .)</p>
<p>如何完成此初始设置取决于您的特定 Servlet 环境。</p>
<p>如果在 Spring Web MVC 中访问范围 beans，实际上是在 Spring <code>DispatcherServlet</code>处理的请求中，则无需进行特殊设置。 <code>DispatcherServlet</code>已经暴露了所有相关的 state。</p>
<p>如果使用 Servlet 2.5 web 容器，并且在 Spring 的<code>DispatcherServlet</code>之外处理请求(对于 example，当使用 JSF 或 Struts 时)，则需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>。对于 Servlet 3.0，可以使用<code>WebApplicationInitializer</code>接口以编程方式完成此操作。或者，或者对于旧容器，将以下声明添加到 web application 的<code>web.xml</code>文件中：</p>
<pre><code>&lt;web-app&gt;
    ...
    &lt;listener&gt;
        &lt;listener-class&gt;
            org.springframework.web.context.request.RequestContextListener
        &lt;/listener-class&gt;
    &lt;/listener&gt;
    ...
&lt;/web-app&gt;
</code></pre>
<p>或者，如果 listener 设置存在问题，请考虑使用 Spring 的<code>RequestContextFilter</code>。过滤器映射取决于周围的 web application configuration，因此您必须根据需要进行更改。以下清单显示了 web application 的过滤器部分：</p>
<pre><code>&lt;web-app&gt;
    ...
    &lt;filter&gt;
        &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    ...
&lt;/web-app&gt;
</code></pre>
<p><code>DispatcherServlet</code>，<code>RequestContextListener</code>和<code>RequestContextFilter</code>都完全相同，即将 HTTP 请求 object 绑定到为该请求提供服务的<code>Thread</code>。这使 beans 在请求和 session-scoped 可进一步在调用链中可用。</p>
<h5 id="请求范围"><a href="#请求范围" class="headerlink" title="请求范围"></a>请求范围</h5><p>考虑以下针对 bean 定义的 XML configuration：</p>
<pre><code>&lt;bean id=&quot;loginAction&quot; class=&quot;com.something.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>Spring 容器通过对每个 HTTP 请求使用<code>loginAction</code> bean 定义来创建<code>LoginAction</code> bean 的新实例。也就是说，<code>loginAction</code> bean 的作用域是 HTTP 请求 level。您可以根据需要更改创建的实例的内部 state，因为从同一<code>loginAction</code> bean 定义创建的其他实例在 state 中看不到这些更改。它们特别针对个人要求。当请求完成处理时，将放弃作用于请求的 bean。</p>
<p>使用 annotation-driven 组件或 Java configuration 时，<code>@RequestScope</code> annotation 可用于将 component 分配给<code>request</code>范围。以下 example 显示了如何执行此操作：</p>
<pre><code>@RequestScope
@Component
public class LoginAction &#123;
    // ...
&#125;
</code></pre>
<h5 id="Session-范围"><a href="#Session-范围" class="headerlink" title="Session 范围"></a>Session 范围</h5><p>考虑以下针对 bean 定义的 XML configuration：</p>
<pre><code>&lt;bean id=&quot;userPreferences&quot; class=&quot;com.something.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>Spring 容器通过在单个 HTTP <code>Session</code>的生命周期中使用<code>userPreferences</code> bean 定义来创建<code>UserPreferences</code> bean 的新实例。换句话说，<code>userPreferences</code> bean 有效地限定在 HTTP <code>Session</code> level。与 request-scoped beans 一样，您可以根据需要更改创建的实例的内部 state，因为知道同样使用从同一<code>userPreferences</code> bean 定义创建的实例的其他 HTTP <code>Session</code>实例在 state 中看不到这些更改，因为它们特定于单个 HTTP <code>Session</code>。当最终丢弃 HTTP <code>Session</code>时，也将丢弃作用于该特定 HTTP <code>Session</code>的 bean。</p>
<p>使用 annotation-driven 组件或 Java configuration 时，可以使用<code>@SessionScope</code> annotation 将 component 分配给<code>session</code>范围。</p>
<pre><code>@SessionScope
@Component
public class UserPreferences &#123;
    // ...
&#125;
</code></pre>
<h5 id="Application-Scope"><a href="#Application-Scope" class="headerlink" title="Application Scope"></a>Application Scope</h5><p>考虑以下针对 bean 定义的 XML configuration：</p>
<pre><code>&lt;bean id=&quot;appPreferences&quot; class=&quot;com.something.AppPreferences&quot; scope=&quot;application&quot;/&gt;
</code></pre>
<p>Spring 容器通过对整个 web application 使用<code>appPreferences</code> bean 定义一次来创建<code>AppPreferences</code> bean 的新实例。也就是说，<code>appPreferences</code> bean 的作用域为<code>ServletContext</code> level 并存储为常规<code>ServletContext</code>属性。这有点类似于 Spring singleton bean 但在两个重要方面有所不同：它是 singleton 每<code>ServletContext</code>，而不是 Spring’ApplicationContext’(在任何给定的 web application 中可能有几个)，它实际上是暴露的，因此作为<code>ServletContext</code>属性可见。</p>
<p>使用 annotation-driven 组件或 Java configuration 时，可以使用<code>@ApplicationScope</code> annotation 将 component 分配给<code>application</code>范围。以下 example 显示了如何执行此操作：</p>
<pre><code>@ApplicationScope
@Component
public class AppPreferences &#123;
    // ...
&#125;
</code></pre>
<h5 id="Scoped-Beans-as-Dependencies"><a href="#Scoped-Beans-as-Dependencies" class="headerlink" title="Scoped Beans as Dependencies"></a>Scoped Beans as Dependencies</h5><p>Spring IoC 容器不仅管理 objects(beans)的实例化，还管理协作者(或依赖项)的连接。如果要将 HTTP request-scoped bean 注入(对于 example)到 longer-lived 范围的另一个 bean，您可以选择 inject AOP 代理来代替作用域 bean。也就是说，您需要 inject 一个代理 object，它暴露与作用域 object 相同的公共接口，但也可以从相关范围(例如 HTTP 请求)中检索真实目标 object，并将方法 calls 委托给真实的 object。</p>
<blockquote>
<p>您也可以在作为<code>singleton</code>的 beans 之间使用<code>&lt;aop:scoped-proxy/&gt;</code>，然后 reference 将通过可序列化的中间代理，因此能够在反序列化时 re-obtain 目标 singleton bean。</p>
</blockquote>
<p>当针对范围<code>prototype</code>的 bean 声明<code>&lt;aop:scoped-proxy/&gt;</code>时，共享代理上的每个方法调用都会导致创建一个新的目标实例，然后将该呼叫转发到该目标实例。</p>
<p>此外，范围代理不是以 lifecycle-safe 方式从较短范围访问 beans 的唯一方法。您还可以将注入点(即构造函数或 setter 参数或自动装配字段)声明为<code>ObjectFactory&lt;MyTargetBean&gt;</code>，允许<code>getObject()</code>调用在每次需要时按需检索当前实例 - 无需保留实例或存储它分别。</p>
<p>作为扩展变体，您可以声明<code>ObjectProvider&lt;MyTargetBean&gt;</code>，它提供了几个额外的访问变体，包括<code>getIfAvailable</code>和<code>getIfUnique</code>。</p>
<p>这个的 JSR-330 变体称为<code>Provider</code>，并且每次检索尝试都会使用<code>Provider&lt;MyTargetBean&gt;</code>声明和相应的<code>get()</code>调用。有关 JSR-330 整体的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-method-injection">这里</a>。</p>
<p>以下 example 中的 configuration 只有一个 line，但了解“为什么”以及它背后的“如何”非常重要：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;
    &lt;bean id=&quot;userPreferences&quot; class=&quot;com.something.UserPreferences&quot; scope=&quot;session&quot;&gt;
        &lt;!-- instructs the container to proxy the surrounding bean --&gt;
        &lt;aop:scoped-proxy/&gt; (1)
    &lt;/bean&gt;

    &lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.something.SimpleUserService&quot;&gt;
        &lt;!-- a reference to the proxied userPreferences bean --&gt;
        &lt;property name=&quot;userPreferences&quot; ref=&quot;userPreferences&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>定义代理的 line。</td>
</tr>
</tbody></table>
<p>要创建这样的代理，请将 child <code>&lt;aop:scoped-proxy/&gt;</code>元素插入到作用域 bean 定义中(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-standard-annotations">选择要创建的代理类型</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection-proxies">XML Schema-based configuration</a>)。为什么在<code>request</code>，<code>session</code>和 custom-scope 级别定义 beans 的定义需要<code>&lt;aop:scoped-proxy/&gt;</code>元素？考虑以下 singleton bean 定义，并将其与您需要为上述范围定义的内容进行对比(请注意，以下<code>userPreferences</code> bean 定义不完整)：</p>
<pre><code>&lt;bean id=&quot;userPreferences&quot; class=&quot;com.something.UserPreferences&quot; scope=&quot;session&quot;/&gt;

&lt;bean id=&quot;userManager&quot; class=&quot;com.something.UserManager&quot;&gt;
    &lt;property name=&quot;userPreferences&quot; ref=&quot;userPreferences&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>在前面的 example 中，singleton bean(<code>userManager</code>)注入一个 reference 到 HTTP <code>Session</code> -scoped bean(<code>userPreferences</code>)。这里的重点是<code>userManager</code> bean 是 singleton：它每个容器只实例化一次，它的依赖项(在这种情况下只有一个，<code>userPreferences</code> bean)也只注入一次。这意味着<code>userManager</code> bean 仅在完全相同的<code>userPreferences</code> object(即最初注入它的那个)上运行。</p>
<p>这不是将 shorter-lived 作用域 bean 注入 longer-lived 作用域 bean 时所需的行为(对于 example，将-scoped 协作 bean 作为依赖项注入 singleton bean)。相反，您需要一个<code>userManager</code> object，并且，对于 HTTP <code>Session</code>的生命周期，您需要一个特定于 HTTP <code>Session</code>的<code>userPreferences</code> object。因此，容器创建一个 object，它公开与<code>UserPreferences</code> class 完全相同的公共接口(理想情况下是一个<code>UserPreferences</code>实例的 object)，它可以从作用域机制中获取真正的<code>UserPreferences</code> object(HTTP 请求，<code>Session</code>等) 。容器将此代理 object 注入<code>userManager</code> bean，它不知道此<code>UserPreferences</code> reference 是代理。在此 example 中，当<code>UserManager</code>实例在 dependency-injected <code>UserPreferences</code> object 上调用方法时，它实际上是在代理上调用方法。然后代理从(在这种情况下)HTTP <code>Session</code>中获取真实<code>UserPreferences</code> object，并将方法调用委托给检索到的真实<code>UserPreferences</code> object。</p>
<p>因此，在将<code>request-</code>和<code>session-scoped</code> beans 注入协作 objects 时，需要以下(正确和完整)configuration，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;userPreferences&quot; class=&quot;com.something.UserPreferences&quot; scope=&quot;session&quot;&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userManager&quot; class=&quot;com.something.UserManager&quot;&gt;
    &lt;property name=&quot;userPreferences&quot; ref=&quot;userPreferences&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h6 id="选择要创建的代理类型"><a href="#选择要创建的代理类型" class="headerlink" title="选择要创建的代理类型"></a>选择要创建的代理类型</h6><p>默认情况下，当 Spring 容器为使用<code>&lt;aop:scoped-proxy/&gt;</code>元素标记的 bean 创建代理时，会创建 CGLIB-based class 代理。</p>
<blockquote>
<p>CGLIB 代理只拦截公共方法 calls！不要在这样的代理上调用 non-public 方法。它们不会委托给实际作用域的目标 object。</p>
</blockquote>
<p>或者，您可以通过为<code>&lt;aop:scoped-proxy/&gt;</code>元素的<code>proxy-target-class</code>属性的 value 指定<code>false</code>来配置 Spring 容器以为此类作用域 beans 创建标准 JDK interface-based 代理。使用 JDK interface-based 代理意味着您不需要 application classpath 中的其他 libraries 来影响此类代理。但是，它还意味着作用域 bean 的 class 必须至少实现一个接口，并且注入了作用域 bean 的所有协作者必须通过其中一个接口引用 bean。以下 example 显示了基于接口的代理：</p>
<pre><code>&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;
&lt;bean id=&quot;userPreferences&quot; class=&quot;com.stuff.DefaultUserPreferences&quot; scope=&quot;session&quot;&gt;
    &lt;aop:scoped-proxy proxy-target-class=&quot;false&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;userManager&quot; class=&quot;com.stuff.UserManager&quot;&gt;
    &lt;property name=&quot;userPreferences&quot; ref=&quot;userPreferences&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>有关选择 class-based 或 interface-based 代理的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas">代理机制</a>。</p>
<h4 id="1-5-5-自定义范围"><a href="#1-5-5-自定义范围" class="headerlink" title="1.5.5. 自定义范围"></a>1.5.5. 自定义范围</h4><p>bean 作用域机制是可扩展的。您可以定义自己的范围，甚至可以重新定义现有范围，但后者被认为是不好的做法，您无法覆盖 built-in <code>singleton</code>和<code>prototype</code>范围。</p>
<h5 id="创建自定义范围"><a href="#创建自定义范围" class="headerlink" title="创建自定义范围"></a>创建自定义范围</h5><p>要将自定义作用域集成到 Spring 容器中，需要实现<code>org.springframework.beans.factory.config.Scope</code>接口，本节将对此进行介绍。有关如何实现自己的范围的 idea，请参阅 Spring Framework 本身和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html">范围</a> javadoc 提供的<code>Scope</code> implementations，它们解释了您需要更详细地实现的方法。</p>
<p><code>Scope</code>接口有四种方法可以从作用域中获取 objects，将它们从作用域中删除，然后将它们销毁。</p>
<p>session 范围 implementation，对于 example，返回 session-scoped bean(如果它不存在，则该方法在将__ssion 绑定到 session 以用于将来 reference 之后返回 bean 的新实例)。以下方法从基础范围返回 object：</p>
<pre><code>Object get(String name, ObjectFactory objectFactory)
</code></pre>
<p>session 范围 implementation，对于 example，从基础 session 中删除 session-scoped bean。应返回 object，但如果找不到具有指定 name 的 object，则可以 return null。以下方法从基础范围中删除 object：</p>
<pre><code>Object remove(String name)
</code></pre>
<p>以下方法记录范围在销毁时或范围中指定的 object 被销毁时应执行的回调：</p>
<pre><code>void registerDestructionCallback(String name, Runnable destructionCallback)
</code></pre>
<p>有关销毁回调的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html#aop-proxying">javadoc</a>或 Spring 范围 implementation。</p>
<p>以下方法获取基础范围的对话标识符：</p>
<pre><code>String getConversationId()
</code></pre>
<p>每个范围的标识符都不同。对于 session 范围的 implementation，此标识符可以是 session 标识符。</p>
<h5 id="使用自定义范围"><a href="#使用自定义范围" class="headerlink" title="使用自定义范围"></a>使用自定义范围</h5><p>在编写并测试一个或多个自定义<code>Scope</code> __mplement 之后，您需要让 Spring 容器知道您的新范围。以下方法是使用 Spring 容器注册新<code>Scope</code>的核心方法：</p>
<pre><code>void registerScope(String scopeName, Scope scope);
</code></pre>
<p>此方法在<code>ConfigurableBeanFactory</code>接口上声明，在 Spring 附带的大多数具体<code>ApplicationContext</code> implementations 上可通过<code>BeanFactory</code> property 获得。</p>
<p><code>registerScope(..)</code>方法的第一个参数是与范围关联的唯一 name。 Spring 容器本身中此类名称的示例是<code>singleton</code>和<code>prototype</code>。 <code>registerScope(..)</code>方法的第二个参数是您希望注册和使用的自定义<code>Scope</code> implementation 的实际实例。</p>
<p>假设您编写自定义<code>Scope</code> implementation，然后按照下一个 example 中的说明进行注册。</p>
<blockquote>
<p>下一个 example 使用<code>SimpleThreadScope</code>，它包含在 Spring 中，但默认情况下未注册。对于您自己的自定义<code>Scope</code> __mplement，说明将是相同的。</p>
</blockquote>
<pre><code>Scope threadScope = new SimpleThreadScope();
beanFactory.registerScope(&quot;thread&quot;, threadScope);
</code></pre>
<p>然后，您可以创建符合自定义<code>Scope</code>的作用域规则的 bean 定义，如下所示：</p>
<pre><code>&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;thread&quot;&gt;
</code></pre>
<p>使用自定义<code>Scope</code> implementation，您不仅限于范围的编程注册。您还可以使用<code>CustomScopeConfigurer</code> class 以声明方式执行<code>Scope</code>注册，如下面的 example 所示：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;bean class=&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;&gt;
        &lt;property name=&quot;scopes&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;thread&quot;&gt;
                    &lt;bean class=&quot;org.springframework.context.support.SimpleThreadScope&quot;/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;thing2&quot; class=&quot;x.y.Thing2&quot; scope=&quot;thread&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Rick&quot;/&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;thing1&quot; class=&quot;x.y.Thing1&quot;&gt;
        &lt;property name=&quot;thing2&quot; ref=&quot;thing2&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<blockquote>
<p>当<code>&lt;aop:scoped-proxy/&gt;</code>放在<code>FactoryBean</code> implementation 中时，工厂 bean 本身是作用域的，而不是从<code>getObject()</code>返回的 object。</p>
</blockquote>
<h3 id="1-6-自定义-Bean-的性质"><a href="#1-6-自定义-Bean-的性质" class="headerlink" title="1.6. 自定义 Bean 的性质"></a>1.6. 自定义 Bean 的性质</h3><p>Spring Framework 提供了许多可用于自定义 bean 特性的接口。本节将它们分组如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#registerDestructionCallback">生命周期回调</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle">ApplicationContextAware 和 BeanNameAware</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">其他感知接口</a></li>
</ul>
<h4 id="1-6-1-生命周期回调"><a href="#1-6-1-生命周期回调" class="headerlink" title="1.6.1. 生命周期回调"></a>1.6.1. 生命周期回调</h4><p>要与容器的 bean 生命周期的 management 进行交互，可以实现 Spring <code>InitializingBean</code>和<code>DisposableBean</code>接口。容器 calls <code>afterPropertiesSet()</code>用于前者，<code>destroy()</code>用于后者让 bean 在初始化和销毁 beans 时执行某些操作。</p>
<blockquote>
<p>JSR-250 <code>@PostConstruct</code>和<code>@PreDestroy</code> 注释通常被认为是在现代 Spring application 中接收生命周期回调的最佳实践。使用这些注释意味着 beans 没有耦合到 Spring-specific 接口。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aware-list">使用 @PostConstruct 和 @PreDestroy</a>。</p>
</blockquote>
<p>如果您不想使用 JSR-250 注释但仍想删除耦合，请考虑使用<code>init-method</code>和<code>destroy-method</code> object 定义元数据。</p>
<p>在内部，Spring Framework 使用<code>BeanPostProcessor</code> implementations 来处理它可以找到的任何回调接口并调用适当的方法。如果您需要自定义 features 或其他生命周期行为 Spring 默认不提供，您可以自己实现<code>BeanPostProcessor</code>。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-postconstruct-and-predestroy-annotations">集装箱扩建点</a>。</p>
<p>除了初始化和销毁回调之外，Spring-managed objects 还可以实现<code>Lifecycle</code>接口，以便那些 objects 可以参与启动和关闭 process，这是由容器自身的生命周期驱动的。</p>
<p>本节描述了生命周期回调接口。</p>
<h5 id="初始化回调"><a href="#初始化回调" class="headerlink" title="初始化回调"></a>初始化回调</h5><p>接口允许 bean 在容器在 bean 上设置所有必需的 properties 后执行初始化工作。 <code>InitializingBean</code>接口指定单个方法：</p>
<pre><code>void afterPropertiesSet() throws Exception;
</code></pre>
<p>我们建议您不要使用<code>InitializingBean</code>接口，因为它会不必要地将 code 耦合到 Spring。或者，我们建议使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension">@PostConstruct</a> annotation 或指定 POJO 初始化方法。对于 XML-based configuration 元数据，可以使用<code>init-method</code>属性指定具有 void no-argument 签名的方法的 name。使用 Java configuration，您可以使用<code>@Bean</code>的<code>initMethod</code>属性。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-postconstruct-and-predestroy-annotations">接收生命周期回调</a>。考虑以下 example：</p>
<pre><code>&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;
</code></pre>
<pre><code>public class ExampleBean &#123;

    public void init() &#123;
        // do some initialization work
    &#125;
&#125;
</code></pre>
<p>前面的 example 与以下 example(由两个列表组成)具有几乎完全相同的效果：</p>
<pre><code>&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;
</code></pre>
<pre><code>public class AnotherExampleBean implements InitializingBean &#123;

    public void afterPropertiesSet() &#123;
        // do some initialization work
    &#125;
&#125;
</code></pre>
<p>但是，前两个示例中的第一个不将 code 耦合到 Spring。</p>
<h5 id="销毁回调"><a href="#销毁回调" class="headerlink" title="销毁回调"></a>销毁回调</h5><p>实现<code>org.springframework.beans.factory.DisposableBean</code>接口允许 bean 在包含它的容器被销毁时获得回调。 <code>DisposableBean</code>接口指定单个方法：</p>
<pre><code>void destroy() throws Exception;
</code></pre>
<p>我们建议您不要使用<code>DisposableBean</code>回调接口，因为它会不必要地将 code 耦合到 Spring。或者，我们建议使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-lifecycle-callbacks">@PreDestroy</a> annotation 或指定 bean 定义支持的泛型方法。使用 XML-based configuration 元数据，您可以使用<code>&lt;bean/&gt;</code>上的<code>destroy-method</code>属性。使用 Java configuration，您可以使用<code>@Bean</code>的<code>destroyMethod</code>属性。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-postconstruct-and-predestroy-annotations">接收生命周期回调</a>。考虑以下定义：</p>
<pre><code>&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.ExampleBean&quot; destroy-method=&quot;cleanup&quot;/&gt;
</code></pre>
<pre><code>public class ExampleBean &#123;

    public void cleanup() &#123;
        // do some destruction work (like releasing pooled connections)
    &#125;
&#125;
</code></pre>
<p>前面的定义与以下定义几乎完全相同：</p>
<pre><code>&lt;bean id=&quot;exampleInitBean&quot; class=&quot;examples.AnotherExampleBean&quot;/&gt;
</code></pre>
<pre><code>public class AnotherExampleBean implements DisposableBean &#123;

    public void destroy() &#123;
        // do some destruction work (like releasing pooled connections)
    &#125;
&#125;
</code></pre>
<p>但是，前两个定义中的第一个不将 code 耦合到 Spring。</p>
<blockquote>
<p>您可以为<code>&lt;bean&gt;</code>元素的<code>destroy-method</code>属性分配一个特殊的<code>(inferred)</code> value，它指示 Spring 自动检测特定 bean class 上的公共<code>close</code>或<code>shutdown</code>方法。 (任何实现<code>java.lang.AutoCloseable</code>或<code>java.io.Closeable</code>的 class 因此 match.)你也可以在<code>&lt;beans&gt;</code>元素的<code>default-destroy-method</code>属性上设置这个特殊的<code>(inferred)</code> value，将这种行为应用于整个 beans 集合(参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-lifecycle-callbacks">默认初始化和销毁方法</a>)。注意这是默认行为 Java configuration。</p>
</blockquote>
<h5 id="默认初始化和销毁方法"><a href="#默认初始化和销毁方法" class="headerlink" title="默认初始化和销毁方法"></a>默认初始化和销毁方法</h5><p>当您编写初始化和销毁不使用 Spring-specific <code>InitializingBean</code>和<code>DisposableBean</code>回调接口的方法回调时，通常会编写名称为<code>init()</code>，<code>initialize()</code>，<code>dispose()</code>等的方法。理想情况下，此类生命周期回调方法的名称在项目中是标准化的，以便所有开发人员使用相同的方法名称并确保一致性。</p>
<p>您可以将 Spring 容器配置为“查找”命名初始化并在每个 bean 上销毁回调方法名称。这意味着，作为 application 开发人员，您可以编写 application classes 并使用名为<code>init()</code>的初始化回调，而无需为每个 bean 定义配置<code>init-method=&quot;init&quot;</code>属性。 Spring IoC 容器在创建 bean 时(并根据标准生命周期回调 contract <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-default-init-destroy-methods">如前所述</a>)调用该方法。此 feature 还强制执行初始化和销毁方法回调的一致命名约定。</p>
<p>假设您的初始化回调方法名为<code>init()</code>，并且您的 destroy 回调方法名为<code>destroy()</code>。您的 class 类似于以下 example 中的 class：</p>
<pre><code>public class DefaultBlogService implements BlogService &#123;

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) &#123;
        this.blogDao = blogDao;
    &#125;

    // this is (unsurprisingly) the initialization callback method
    public void init() &#123;
        if (this.blogDao == null) &#123;
            throw new IllegalStateException(&quot;The [blogDao] property must be set.&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>然后，您可以在 bean 中使用 class，类似于以下内容：</p>
<pre><code>&lt;beans default-init-method=&quot;init&quot;&gt;

    &lt;bean id=&quot;blogService&quot; class=&quot;com.something.DefaultBlogService&quot;&gt;
        &lt;property name=&quot;blogDao&quot; ref=&quot;blogDao&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>top-level <code>&lt;beans/&gt;</code>元素属性上存在<code>default-init-method</code>属性会导致 Spring IoC 容器在 bean class 上识别名为<code>init</code>的方法作为初始化方法回调。当创建和组装 bean 时，如果 bean class 具有这样的方法，则在适当的 time 调用它。</p>
<p>您可以使用 top-level <code>&lt;beans/&gt;</code>元素上的<code>default-destroy-method</code>属性类似地(在 XML 中)配置 destroy 方法回调。</p>
<p>如果现有的 bean classes 已经具有以约定方式命名的回调方法，则可以通过使用<code>&lt;bean/&gt;</code>本身的<code>init-method</code>和<code>destroy-method</code>属性指定(在 XML 中，即)方法 name 来覆盖默认值。</p>
<p>Spring 容器保证在为 bean 提供所有依赖项后立即调用已配置的初始化回调。因此，在原始 bean reference 上调用初始化回调，这意味着 AOP 拦截器等尚未应用于 bean。首先完全创建目标 bean，然后应用具有拦截器链的 AOP 代理(用于 example)。如果目标 bean 和代理是分开定义的，那么 code 甚至可以绕过代理与原始目标 bean 进行交互。因此，将拦截器应用于<code>init</code>方法是不一致的，因为这样做会将目标 bean 的生命周期耦合到其代理或拦截器，并在 code 直接与原始目标 bean 进行交互时留下奇怪的语义。</p>
<h5 id="结合生命周期机制"><a href="#结合生命周期机制" class="headerlink" title="结合生命周期机制"></a>结合生命周期机制</h5><p>从 Spring 2.5 开始，您有三个控制 bean 生命周期行为的选项：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle">InitializingBean</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">DisposableBean</a>回调接口</li>
<li>自定义<code>init()</code>和<code>destroy()</code>方法</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean">@PostConstruct 和 @PreDestroy 注释</a>。您可以组合这些机制来控制给定的 bean。</li>
</ul>
<blockquote>
<p>如果为 bean 配置了多个生命周期机制，并且每个机制配置了不同的方法 name，则每个配置的方法都在此注释后列出的 order 中执行。但是，如果配置了相同的方法 name - 对于 example，<code>init()</code>用于初始化方法 - 对于多个这些生命周期机制，该方法将执行一次，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-postconstruct-and-predestroy-annotations">前一节</a>中所述。</p>
</blockquote>
<p>为同一 bean 配置的多个生命周期机制具有不同的初始化方法，如下所示：</p>
<ul>
<li>用<code>@PostConstruct</code>注释的方法</li>
<li><code>afterPropertiesSet()</code>由<code>InitializingBean</code>回调接口定义</li>
<li>自定义配置的<code>init()</code>方法</li>
</ul>
<p>Destroy 方法在同一个 order 中调用：</p>
<ul>
<li>用<code>@PreDestroy</code>注释的方法</li>
<li><code>destroy()</code>由<code>DisposableBean</code>回调接口定义</li>
<li>自定义配置的<code>destroy()</code>方法</li>
</ul>
<h5 id="启动和关闭回调"><a href="#启动和关闭回调" class="headerlink" title="启动和关闭回调"></a>启动和关闭回调</h5><p><code>Lifecycle</code>接口为具有自己的生命周期要求的任何 object 定义了基本方法(例如启动和停止一些后台 process)：</p>
<pre><code>public interface Lifecycle &#123;

    void start();

    void stop();

    boolean isRunning();
&#125;
</code></pre>
<p>任何 Spring-managed object 都可以实现<code>Lifecycle</code>接口。然后，当<code>ApplicationContext</code>本身接收到启动和停止信号时(对于 example，对于运行时的 stop/restart 场景)，它将那些 calls 级联到该 context 中定义的所有<code>Lifecycle</code> __mplement。它通过委托给<code>LifecycleProcessor</code>来实现，如下面的清单所示：</p>
<pre><code>public interface LifecycleProcessor extends Lifecycle &#123;

    void onRefresh();

    void onClose();
&#125;
</code></pre>
<p>请注意，<code>LifecycleProcessor</code>本身是<code>Lifecycle</code>接口的扩展。它还添加了另外两种方法来响应正在刷新和关闭的 context。</p>
<blockquote>
<p>请注意，常规<code>org.springframework.context.Lifecycle</code>接口是用于显式启动和停止通知的普通 contract，并不意味着 auto-startup 在 context refresh time。对于 fine-grained 控制特定 bean 的 auto-startup(包括启动阶段)，请考虑实现<code>org.springframework.context.SmartLifecycle</code>。</p>
</blockquote>
<p>此外，请注意，在销毁之前不保证停止通知。在常规关闭时，所有<code>Lifecycle</code> beans 在传播一般销毁回调之前首先收到停止通知。但是，在 context 生命周期内的热刷新或中止刷新尝试时，仅调用 destroy 方法。</p>
<p>启动和关闭调用的 order 非常重要。如果任何两个 object 之间存在“depends-on”关系，则依赖方在其依赖之后开始，并且在其依赖之前停止。但是，有时，直接依赖性是未知的。您可能只知道某种类型的 objects 应该在另一种类型的 objects 之前开始。在这些情况下，<code>SmartLifecycle</code>接口定义了另一个选项，即 super-interface，<code>Phased</code>上定义的<code>getPhase()</code>方法。以下清单显示了<code>Phased</code>接口的定义：</p>
<pre><code>public interface Phased &#123;

    int getPhase();
&#125;
</code></pre>
<p>以下清单显示了<code>SmartLifecycle</code>接口的定义：</p>
<pre><code>public interface SmartLifecycle extends Lifecycle, Phased &#123;

    boolean isAutoStartup();

    void stop(Runnable callback);
&#125;
</code></pre>
<p>启动时，具有最低相位的 objects 首先启动。停止时，遵循反向顺序。因此，实现<code>SmartLifecycle</code>且其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>的 object 将是第一个开始，最后一个停止。在频谱的另一端，<code>Integer.MAX_VALUE</code>的阶段值将指示 object 应该最后启动并首先停止(可能因为它依赖于其他进程 running)。在考虑阶段 value 时，同样重要的是要知道没有实现<code>SmartLifecycle</code>的任何“正常”<code>Lifecycle</code> object 的默认阶段是<code>0</code>。因此，任何负相位 value 都表示 object 应该在这些标准组件之前启动(并在它们之后停止)。对于任何正相值，反向都是 true。</p>
<p><code>SmartLifecycle</code>定义的 stop 方法接受回调。在 implementation 的 shutdown process 完成之后，任何 implementation 都必须调用该回调的<code>run()</code>方法。这样可以在必要时启用异步关闭，因为<code>LifecycleProcessor</code>接口的默认_impleration <code>DefaultLifecycleProcessor</code>等待每个阶段中 objects 的 group 的超时值，以调用该回调。默认 per-phase 超时为 30 秒。您可以通过在 context 中定义名为<code>lifecycleProcessor</code>的 bean 来覆盖默认生命周期处理器实例。如果您只想修改超时，则定义以下内容就足够了：</p>
<pre><code>&lt;bean id=&quot;lifecycleProcessor&quot; class=&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;&gt;
    &lt;!-- timeout value in milliseconds --&gt;
    &lt;property name=&quot;timeoutPerShutdownPhase&quot; value=&quot;10000&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>如前所述，<code>LifecycleProcessor</code>接口定义了用于刷新和关闭 context 的回调方法。后者驱动 shutdown process，就像显式调用<code>stop()</code>一样，但是当 context 关闭时会发生。另一方面，’refresh’回调启用<code>SmartLifecycle</code> beans 的另一个 feature。刷新 context 时(在实例化并初始化所有 objects 之后)，将调用该回调。此时，默认生命周期处理器检查每个<code>SmartLifecycle</code> object 的<code>isAutoStartup()</code>方法返回的 boolean value。如果<code>true</code>，那个 object 就是在那一点开始而不是等待显式调用 context 或它自己的<code>start()</code>方法(与 context 刷新不同，context start 不会自动发生在标准的 context implementation 中)。 <code>phase</code> value 和任何“depends-on”关系确定了如前所述的 startup order。</p>
<h5 id="在-Non-Web-Applications-中优雅地关闭-Spring-IoC-容器"><a href="#在-Non-Web-Applications-中优雅地关闭-Spring-IoC-容器" class="headerlink" title="在 Non-Web Applications 中优雅地关闭 Spring IoC 容器"></a>在 Non-Web Applications 中优雅地关闭 Spring IoC 容器</h5><blockquote>
<p>本节仅适用于 non-web applications。当相关的 web application 关闭时，Spring 的 web-based <code>ApplicationContext</code> implementations 已经有 code 来正常关闭 Spring IoC 容器。</p>
</blockquote>
<p>如果在 non-web application 环境中使用 Spring 的 IoC 容器(对于 example，在富 client 桌面环境中)，请向 JVM 注册 shutdown hook。这样做可确保正常关闭并 calls singleton beans 上的相关 destroy 方法，以便释放所有资源。您仍然必须正确配置和实现这些 destroy 回调。</p>
<p>要注册 shutdown hook，请调用<code>ConfigurableApplicationContext</code>接口上声明的<code>registerShutdownHook()</code>方法，如下面的 example 所示：</p>
<pre><code>import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot &#123;

    public static void main(final String[] args) throws Exception &#123;
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    &#125;
&#125;
</code></pre>
<h4 id="1-6-2-ApplicationContextAware-和-BeanNameAware"><a href="#1-6-2-ApplicationContextAware-和-BeanNameAware" class="headerlink" title="1.6.2. ApplicationContextAware 和 BeanNameAware"></a>1.6.2. ApplicationContextAware 和 BeanNameAware</h4><p>当<code>ApplicationContext</code>创建实现<code>org.springframework.context.ApplicationContextAware</code>接口的 object 实例时，该实例将提供的 reference。以下清单显示了<code>ApplicationContextAware</code>接口的定义：</p>
<pre><code>public interface ApplicationContextAware &#123;

    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
&#125;
</code></pre>
<p>因此，beans 可以通过<code>ApplicationContext</code>接口以编程方式操纵创建它们的<code>ApplicationContext</code>，或者通过将 reference 转换为此接口的已知子类(例如<code>ConfigurableApplicationContext</code>，这会暴露其他功能)。一种用途是对其他 beans 进行编程检索。有时这种能力很有用。但是，一般情况下，您应该避免使用它，因为它将 code 与 Spring 耦合，并且不遵循 Inversion of Control 样式，其中协作者作为 properties 提供给 beans。 <code>ApplicationContext</code>的其他方法提供对文件资源的访问，发布 application events 和访问<code>MessageSource</code>。这些额外的 features 在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-default-init-destroy-methods">ApplicationContext 的附加功能</a>中描述。</p>
<p>从 Spring 2.5 开始，自动装配是获得<code>ApplicationContext</code>的 reference 的另一种选择。 “传统”<code>constructor</code>和<code>byType</code>自动装配模式(如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#context-introduction">自动化协作者</a>中所述)可以分别为构造函数参数或 setter 方法参数提供类型<code>ApplicationContext</code>的依赖关系。要获得更多灵活性，包括自动装配字段和多参数方法的功能，请使用新的 annotation-based 自动装配 features。如果这样做，<code>ApplicationContext</code>将自动装入一个字段，构造函数参数或方法参数，如果所涉及的字段，构造函数或方法带有<code>@Autowired</code> annotation，则该参数需要<code>ApplicationContext</code>类型。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">使用 @Autowired</a>。</p>
<p>当<code>ApplicationContext</code>创建一个实现<code>org.springframework.beans.factory.BeanNameAware</code>接口的 class 时，class 会提供对其关联的 object 定义中定义的 name 的 reference。以下清单显示了 BeanNameAware 接口的定义：</p>
<pre><code>public interface BeanNameAware &#123;

    void setBeanName(String name) throws BeansException;
&#125;
</code></pre>
<p>在普通 bean properties 的填充之后但在初始化回调之前(例如<code>InitializingBean</code>，<code>afterPropertiesSet</code>或自定义 init-method)之前调用回调。</p>
<h4 id="1-6-3-其他感知接口"><a href="#1-6-3-其他感知接口" class="headerlink" title="1.6.3. 其他感知接口"></a>1.6.3. 其他感知接口</h4><p>除了<code>ApplicationContextAware</code>和<code>BeanNameAware</code>(讨论<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-autowired-annotation">前</a>)之外，Spring 还提供了一系列<code>Aware</code>接口，让 beans 向容器指示它们需要某种基础结构依赖性。作为一般规则，name 是依赖类型的良好指示。以下 table 总结了最重要的<code>Aware</code>接口：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>注入依赖</th>
<th>解释在……</th>
</tr>
</thead>
<tbody><tr>
<td><code>ApplicationContextAware</code></td>
<td>声明<code>ApplicationContext</code>。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">ApplicationContextAware 和 BeanNameAware</a></td>
</tr>
<tr>
<td><code>ApplicationEventPublisherAware</code></td>
<td>封闭<code>ApplicationContext</code>的 Event 发布者。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">ApplicationContext 的附加功能</a></td>
</tr>
<tr>
<td><code>BeanClassLoaderAware</code></td>
<td>Class loader 用于加载 bean classes。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#context-introduction">实例化 Beans</a></td>
</tr>
<tr>
<td><code>BeanFactoryAware</code></td>
<td>声明<code>BeanFactory</code>。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class">ApplicationContextAware 和 BeanNameAware</a></td>
</tr>
<tr>
<td><code>BeanNameAware</code></td>
<td>声明 bean 的名称。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">ApplicationContextAware 和 BeanNameAware</a></td>
</tr>
<tr>
<td><code>BootstrapContextAware</code></td>
<td>资源适配器<code>BootstrapContext</code>容器运行。通常仅在 JCA 感知<code>ApplicationContext</code>实例中可用。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#beans-factory-aware">JCA CCI</a></td>
</tr>
<tr>
<td><code>LoadTimeWeaverAware</code></td>
<td>定义的 weaver 用于在 load time 处理 class 定义。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#cci">Load-time 在 Spring Framework 中使用 AspectJ 进行编织</a></td>
</tr>
<tr>
<td><code>MessageSourceAware</code></td>
<td>用于解析消息的已配置策略(支持参数化和国际化)。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">ApplicationContext 的附加功能</a></td>
</tr>
<tr>
<td><code>NotificationPublisherAware</code></td>
<td>Spring JMX 通知发布者。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#context-introduction">通知</a></td>
</tr>
<tr>
<td><code>ResourceLoaderAware</code></td>
<td>配置加载程序以 low-level 访问资源。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#jmx-notifications">资源</a></td>
</tr>
<tr>
<td><code>ServletConfigAware</code></td>
<td>当前<code>ServletConfig</code>容器运行。仅在 web-aware Spring <code>ApplicationContext</code>中有效。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#resources">Spring MVC</a></td>
</tr>
<tr>
<td><code>ServletContextAware</code></td>
<td>当前<code>ServletContext</code>容器运行。仅在 web-aware Spring <code>ApplicationContext</code>中有效。</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc">Spring MVC</a></td>
</tr>
</tbody></table>
<p>请再次注意，使用这些接口会将 code 绑定到 Spring API，而不会遵循 Inversion of Control 样式。因此，我们建议将它们用于需要以编程方式访问容器的基础结构 beans。</p>
<h3 id="1-7-Bean-定义继承"><a href="#1-7-Bean-定义继承" class="headerlink" title="1.7. Bean 定义继承"></a>1.7. Bean 定义继承</h3><p>bean 定义可以包含许多 configuration 信息，包括构造函数 arguments，property 值和 container-specific 信息，例如初始化方法，静态工厂方法 name 等。 child bean 定义从 parent 定义继承 configuration 数据。 child 定义可以覆盖某些值或根据需要添加其他值。使用 parent 和 child bean 定义可以节省大量的 typing。实际上，这是一种模板形式。</p>
<p>如果以编程方式使用<code>ApplicationContext</code>接口，则 child bean 定义由<code>ChildBeanDefinition</code> class 表示。大多数用户不会在这个 level 上使用它们。相反，它们在 class(例如<code>ClassPathXmlApplicationContext</code>)中以声明方式配置 bean 定义。使用 XML-based configuration 元数据时，可以使用<code>parent</code>属性指定 child bean 定义，并将 parent bean 指定为此属性的 value。以下 example 显示了如何执行此操作：</p>
<pre><code>&lt;bean id=&quot;inheritedTestBean&quot; abstract=&quot;true&quot;
        class=&quot;org.springframework.beans.TestBean&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;inheritsWithDifferentClass&quot;
        class=&quot;org.springframework.beans.DerivedTestBean&quot;
        parent=&quot;inheritedTestBean&quot; init-method=&quot;initialize&quot;&gt;  (1)
    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;
    &lt;!-- the age property value of 1 will be inherited from parent --&gt;
&lt;/bean&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>注意<code>parent</code>属性。</td>
</tr>
</tbody></table>
<p>如果指定了 none，则 child bean 定义使用 parent 定义中的 bean class，但也可以覆盖它。在后一种情况下，child bean class 必须与 parent 兼容(即，它必须接受 parent 的 property 值)。</p>
<p>child bean 定义从 parent 继承范围，构造函数参数值，属性值和方法覆盖，并带有添加新值的选项。您指定的任何范围，初始化方法，销毁方法或<code>static</code>工厂方法设置都会覆盖相应的 parent 设置。</p>
<p>其余设置始终取自 child 定义：依赖于，autowire 模式，依赖性检查，singleton 和 lazy init。</p>
<p>前面的 example 使用<code>abstract</code>属性显式地将 parent bean 定义标记为 abstract。如果 parent 定义未指定 class，则需要将 parent bean 定义显式标记为<code>abstract</code>，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;inheritedTestBeanWithoutClass&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;inheritsWithClass&quot; class=&quot;org.springframework.beans.DerivedTestBean&quot;
        parent=&quot;inheritedTestBeanWithoutClass&quot; init-method=&quot;initialize&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;
    &lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;
&lt;/bean&gt;
</code></pre>
<p>parent bean 无法单独实例化，因为它不完整，并且也明确标记为<code>abstract</code>。当定义为<code>abstract</code>时，它仅可用作纯模板 bean 定义，用作 child 定义的 parent 定义。尝试使用这样的<code>abstract</code> parent bean，通过将其称为另一个 bean 的 ref property 或使用 parent bean ID 进行显式<code>getBean()</code>调用返回错误。类似地，容器的内部<code>preInstantiateSingletons()</code>方法忽略定义为 abstract 的 bean 定义。</p>
<blockquote>
<p><code>ApplicationContext</code> pre-instantiates 默认情况下所有单身人士。因此，重要的是(至少对于 singleton beans)，如果你有一个(parent)bean 定义，你打算只用作模板，并且这个定义指定一个 class，你必须确保将 abstract 属性设置为 true ，否则 application context 将实际(尝试)pre-instantiate <code>abstract</code> bean。</p>
</blockquote>
<h3 id="1-8-集装箱扩建点"><a href="#1-8-集装箱扩建点" class="headerlink" title="1.8. 集装箱扩建点"></a>1.8. 集装箱扩建点</h3><p>通常，application 开发人员不需要子类<code>ApplicationContext</code> implementation classes。相反，可以通过插入特殊 integration 接口的 implementations 来扩展 Spring IoC 容器。接下来的几节将介绍这些 integration 接口。</p>
<h4 id="1-8-1-使用-BeanPostProcessor-自定义-Beans"><a href="#1-8-1-使用-BeanPostProcessor-自定义-Beans" class="headerlink" title="1.8.1. 使用 BeanPostProcessor 自定义 Beans"></a>1.8.1. 使用 BeanPostProcessor 自定义 Beans</h4><p><code>BeanPostProcessor</code>接口定义了您可以实现的回调方法，以提供您自己的(或覆盖容器的默认)实例化逻辑，dependency-resolution 逻辑等。如果要在 Spring 容器完成实例化，配置和初始化 bean 之后实现某些自定义逻辑，则可以插入一个或多个<code>BeanPostProcessor</code> implementations。</p>
<p>您可以配置多个<code>BeanPostProcessor</code>实例，并且可以通过设置<code>order</code> property 来控制执行这些<code>BeanPostProcessor</code>实例的 order。仅当<code>BeanPostProcessor</code>实现<code>Ordered</code>接口时，才能设置此 property。如果你自己编写<code>BeanPostProcessor</code>，你也应该考虑实现<code>Ordered</code>接口。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html">BeanPostProcessor</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Ordered.html">有序</a>接口的 javadoc。另见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc">BeanPostProcessor 实例的编程注册</a>上的注释。</p>
<blockquote>
<p><code>BeanPostProcessor</code>实例在 bean(或 object)实例上运行。也就是说，Spring IoC 容器实例化 bean 实例，然后<code>BeanPostProcessor</code>实例执行它们的工作。</p>
</blockquote>
<p><code>BeanPostProcessor</code>实例的范围是 per-container。仅当您使用容器层次结构时，这才是相关的。如果在一个容器中定义<code>BeanPostProcessor</code>，则 post-processes 仅包含该容器中的 beans。换句话说，在一个容器中定义的 beans 不是由另一个容器中定义的<code>BeanPostProcessor</code> post-processed，即使两个容器都是同一层次结构的一部分。</p>
<p>要更改实际的 bean 定义(即定义 bean 的蓝图)，您需要使用<code>BeanFactoryPostProcessor</code>，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-programmatically-registering-beanpostprocessors">使用 BeanFactoryPostProcessor 自定义 Configuration 元数据</a>中所述。</p>
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口恰好包含两个回调方法。当这样的 class 被容器注册为 post-processor 时，对于容器创建的每个 bean 实例，post-processor 在容器初始化方法(例如<code>InitializingBean.afterPropertiesSet()</code>，在任何声明的<code>init</code>方法之后)被调用之前都从容器获得回调，以及任何 bean 初始化回调之后。 post-processor 可以对 bean 实例执行任何操作，包括完全忽略回调。 bean post-processor 通常检查回调接口，或者它可以用代理包装 bean。一些 Spring AOP 基础结构 classes 在 order 中实现为 bean post-processors 以提供 proxy-wrapping 逻辑。</p>
<p><code>ApplicationContext</code>自动检测在实现<code>BeanPostProcessor</code>接口的 configuration 元数据中定义的任何 beans。 <code>ApplicationContext</code>将 beans 注册为 post-processors，以便稍后在 bean 创建时调用它们。 Bean post-processors 可以以与任何其他 beans 相同的方式部署在容器中。</p>
<p>请注意，在 configuration class 上使用<code>@Bean</code>工厂方法声明<code>BeanPostProcessor</code>时，工厂方法的 return 类型应该是 implementation class 本身或至少<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口，清楚地表明该 bean 的 post-processor 性质。否则，在完全_create 之前，<code>ApplicationContext</code>不能按类型自动检测它。由于需要在 order 中提前实例化以应用于 context 中其他 beans 的初始化，因此这种早期类型检测至关重要。</p>
<blockquote>
<p>以编程方式注册<code>BeanPostProcessor</code>实例虽然推荐的<code>BeanPostProcessor</code>注册方法是通过<code>ApplicationContext</code> auto-detection(如前所述)，但您可以使用<code>addBeanPostProcessor</code>方法以编程方式对<code>ConfigurableBeanFactory</code>进行注册。当您需要在注册前评估条件逻辑，甚至在层次结构中跨上下文复制 bean 后处理器时，这非常有用。但请注意，以编程方式添加的<code>BeanPostProcessor</code>实例不尊重<code>Ordered</code>接口。在这里，注册的顺序决定了执行的顺序。另请注意，以编程方式注册的<code>BeanPostProcessor</code>实例始终在通过 auto-detection 注册的实例之前处理，而不管任何显式的 ordering。</p>
</blockquote>
<blockquote>
<p><code>BeanPostProcessor</code>实例和 AOP auto-proxying</p>
</blockquote>
<p>_实现<code>BeanPostProcessor</code>接口的类是特殊的，容器对它们的处理方式不同。它们直接 reference 的所有<code>BeanPostProcessor</code>实例和 beans 在启动时被实例化，作为<code>ApplicationContext</code>的特殊启动阶段的一部分。接下来，所有<code>BeanPostProcessor</code>实例都以排序方式注册，并应用于容器中的所有其他 beans。因为 AOP auto-proxying 是作为<code>BeanPostProcessor</code>本身实现的，所以<code>BeanPostProcessor</code>实例和它们直接引用的 beans 都不符合 auto-proxying 的条件，因此没有编入方面的方面。</p>
<p>对于任何此类 bean，您应该看到一条信息 log 消息：<code>Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</code>。</p>
<p>如果使用自动装配或<code>@Resource</code>(可能会回退到自动装配)将 beans 连接到<code>BeanPostProcessor</code>，Spring 可能会在搜索 type-matching 依赖项候选时访问意外的 beans，因此使它们不适合 auto-proxying 或其他类型的 bean post-processing。例如，如果您有一个使用<code>@Resource</code>注释的依赖项，其中 field 或 setter name 不直接对应_ bean 的声明 name 且未使用 name 属性，则 Spring 会访问其他 beans 以按类型匹配它们。</p>
<p>以下示例显示如何在<code>ApplicationContext</code>中编写，注册和使用<code>BeanPostProcessor</code>实例。</p>
<h5 id="示例：Hello-World，BeanPostProcessor-style"><a href="#示例：Hello-World，BeanPostProcessor-style" class="headerlink" title="示例：Hello World，BeanPostProcessor-style"></a>示例：Hello World，BeanPostProcessor-style</h5><p>第一个例子说明了基本用法。 example 显示了一个自定义<code>BeanPostProcessor</code> implementation，它调用容器创建的每个 bean 的<code>toString()</code>方法，并将生成的 string 打印到系统 console。</p>
<p>以下清单显示了自定义<code>BeanPostProcessor</code> implementation class 定义：</p>
<pre><code>package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor &#123;

    // simply return the instantiated bean as-is
    public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;
        return bean; // we could potentially return any object reference here...
    &#125;

    public Object postProcessAfterInitialization(Object bean, String beanName) &#123;
        System.out.println(&quot;Bean &#39;&quot; + beanName + &quot;&#39; created : &quot; + bean.toString());
        return bean;
    &#125;
&#125;
</code></pre>
<p>以下<code>beans</code>元素使用<code>InstantiationTracingBeanPostProcessor</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang
        http://www.springframework.org/schema/lang/spring-lang.xsd&quot;&gt;

    &lt;lang:groovy id=&quot;messenger&quot;
            script-source=&quot;classpath:org/springframework/scripting/groovy/Messenger.groovy&quot;&gt;
        &lt;lang:property name=&quot;message&quot; value=&quot;Fiona Apple Is Just So Dreamy.&quot;/&gt;
    &lt;/lang:groovy&gt;

    &lt;!--
    when the above bean (messenger) is instantiated, this custom
    BeanPostProcessor implementation will output the fact to the system console
    --&gt;
    &lt;bean class=&quot;scripting.InstantiationTracingBeanPostProcessor&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>注意如何定义<code>InstantiationTracingBeanPostProcessor</code>。它甚至没有 name，因为它是一个 bean，它可以像任何其他 bean 一样 dependency-injected。 (前面的 configuration 还定义了一个由 Groovy 脚本支持的 bean.Spring 动态语言支持在名为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/languages.html#beans-factory-extension-factory-postprocessors">动态语言支持</a> .)的章节中有详细说明。</p>
<p>以下 Java application 运行前面的 code 和 configuration：</p>
<pre><code>import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot &#123;

    public static void main(final String[] args) throws Exception &#123;
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;scripting/beans.xml&quot;);
        Messenger messenger = (Messenger) ctx.getBean(&quot;messenger&quot;);
        System.out.println(messenger);
    &#125;

&#125;
</code></pre>
<p>前面的 application 的输出类似于以下内容：</p>
<pre><code>Bean &#39;messenger&#39; created : org.springframework.scripting.groovy.GroovyMesse[emailprotected]
[emailprotected]
</code></pre>
<h5 id="Example：RequiredAnnotationBeanPostProcessor"><a href="#Example：RequiredAnnotationBeanPostProcessor" class="headerlink" title="Example：RequiredAnnotationBeanPostProcessor"></a>Example：RequiredAnnotationBeanPostProcessor</h5><p>将回调接口或 annotations 与自定义<code>BeanPostProcessor</code> implementation 结合使用是扩展 Spring IoC 容器的常用方法。一个 example 是 Spring 的<code>RequiredAnnotationBeanPostProcessor</code> - 一个带有 Spring 分布的<code>BeanPostProcessor</code> implementation，它确保 beans 上标记有(任意)annotation 的 JavaBean properties 实际上(配置为)带有 value 的 dependency-injected。</p>
<h4 id="1-8-2-使用-BeanFactoryPostProcessor-自定义-Configuration-元数据"><a href="#1-8-2-使用-BeanFactoryPostProcessor-自定义-Configuration-元数据" class="headerlink" title="1.8.2. 使用 BeanFactoryPostProcessor 自定义 Configuration 元数据"></a>1.8.2. 使用 BeanFactoryPostProcessor 自定义 Configuration 元数据</h4><p>我们看到的下一个扩展点是<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>。此接口的语义类似于<code>BeanPostProcessor</code>的语义，但有一个主要区别：<code>BeanFactoryPostProcessor</code>对 bean configuration 元数据进行操作。也就是说，Spring IoC 容器允许<code>BeanFactoryPostProcessor</code>读取 configuration 元数据，并可能在容器实例化除<code>BeanFactoryPostProcessor</code>实例之外的任何 beans 之前更改它。</p>
<p>您可以配置多个<code>BeanFactoryPostProcessor</code>实例，并且可以通过设置<code>order</code> property 来控制这些<code>BeanFactoryPostProcessor</code>实例 run 的 order。但是，如果<code>BeanFactoryPostProcessor</code>实现<code>Ordered</code>接口，则只能设置此 property。如果你自己编写<code>BeanFactoryPostProcessor</code>，你也应该考虑实现<code>Ordered</code>接口。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html">BeanFactoryPostProcessor</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Ordered.html">有序</a>接口的 javadoc。</p>
<blockquote>
<p>如果要更改实际的 bean 实例(即，从 configuration 元数据创建的 objects)，则需要使用<code>BeanPostProcessor</code>(前面在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#dynamic-language">使用 BeanPostProcessor 自定义 Beans</a>中描述)。虽然技术上可以在<code>BeanFactoryPostProcessor</code>中使用 bean 实例(例如，通过使用<code>BeanFactory.getBean()</code>)，但这样做会导致过早的 bean 实例化，从而违反标准容器生命周期。这可能会导致负面影响，例如绕过 bean 后期处理。</p>
</blockquote>
<p>此外，<code>BeanFactoryPostProcessor</code>实例的范围是 per-container。仅当您使用容器层次结构时，这才有意义。如果在一个容器中定义<code>BeanFactoryPostProcessor</code>，则它仅应用于该容器中的 bean 定义。一个容器中的 Bean 定义不是<code>BeanFactoryPostProcessor</code>在另一个容器中的<code>BeanFactoryPostProcessor</code>实例，即使两个容器都是同一层次结构的一部分。</p>
<p>工厂 post-processor 在<code>ApplicationContext</code>中声明时自动执行，在 order 中将更改应用于定义容器的 configuration 元数据。 Spring 包含许多预定义的 bean factory post-processors，例如<code>PropertyOverrideConfigurer</code>和<code>PropertyPlaceholderConfigurer</code>。您还可以使用自定义<code>BeanFactoryPostProcessor</code> - for example 来注册自定义 property 编辑器。</p>
<p><code>ApplicationContext</code>自动检测部署到其中的任何实现<code>BeanFactoryPostProcessor</code>接口的 beans。它在适当的 time 使用 beans 作为 bean factory post-processors。您可以像处理任何其他 bean 一样部署这些 post-processor beans。</p>
<blockquote>
<p>与<code>BeanPostProcessor</code>一样，您通常不希望为延迟初始化配置<code>BeanFactoryPostProcessor</code>。如果没有其他 bean references a <code>Bean(Factory)PostProcessor</code>，post-processor 将根本不会被实例化。因此，将忽略将其标记为延迟初始化，即使在<code>&lt;beans /&gt;</code>元素的声明上将<code>default-lazy-init</code>属性设置为<code>true</code>，也会急切地实例化<code>Bean(Factory)PostProcessor</code>。</p>
</blockquote>
<h5 id="Example：Class-Name-Substitution-PropertyPlaceholderConfigurer"><a href="#Example：Class-Name-Substitution-PropertyPlaceholderConfigurer" class="headerlink" title="Example：Class Name Substitution PropertyPlaceholderConfigurer"></a>Example：Class Name Substitution PropertyPlaceholderConfigurer</h5><p>您可以使用<code>PropertyPlaceholderConfigurer</code>来使用标准 Java <code>Properties</code>格式在单独的文件中将 bean 定义中的 property 值外部化。这样做可以使部署 application 的人员自定义 environment-specific properties，例如数据库 URL 和密码，而不会有修改主 XML 定义文件或容器的 files 的复杂性或风险。</p>
<p>考虑以下 XML-based configuration 元数据片段，其中定义了带占位符值的<code>DataSource</code>：</p>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
    &lt;property name=&quot;locations&quot; value=&quot;classpath:com/something/jdbc.properties&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;dataSource&quot; destroy-method=&quot;close&quot;
        class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>example 显示了从外部<code>Properties</code>文件配置的 properties。在运行时，将<code>PropertyPlaceholderConfigurer</code>应用于替换 DataSource 的某些 properties 的元数据。要替换的值被指定为<code>$&#123;property-name&#125;</code>形式的占位符，它遵循 Ant 和 log4j 以及 JSP EL 样式。</p>
<p>实际值来自标准 Java <code>Properties</code>格式的另一个文件：</p>
<pre><code>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
</code></pre>
<p>因此，<code>$&#123;jdbc.username&#125;</code> string 在运行时将替换为 value，’sa’，同样适用于 properties 文件中 match 键的其他占位符值。 <code>PropertyPlaceholderConfigurer</code>检查大多数 properties 中的占位符和 bean 定义的属性。此外，您可以自定义占位符前缀和后缀。</p>
<p>使用 Spring 2.5 中引入的<code>context</code>名称空间，可以使用专用的 configuration 元素配置 property 占位符。您可以在<code>location</code>属性中提供一个或多个位置作为 comma-separated 列表，如下面的 example 所示：</p>
<pre><code>&lt;context:property-placeholder location=&quot;classpath:com/something/jdbc.properties&quot;/&gt;
</code></pre>
<p><code>PropertyPlaceholderConfigurer</code>不仅在您指定的<code>Properties</code>文件中查找 properties。默认情况下，如果它在指定的 properties files 中找不到 property，它还会检查 Java <code>System</code> properties。您可以通过使用以下三个支持的 integer 值之一设置 configurer 的<code>systemPropertiesMode</code> property 来自定义此行为：</p>
<ul>
<li><code>never</code>(0)：从不检查系统 properties。</li>
<li><code>fallback</code>(1)：如果在指定的 properties files 中无法解析，则检查系统 properties。这是默认值。</li>
<li><code>override</code>(2)：在尝试指定的 properties files 之前，先检查系统 properties。这使系统 properties 可以覆盖任何其他 property 源。</li>
</ul>
<p>有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html">PropertyPlaceholderConfigurer</a> javadoc。</p>
<blockquote>
<p>您可以使用<code>PropertyPlaceholderConfigurer</code>替换 class 名称，这在您必须在运行时选择特定的 implementation class 时有用。以下 example 显示了如何执行此操作：</p>
</blockquote>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
    &lt;property name=&quot;locations&quot;&gt;
        &lt;value&gt;classpath:com/something/strategy.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;value&gt;custom.strategy.class=com.something.DefaultStrategy&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;serviceStrategy&quot; class=&quot;$&#123;custom.strategy.class&#125;&quot;/&gt;
</code></pre>
<p>如果 class 在运行时无法解析为有效的 class，则 bean 的解析将在创建时失败，即</p>
<h5 id="Example：PropertyOverrideConfigurer"><a href="#Example：PropertyOverrideConfigurer" class="headerlink" title="Example：PropertyOverrideConfigurer"></a>Example：PropertyOverrideConfigurer</h5><p><code>PropertyOverrideConfigurer</code>，另一个 bean 工厂 post-processor，类似于<code>PropertyPlaceholderConfigurer</code>，但与后者不同，原始定义可以为 bean properties 提供默认值或根本没有值。如果重写的<code>Properties</code>文件没有某个 bean property 的条目，则使用默认的 context 定义。</p>
<p>请注意，bean 定义不知道被覆盖，因此从 XML 定义文件中可以立即看出正在使用覆盖配置器。如果多个<code>PropertyOverrideConfigurer</code>实例为同一个 bean property 定义了不同的值，则由于覆盖机制，最后一个获胜。</p>
<p>Properties 文件 configuration lines 采用以下格式：</p>
<pre><code>beanName.property=value
</code></pre>
<p>以下清单显示了格式的示例：</p>
<pre><code>dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
</code></pre>
<p>此 example 文件可以与容器定义一起使用，该容器定义包含名为<code>dataSource</code>的 bean，该具有<code>driver</code>和<code>url</code> properties。</p>
<p>复合 property 名称也被支持，因为 long 作为路径的每个 component 除了被覆盖的最终 property 已经 non-null(可能由构造函数初始化)。在下面的示例中，<code>tom</code> bean 的<code>fred</code> property 的<code>bob</code> property 的<code>sammy</code> property 设置为标量 value <code>123</code>：</p>
<pre><code>tom.fred.bob.sammy=123
</code></pre>
<blockquote>
<p>指定的覆盖值始终是文字值。它们没有被翻译成 bean references。当 XML bean 定义中的原始 value 指定 bean reference 时，此约定也适用。</p>
</blockquote>
<p>使用 Spring 2.5 中引入的<code>context</code>名称空间，可以使用专用的 configuration 元素配置 property 覆盖，如下面的 example 所示：</p>
<pre><code>&lt;context:property-override location=&quot;classpath:override.properties&quot;/&gt;
</code></pre>
<h4 id="1-8-3-使用-FactoryBean-自定义实例化逻辑"><a href="#1-8-3-使用-FactoryBean-自定义实例化逻辑" class="headerlink" title="1.8.3. 使用 FactoryBean 自定义实例化逻辑"></a>1.8.3. 使用 FactoryBean 自定义实例化逻辑</h4><p>您可以为本身为工厂的 objects 实现<code>org.springframework.beans.factory.FactoryBean</code>接口。</p>
<p><code>FactoryBean</code>接口是可插入 Spring IoC 容器的实例化逻辑的一个点。如果你有一个复杂的初始化 code，用 Java 表示，而不是(可能)冗长的 XML，你可以创建自己的<code>FactoryBean</code>，在 class 中编写复杂的初始化，然后将自定义<code>FactoryBean</code>插入容器。</p>
<p><code>FactoryBean</code>接口提供了三种方法：</p>
<ul>
<li><code>Object getObject()</code>：返回此工厂创建的 object 的实例。可以共享实例，具体取决于此工厂是返回单例还是原型。</li>
<li><code>boolean isSingleton()</code>：如果<code>FactoryBean</code>返回单例，则返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>Class getObjectType()</code>：返回<code>getObject()</code>方法返回的 object 类型，如果事先不知道类型，则返回<code>null</code>。</li>
</ul>
<p><code>FactoryBean</code>概念和接口用于 Spring Framework 中的许多位置。 <code>FactoryBean</code>接口的 50 多个 implementations 与 Spring 本身一起发布。</p>
<p>当你需要向一个容器询问一个实际的<code>FactoryBean</code>实例本身而不是它生成的 bean 时，在调用<code>ApplicationContext</code>的<code>getBean()</code>方法时，_BE 的<code>id</code>前面带有＆符号(<code>&amp;</code>)。因此，对于具有<code>id</code> <code>myBean</code>的给定<code>FactoryBean</code>，在容器上调用<code>getBean(&quot;myBean&quot;)</code>将返回<code>FactoryBean</code>的乘积，而调用<code>getBean(&quot;&amp;myBean&quot;)</code>则返回<code>FactoryBean</code>实例本身。</p>
<h3 id="1-9-Annotation-based-Container-Configuration"><a href="#1-9-Annotation-based-Container-Configuration" class="headerlink" title="1.9. Annotation-based Container Configuration"></a>1.9. Annotation-based Container Configuration</h3><p>annotations 比 XML 更适合配置 Spring 吗？</p>
<p>annotation-based configuration 的引入提出了这种方法是否比 XML 更“好”的问题。简短的回答是“这取决于”。答案是，每种方法都有其优点和缺点，通常，由开发人员决定哪种策略更适合他们。由于它们的定义方式，annotations 在其声明中提供了大量的 context，从而导致更简洁，更简洁的 configuration。但是，XML 擅长在不触及 source code 或重新编译它们的情况下连接组件。一些开发人员更喜欢将布线靠近源，而其他开发人员则认为带注释的 classes 不再是 POJO，而且 configuration 变得分散且难以控制。</p>
<p>无论选择如何，Spring 都可以兼顾两种风格，甚至可以将它们混合在一起。值得指出的是，通过其<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension-bpp">JavaConfig</a>选项，Spring 允许注释以 non-invasive 方式使用，而不触及目标组件 source code，并且在工具方面，<a target="_blank" rel="noopener" href="https://spring.io/tools/sts">Spring 工具套件</a>支持所有 configuration 样式。</p>
<p>annotation-based configuration 提供了 XML 设置的替代方法，它依赖于字节码元数据来连接组件而不是 angle-bracket 声明。开发人员不使用 XML 来描述 bean 布线，而是通过在相关的 class，方法或字段声明上使用 annotations 将 configuration 移动到 component class 本身。如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java">Example：RequiredAnnotationBeanPostProcessor</a>中所述，将<code>BeanPostProcessor</code>与 annotations 结合使用是扩展 Spring IoC 容器的常用方法。例如，Spring 2.0 引入了使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension-bpp-examples-rabpp">@Required</a> annotation 强制执行所需 properties 的可能性。 Spring 2.5 使得有可能采用相同的通用方法来驱动 Spring 的依赖注入。从本质上讲，<code>@Autowired</code> annotation 提供了与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-required-annotation">自动化协作者</a>中描述的相同的功能，但具有更多的 fine-grained 控制和更广泛的适用性。 Spring 2.5 还添加了对 JSR-250 注释的支持，例如<code>@PostConstruct</code>和<code>@PreDestroy</code>。 Spring 3.0 添加了有关这些注释的详细信息可以在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">相关部分</a>中找到。</p>
<blockquote>
<p>注释注入在 XML 注入之前执行。因此，XML configuration 会覆盖通过这两种方法连接的 properties 的 annotations。</p>
</blockquote>
<p>与往常一样，您可以将它们注册为单独的 bean 定义，但也可以通过在 XML-based Spring configuration 中包含以下标记来隐式注册它们(注意包含<code>context</code>命名空间)：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<p>(隐式注册的 post-processors 包括<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html">AutowiredAnnotationBeanPostProcessor</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html">CommonAnnotationBeanPostProcessor 会</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html">PersistenceAnnotationBeanPostProcessor</a>和前面提到的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html">RequiredAnnotationBeanPostProcessor</a> .)</p>
<blockquote>
<p><code>&lt;context:annotation-config/&gt;</code>仅在定义它的同一 application context 中查找 beans 上的 annotations。这意味着，如果将<code>&lt;context:annotation-config/&gt;</code>放在<code>WebApplicationContext</code>中<code>DispatcherServlet</code>，它只检查控制器中的<code>@Autowired</code> beans，而不检查您的服务。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#beans-standard-annotations">DispatcherServlet</a>。</p>
</blockquote>
<h4 id="1-9-1-Required"><a href="#1-9-1-Required" class="headerlink" title="1.9.1. @Required"></a>1.9.1. @Required</h4><p><code>@Required</code> annotation 适用于 bean property setter 方法，如下例所示：</p>
<pre><code>public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    // ...
&#125;
</code></pre>
<p>此 annotation 指示必须在 configuration time，bean 定义中的显式 property value 或通过自动装配填充受影响的 bean property。如果尚未填充受影响的 bean property，则容器会抛出 exception。这允许急切和明确的失败，以后避免<code>NullPointerException</code>实例等。我们仍然建议您将断言放入 bean class 本身(对于 example，放入 init 方法)。即使在容器外部使用 class，这样做也会强制执行那些必需的 references 和值。</p>
<h4 id="1-9-2-使用-Autowired"><a href="#1-9-2-使用-Autowired" class="headerlink" title="1.9.2. 使用 @Autowired"></a>1.9.2. 使用 @Autowired</h4><blockquote>
<p>在本节所包含的示例中，可以使用 JSR 330 的<code>@Inject</code> annotation 代替 Spring 的<code>@Autowired</code> annotation。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-servlet">这里</a>。</p>
</blockquote>
<p>您可以将<code>@Autowired</code> annotation 应用于构造函数，如以下 example 所示：</p>
<pre><code>public class MovieRecommender &#123;

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;
        this.customerPreferenceDao = customerPreferenceDao;
    &#125;

    // ...
&#125;
</code></pre>
<blockquote>
<p>从 Spring Framework 4.3 开始，如果目标 bean 仅定义一个开头的构造函数，则不再需要在这样的构造函数上使用<code>@Autowired</code> annotation。但是，如果有几个构造器可用，则必须注释至少一个构造器以教导容器使用哪一个。</p>
</blockquote>
<p>您还可以将<code>@Autowired</code> annotation 应用于“传统”setter 方法，如以下 example 所示：</p>
<pre><code>public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    // ...
&#125;
</code></pre>
<p>您还可以将 annotation 应用于具有任意名称和多个 arguments 的方法，如下面的 example 所示：</p>
<pre><code>public class MovieRecommender &#123;

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) &#123;
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    &#125;

    // ...
&#125;
</code></pre>
<p>您也可以将<code>@Autowired</code>应用于字段，甚至可以将其与构造函数混合使用，如下面的示例所示：</p>
<pre><code>public class MovieRecommender &#123;

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;
        this.customerPreferenceDao = customerPreferenceDao;
    &#125;

    // ...
&#125;
</code></pre>
<blockquote>
<p>确保您的目标组件(对于 example，<code>MovieCatalog</code>或<code>CustomerPreferenceDao</code>)始终由您用于<code>@Autowired</code> -annotated 注入点的类型声明。否则，由于在运行时找不到类型 match，注入可能会失败。</p>
</blockquote>
<p>对于通过 classpath 扫描找到的 XML-defined beans 或 component classes，容器通常预先知道具体类型。但是，对于<code>@Bean</code>工厂方法，您需要确保声明的 return 类型具有足够的表现力。对于实现多个接口的组件或可能由其 implementation 类型引用的组件，请考虑在工厂方法中声明最具体的 return 类型(至少与引用 bean 的注入点所需的具体类型相同)。</p>
<p>您还可以通过将 annotation 添加到需要该类型的 array 的字段或方法来提供<code>ApplicationContext</code>中特定类型的所有 beans，如下面的 example 所示：</p>
<pre><code>public class MovieRecommender &#123;

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...
&#125;
</code></pre>
<p>这同样适用于类型化集合，如以下 example 所示：</p>
<pre><code>public class MovieRecommender &#123;

    private Set&lt;MovieCatalog&gt; movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;
        this.movieCatalogs = movieCatalogs;
    &#125;

    // ...
&#125;
</code></pre>
<blockquote>
<p>如果希望 array 或列表中的项目按特定 order 排序，则目标 beans 可以实现<code>org.springframework.core.Ordered</code>接口或使用<code>@Order</code>或标准<code>@Priority</code> annotation。否则，它们的 order 遵循容器中相应目标 bean 定义的 registration order。</p>
</blockquote>
<p>您可以在 target class level 和<code>@Bean</code>方法上声明<code>@Order</code> annotation，可能是通过单独的 bean 定义(如果多个定义使用相同的 bean class)。 <code>@Order</code>值可能会影响注入点的优先级，但请注意它们不会影响 singleton startup order，这是由依赖关系和<code>@DependsOn</code>声明确定的正交关注点。</p>
<p>请注意，标准<code>javax.annotation.Priority</code> annotation 在<code>@Bean</code> level 中不可用，因为它无法在方法上声明。对于每种类型，它的语义可以通过<code>@Order</code>值与<code>@Primary</code>组合在一个 bean 上建模。</p>
<p>即使是键入的<code>Map</code>实例也可以自动装配为 long，因为预期的 key 类型是<code>String</code>。 Map 值包含期望类型的所有 beans，并且键包含相应的 bean 名称，如下面的 example 所示：</p>
<pre><code>public class MovieRecommender &#123;

    private Map&lt;String, MovieCatalog&gt; movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123;
        this.movieCatalogs = movieCatalogs;
    &#125;

    // ...
&#125;
</code></pre>
<p>默认情况下，只要零候选 beans 可用，自动装配就会失败。默认行为是将带注释的方法，构造函数和字段视为指示所需的依赖项。您可以在以下 example 中更改此行为：</p>
<pre><code>public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    // ...
&#125;
</code></pre>
<blockquote>
<p>只能将一个带注释的构造函数 per-class 标记为必需，但可以注释多个 non-required 构造函数。在这种情况下，每个都被认为是候选者之一，Spring 使用最贪婪的构造函数，其依赖性可以得到满足 - 也就是说，具有最大数量的 arguments 的构造函数。</p>
</blockquote>
<p>建议<code>@Autowired</code>的必需属性优于<code>@Required</code> annotation。 required 属性表示自动装配不需要 property。如果无法自动装配，则忽略 property。另一方面，<code>@Required</code>更强大，因为它强制执行由容器支持的任何方式设置的 property。如果没有注入 value，则引发相应的 exception。</p>
<p>或者，您可以通过 Java 8 的<code>java.util.Optional</code>表达特定依赖关系的 non-required 性质，如下面的示例所示：</p>
<pre><code>public class SimpleMovieLister &#123;

    @Autowired
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>从 Spring Framework 5.0 开始，您还可以使用<code>@Nullable</code> annotation(任何包中的任何类型 - 对于 example，<code>javax.annotation.Nullable</code>来自 JSR-305)：</p>
<pre><code>public class SimpleMovieLister &#123;

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) &#123;
        ...
    &#125;
&#125;
</code></pre>
<p>您还可以将<code>@Autowired</code>用于 well-known 可解析依赖项的接口：<code>BeanFactory</code>，<code>ApplicationContext</code>，<code>Environment</code>，<code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>和<code>MessageSource</code>。这些接口及其扩展接口(如<code>ConfigurableApplicationContext</code>或<code>ResourcePatternResolver</code>)将自动解析，无需特殊设置。以下 example 自动装配<code>ApplicationContext</code> object：</p>
<pre><code>public class MovieRecommender &#123;

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() &#123;
    &#125;

    // ...
&#125;
</code></pre>
<blockquote>
<p><code>@Autowired</code>，<code>@Inject</code>，<code>@Resource</code>和<code>@Value</code> 注释由 Spring <code>BeanPostProcessor</code> implementations 处理。这意味着您无法在自己的<code>BeanPostProcessor</code>或<code>BeanFactoryPostProcessor</code>类型(如果有)中应用这些注释。必须使用 XML 或 Spring <code>@Bean</code>方法显式“连接”这些类型。</p>
</blockquote>
<h4 id="1-9-3-Fine-tuning-Annotation-based-使用-Primary-自动装配"><a href="#1-9-3-Fine-tuning-Annotation-based-使用-Primary-自动装配" class="headerlink" title="1.9.3. Fine-tuning Annotation-based 使用 @Primary 自动装配"></a>1.9.3. Fine-tuning Annotation-based 使用 @Primary 自动装配</h4><p>由于按类型自动装配可能会导致多个候选项，因此通常需要对选择 process 进行更多控制。实现此目的的一种方法是使用 Spring 的<code>@Primary</code> annotation。 <code>@Primary</code>表示当多个 beans 是自动连接到 single-valued 依赖项的候选者时，应该优先选择特定的 bean。如果候选者中只存在一个主 bean，则它将成为自动连接的 value。</p>
<p>请考虑以下 configuration 将<code>firstMovieCatalog</code>定义为主<code>MovieCatalog</code>：</p>
<pre><code>@Configuration
public class MovieConfiguration &#123;

    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() &#123; ... &#125;

    @Bean
    public MovieCatalog secondMovieCatalog() &#123; ... &#125;

    // ...
&#125;
</code></pre>
<p>使用前面的 configuration，以下<code>MovieRecommender</code>与<code>firstMovieCatalog</code>一起自动装配：</p>
<pre><code>public class MovieRecommender &#123;

    @Autowired
    private MovieCatalog movieCatalog;

    // ...
&#125;
</code></pre>
<p>相应的 bean 定义如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot; primary=&quot;true&quot;&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<h4 id="1-9-4-Fine-tuning-Annotation-based-使用限定符自动装配"><a href="#1-9-4-Fine-tuning-Annotation-based-使用限定符自动装配" class="headerlink" title="1.9.4. Fine-tuning Annotation-based 使用限定符自动装配"></a>1.9.4. Fine-tuning Annotation-based 使用限定符自动装配</h4><p>当可以确定一个主要候选者时，<code>@Primary</code>是一种有效的方式，可以通过多个实例使用类型自动装配。当您需要更多控制选择 process 时，可以使用 Spring 的<code>@Qualifier</code> annotation。您可以将限定符值与特定的 arguments 相关联，缩小类型匹配集，以便为每个参数选择特定的 bean。在最简单的情况下，这可以是一个简单的描述性 value，如下面的示例所示：</p>
<pre><code>public class MovieRecommender &#123;

    @Autowired
    @Qualifier(&quot;main&quot;)
    private MovieCatalog movieCatalog;

    // ...
&#125;
</code></pre>
<p>您还可以在单个构造函数 arguments 或方法参数上指定<code>@Qualifier</code> annotation，如以下 example 所示：</p>
<pre><code>public class MovieRecommender &#123;

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier(&quot;main&quot;)MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) &#123;
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    &#125;

    // ...
&#125;
</code></pre>
<p>以下 example 显示了相应的 bean 定义。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier value=&quot;main&quot;/&gt; (1)

        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier value=&quot;action&quot;/&gt; (2)

        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>具有<code>main</code>限定符 value 的 bean 与使用相同 value 限定的构造函数参数连接。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>具有<code>action</code>限定符 value 的 bean 与使用相同 value 限定的构造函数参数连接。</td>
</tr>
</tbody></table>
<p>对于后备 match， bean name 被视为默认限定符 value。因此，您可以使用<code>id</code> 而不是嵌套的限定符元素定义 bean，从而得到相同的匹配结果。但是，尽管您可以使用此约定通过 name 引用特定的 beans，<code>@Autowired</code>基本上是关于带有可选语义限定符的 type-driven 注入。这意味着限定符值(即使使用 bean name 回退)在类型匹配集中始终具有缩小语义。它们在语义上不表达对唯一 bean <code>id</code>的 reference。良好的限定符值是<code>main</code>或<code>EMEA</code>或<code>persistent</code>，表示独立于 bean <code>id</code>的特定 component 的特征，如果是匿名 bean 定义(例如前面的 example 中的定义)，则可能是 auto-generated。</p>
<p>限定符也适用于类型集合，如前所述 - 例如，<code>Set&lt;MovieCatalog&gt;</code>。在这种情况下，根据声明的限定符，所有匹配的 beans 都作为集合注入。这意味着限定符不必是唯一的。相反，它们构成了过滤标准。对于 example，您可以使用相同的限定符 value“action”定义多个<code>MovieCatalog</code> beans，所有这些都被注入<code>Set&lt;MovieCatalog&gt;</code>注释<code>@Qualifier(&quot;action&quot;)</code>。</p>
<blockquote>
<p>允许在 type-matching 候选者中针对目标 bean 名称选择限定符值_，在注入点不需要<code>@Qualifier</code> annotation。如果没有其他解析指示符(例如限定符或主要标记)，则对于 non-unique 依赖情况，Spring 将注入点 name(即字段 name 或参数 name)与目标 bean 名称匹配，然后选择 same-named 候选人，如果有的话。</p>
</blockquote>
<p>也就是说，如果你打算用 name 表达 annotation-driven 注入，不要主要使用<code>@Autowired</code>，即使它能够在 type-matching 候选者中通过 bean name 进行选择。相反，使用 JSR-250 <code>@Resource</code> annotation，它在语义上定义为通过其唯一的 name 标识特定的目标 component，声明的类型与匹配的 process 无关。 <code>@Autowired</code>具有相当不同的语义：在按类型选择候选 beans 之后，仅在那些 type-selected 候选内考虑指定的<code>String</code>限定符 value(对于 example，将<code>account</code>限定符与标记有相同限定符标签的 beans 匹配)。</p>
<p>对于本身被定义为集合，<code>Map</code>或 array 类型的 beans，<code>@Resource</code>是一个很好的解决方案，引用特定集合或 array bean 由 unique name。也就是说，从 4.3，集合开始，你可以通过 Spring 的<code>@Autowired</code>类型匹配算法 match <code>Map</code>和 array 类型，因为 long _类型信息被保存在<code>@Bean</code> return 类型签名或集合继承层次结构中。在这种情况下，您可以使用限定符值在 same-typed 集合中进行选择，如上一段所述。</p>
<p>从 4.3 开始，<code>@Autowired</code>也会考虑自我 reference 进行注入(即，references 返回到当前注入的 bean)。请注意，自我注入是一种后备。对其他组件的常规依赖性始终具有优先权。从这个意义上讲，自我引用并不参与常规的候选人选择，因此尤其不是主要的。相反，它们总是最低优先级。在实践中，您应该仅使用 self references 作为最后的手段(例如，通过 bean 的 transactional 代理调用同一实例上的其他方法)。考虑在这种情况下将受影响的方法分解为单独的委托 bean。或者，您可以使用<code>@Resource</code>，它可以通过其唯一的 name 获取代理回到当前 bean。</p>
<p><code>@Autowired</code>适用于字段，构造函数和 multi-argument 方法，允许通过参数 level 中的限定符注释缩小范围。相比之下，<code>@Resource</code>仅支持字段，bean property setter 方法只支持一个参数。因此，如果注射目标是构造函数或 multi-argument 方法，则应该使用限定符。</p>
<p>您可以创建自己的自定义限定符注释。为此，请定义 annotation 并在定义中提供<code>@Qualifier</code> annotation，如下面的 example 所示：</p>
<pre><code>@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre &#123;

    String value();
&#125;
</code></pre>
<p>然后，您可以在自动装配的字段和参数上提供自定义限定符，如下面的 example 所示：</p>
<pre><code>public class MovieRecommender &#123;

    @Autowired
    @Genre(&quot;Action&quot;)
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre(&quot;Comedy&quot;) MovieCatalog comedyCatalog) &#123;
        this.comedyCatalog = comedyCatalog;
    &#125;

    // ...
&#125;
</code></pre>
<p>接下来，您可以提供候选 bean 定义的信息。您可以将<code>&lt;qualifier/&gt;</code>标记添加为<code>&lt;bean/&gt;</code>标记的 sub-elements，然后将<code>type</code>和<code>value</code>指定为匹配您的自定义限定符注释。该类型与 annotation 的 fully-qualified class name 匹配。或者，为方便起见，如果不存在冲突名称的风险，可以使用 short class name。以下示例演示了两种方法：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;Genre&quot; value=&quot;Action&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;example.Genre&quot; value=&quot;Comedy&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-standard-annotations">Classpath 扫描和托管组件</a>中，您可以看到以 XML 格式提供限定符元数据的 annotation-based 替代方法。具体来说，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-classpath-scanning">使用 Annotations 提供限定符元数据</a>。</p>
<p>在某些情况下，使用没有 value 的 annotation 可能就足够了。当 annotation 用于更通用的目的并且可以跨多种不同类型的依赖项应用时，这可能很有用。例如，您可以提供可在没有 Internet 连接时搜索的脱机目录。首先，定义简单的 annotation，如下面的 example 所示：</p>
<pre><code>@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline &#123;

&#125;
</code></pre>
<p>然后将 annotation 添加到字段或 property 以进行自动装配，如以下 example 所示：</p>
<pre><code>public class MovieRecommender &#123;

    @Autowired
    @Offline (1)
    private MovieCatalog offlineCatalog;

    // ...
&#125;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>此 line 添加<code>@Offline</code> annotation。</td>
</tr>
</tbody></table>
<p>现在 bean 定义只需要一个限定符<code>type</code>，如下面的 example 所示：</p>
<pre><code>&lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
    &lt;qualifier type=&quot;Offline&quot;/&gt; (1)
    &lt;!-- inject any dependencies required by this bean --&gt;
&lt;/bean&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>此元素指定限定符。</td>
</tr>
</tbody></table>
<p>除了简单的<code>value</code>属性之外或者代替简单的<code>value</code>属性，您还可以定义接受命名属性的自定义限定符注释。如果随后在要自动装配的字段或参数上指定了多个属性值，则 bean 定义必须_匹配所有此类属性值才能被视为自动装配候选。作为示例，请考虑以下 annotation 定义：</p>
<pre><code>@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier &#123;

    String genre();

    Format format();
&#125;
</code></pre>
<p>在这种情况下，<code>Format</code>是 enum，定义如下：</p>
<pre><code>public enum Format &#123;
    VHS, DVD, BLURAY
&#125;
</code></pre>
<p>要自动装配的字段使用自定义限定符进行批注，并包含两个属性的值：<code>genre</code>和<code>format</code>，如下面的 example 所示：</p>
<pre><code>public class MovieRecommender &#123;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)
    private MovieCatalog comedyBluRayCatalog;

    // ...
&#125;
</code></pre>
<p>最后，bean 定义应包含匹配的限定符值。此 example 还演示了您可以使用 bean 元属性而不是<code>&lt;qualifier/&gt;</code>元素。如果可用，<code>&lt;qualifier/&gt;</code>元素及其属性优先，但如果没有这样的限定符，则自动装配机制将回退到<code>&lt;meta/&gt;</code>标记内提供的值，如下面 example 中的最后两个 bean 定义：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;
            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;
            &lt;attribute key=&quot;genre&quot; value=&quot;Action&quot;/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;
            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;
            &lt;attribute key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;meta key=&quot;format&quot; value=&quot;DVD&quot;/&gt;
        &lt;meta key=&quot;genre&quot; value=&quot;Action&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;meta key=&quot;format&quot; value=&quot;BLURAY&quot;/&gt;
        &lt;meta key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h4 id="1-9-5-使用泛型作为自动装配限定符"><a href="#1-9-5-使用泛型作为自动装配限定符" class="headerlink" title="1.9.5. 使用泛型作为自动装配限定符"></a>1.9.5. 使用泛型作为自动装配限定符</h4><p>除了<code>@Qualifier</code> annotation 之外，您还可以使用 Java 泛型类型作为隐式的限定形式。例如，假设您有以下 configuration：</p>
<pre><code>@Configuration
public class MyConfiguration &#123;

    @Bean
    public StringStore stringStore() &#123;
        return new StringStore();
    &#125;

    @Bean
    public IntegerStore integerStore() &#123;
        return new IntegerStore();
    &#125;
&#125;
</code></pre>
<p>假设前面的 beans 实现了一个通用接口(即<code>Store&lt;String&gt;</code>和<code>Store&lt;Integer&gt;</code>)，你可以<code>@Autowire</code> <code>Store</code>接口，泛型用作限定符，如下面的 example 所示：</p>
<pre><code>@Autowired
private Store&lt;String&gt; s1; // &lt;String&gt; qualifier, injects the stringStore bean

@Autowired
private Store&lt;Integer&gt; s2; // &lt;Integer&gt; qualifier, injects the integerStore bean
</code></pre>
<p>通用限定符也适用于自动装配 lists，<code>Map</code>实例和数组。以下 example 自动装配通用<code>List</code>：</p>
<pre><code>// Inject all Store beans as long as they have an &lt;Integer&gt; generic
// Store&lt;String&gt; beans will not appear in this list
@Autowired
private List&lt;Store&lt;Integer&gt;&gt; s;
</code></pre>
<h4 id="1-9-6-使用-CustomAutowireConfigurer"><a href="#1-9-6-使用-CustomAutowireConfigurer" class="headerlink" title="1.9.6. 使用 CustomAutowireConfigurer"></a>1.9.6. 使用 CustomAutowireConfigurer</h4><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html">CustomAutowireConfigurer 上</a>是一个<code>BeanFactoryPostProcessor</code>，它允许您注册自己的自定义限定符注释类型，即使它们没有使用 Spring 的<code>@Qualifier</code> annotation 注释。以下 example 显示了如何使用<code>CustomAutowireConfigurer</code>：</p>
<pre><code>&lt;bean id=&quot;customAutowireConfigurer&quot;
        class=&quot;org.springframework.beans.factory.annotation.CustomAutowireConfigurer&quot;&gt;
    &lt;property name=&quot;customQualifierTypes&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;example.CustomQualifier&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><code>AutowireCandidateResolver</code>通过以下方式确定 autowire 候选人：</p>
<ul>
<li>每个 bean 定义的<code>autowire-candidate</code> value</li>
<li><code>&lt;beans/&gt;</code>元素上可用的任何<code>default-autowire-candidates</code>模式</li>
<li><code>@Qualifier</code> 注释的存在以及使用<code>CustomAutowireConfigurer</code>注册的任何自定义注释</li>
</ul>
<p>当多个 beans 有资格作为 autowire 候选者时，“primary”的确定如下：如果候选者中只有一个 bean 定义将<code>primary</code>属性设置为<code>true</code>，则选择它。</p>
<h4 id="1-9-7-注射-Resource"><a href="#1-9-7-注射-Resource" class="headerlink" title="1.9.7. 注射 @Resource"></a>1.9.7. 注射 @Resource</h4><p>Spring 还支持使用字段上的 JSR-250 <code>@Resource</code> annotation 或 bean property setter 方法进行注入。这是 Java EE 5 和 6 中的 common pattern(例如，在 JSF 1.2 managed beans 或 JAX-WS 2.0 endpoints 中)。 Spring 也为 Spring-managed objects 支持此 pattern。</p>
<p><code>@Resource</code>采用 name 属性。默认情况下，Spring 将 value 解释为要注入的 bean name。换句话说，它遵循 by-name 语义，如下面的示例所示：</p>
<pre><code>public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Resource(name=&quot;myMovieFinder&quot;) (1)
    public void setMovieFinder(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>这个 line 注入一个<code>@Resource</code>。</td>
</tr>
</tbody></table>
<p>如果未显式指定 name，则默认 name 派生自字段 name 或 setter 方法。如果是字段，则需要字段 name。在 setter 方法的情况下，它采用 bean property name。以下 example 将 bean 命名为<code>movieFinder</code>注入其 setter 方法：</p>
<pre><code>public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Resource
    public void setMovieFinder(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>_an 注释提供的 name 被<code>CommonAnnotationBeanPostProcessor</code>解析为如果您明确配置 Spring 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html">SimpleJndiBeanFactory</a>，则可以通过 JNDI 解析名称。但是，我们建议您依赖默认行为并使用 Spring 的 JNDI 查找功能来保留间接的 level。</p>
</blockquote>
<p>在<code>@Resource</code>用法的唯一情况下，没有指定明确的 name，并且类似于<code>@Autowired</code>，<code>@Resource</code>找到主要类型 match 而不是特定的名为 bean，并解析众所周知的可解析依赖项：<code>BeanFactory</code>，<code>ApplicationContext</code>，<code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>和<code>MessageSource</code>接口。</p>
<p>因此，在下面的示例中，<code>customerPreferenceDao</code>字段首先查找名为 customerPreferenceDao 的 bean，然后返回类型为<code>CustomerPreferenceDao</code>的主类型 match：</p>
<pre><code>public class MovieRecommender &#123;

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context; (1)

    public MovieRecommender() &#123;
    &#125;

    // ...
&#125;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>根据已知的可解析依赖类型注入<code>context</code>字段：<code>ApplicationContext</code>。</td>
</tr>
</tbody></table>
<h4 id="1-9-8-使用-PostConstruct-和-PreDestroy"><a href="#1-9-8-使用-PostConstruct-和-PreDestroy" class="headerlink" title="1.9.8. 使用 @PostConstruct 和 @PreDestroy"></a>1.9.8. 使用 @PostConstruct 和 @PreDestroy</h4><p><code>CommonAnnotationBeanPostProcessor</code>不仅识别<code>@Resource</code> annotation，还识别 JSR-250 生命周期注释。在 Spring 2.5 中引入，对这些注释的支持提供了<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-scanning-qualifiers">初始化回调</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">破坏回调</a>中描述的另一种替代方法。如果在 Spring <code>ApplicationContext</code>中注册，则在生命周期的同一点调用带有其中一个注释的方法，作为相应的 Spring 生命周期接口方法或显式声明的回调方法。在下面的示例中，缓存在初始化时为 pre-populated，在销毁时清除：</p>
<pre><code>public class CachingMovieLister &#123;

    @PostConstruct
    public void populateMovieCache() &#123;
        // populates the movie cache upon initialization...
    &#125;

    @PreDestroy
    public void clearMovieCache() &#123;
        // clears the movie cache upon destruction...
    &#125;
&#125;
</code></pre>
<blockquote>
<p>有关组合各种生命周期机制的效果的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean">结合生命周期机制</a>。</p>
</blockquote>
<h3 id="1-10-Classpath-扫描和托管组件"><a href="#1-10-Classpath-扫描和托管组件" class="headerlink" title="1.10. Classpath 扫描和托管组件"></a>1.10. Classpath 扫描和托管组件</h3><p>本章中的大多数示例都使用 XML 来指定_Spiguration 元数据，该元数据在 Spring 容器中生成每个<code>BeanDefinition</code>。上一节(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-combined-effects">Annotation-based Container Configuration</a>)演示了如何通过 source-level annotations 提供大量 configuration 元数据。但是，即使在这些示例中，“base”bean 定义也在 XML 文件中明确定义，而 annotations 仅驱动依赖项注入。本节介绍通过扫描 classpath 隐式检测候选组件的选项。候选组件是 classes，它们与过滤条件匹配，并且在容器中注册了相应的 bean 定义。这消除了使用 XML 执行 bean 注册的需要。相反，您可以使用 annotations(用于 example，<code>@Component</code>)，AspectJ 类型表达式或您自己的自定义过滤条件来选择哪些 classes 具有向容器注册的 bean 定义。</p>
<blockquote>
<p>从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多 features 都是核心 Spring Framework 的一部分。这允许您使用 Java 定义 beans 而不是使用传统的 XML files。有关如何使用这些新 features 的示例，请查看<code>@Configuration</code>，<code>@Bean</code>，<code>@Import</code>和<code>@DependsOn</code> 注释。</p>
</blockquote>
<h4 id="1-10-1-Component-和进一步的刻板印象注释"><a href="#1-10-1-Component-和进一步的刻板印象注释" class="headerlink" title="1.10.1. @Component 和进一步的刻板印象注释"></a>1.10.1. @Component 和进一步的刻板印象注释</h4><p><code>@Repository</code> annotation 是任何 class 的标记，它满足 repository(也称为 Data Access Object 或 DAO)的角色或构造型。该标记的用途之一是 exceptions 的自动转换，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#beans-annotation-config">Exception 翻译</a>中所述。</p>
<p>Spring 提供了进一步的构造型注释：<code>@Component</code>，<code>@Service</code>和<code>@Controller</code>。 <code>@Component</code>是任何 Spring-managed component 的通用构造型。 <code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>是<code>@Component</code>的特化，用于更具体的用例(分别在持久性，服务和表示层中)。因此，您可以使用<code>@Component</code>注释 component classes，但是，通过使用<code>@Repository</code>，<code>@Service</code>或<code>@Controller</code>注释它们，您的 classes 更适合通过工具处理或与方面相关联。例如，这些构造型注释成为切入点的理想目标。 <code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>还可以在 Spring Framework 的未来版本中携带其他语义。因此，如果您在服务层使用<code>@Component</code>或<code>@Service</code>之间进行选择，<code>@Service</code>显然是更好的选择。同样，如前所述，已经支持<code>@Repository</code>作为持久层中自动 exception 转换的标记。</p>
<h4 id="1-10-2-使用-Meta-annotations-和-Composed-Annotations"><a href="#1-10-2-使用-Meta-annotations-和-Composed-Annotations" class="headerlink" title="1.10.2. 使用 Meta-annotations 和 Composed Annotations"></a>1.10.2. 使用 Meta-annotations 和 Composed Annotations</h4><p>Spring 提供的许多注释可以在您自己的 code 中用作 meta-annotations。 meta-annotation 是一个 annotation，可以应用于另一个 annotation。对于 example，提到的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#orm-exception-translation">前</a> annotation <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-stereotype-annotations">前</a>是 meta-annotated 和<code>@Component</code>，如下面的 example 所示：</p>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component (1)
public @interface Service &#123;

    // ....
&#125;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>Component</code>导致<code>@Service</code>以与<code>@Component</code>相同的方式处理。</td>
</tr>
</tbody></table>
<p>您还可以组合 meta-annotations 来创建“撰写注释”。例如，Spring MVC 的<code>@RestController</code> annotation 由<code>@Controller</code>和<code>@ResponseBody</code>组成。</p>
<p>此外，组合的 annotations 可以选择从 meta-annotations 重新声明属性以允许自定义。当您只想公开 meta-annotation 属性的子集时，这可能特别有用。对于 example，Spring 的<code>@SessionScope</code> annotation 将范围 name 硬编码为<code>session</code>，但仍允许自定义<code>proxyMode</code>。以下清单显示了<code>SessionScope</code> annotation 的定义：</p>
<pre><code>@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope &#123;

    /**
     * Alias for &#123;@link Scope#proxyMode&#125;.
     * &lt;p&gt;Defaults to &#123;@link ScopedProxyMode#TARGET_CLASS&#125;.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

&#125;
</code></pre>
<p>然后，您可以使用<code>@SessionScope</code>而不声明<code>proxyMode</code>，如下所示：</p>
<pre><code>@Service
@SessionScope
public class SessionScopedService &#123;
    // ...
&#125;
</code></pre>
<p>您还可以覆盖<code>proxyMode</code>的 value，如下面的 example 所示：</p>
<pre><code>@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
public class SessionScopedUserService implements UserService &#123;
    // ...
&#125;
</code></pre>
<p>有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a> wiki 页面。</p>
<h4 id="1-10-3-自动检测-Classes-并注册-Bean-定义"><a href="#1-10-3-自动检测-Classes-并注册-Bean-定义" class="headerlink" title="1.10.3. 自动检测 Classes 并注册 Bean 定义"></a>1.10.3. 自动检测 Classes 并注册 Bean 定义</h4><p>Spring 可以自动检测原型 classes 并使用<code>ApplicationContext</code>注册相应的<code>BeanDefinition</code>实例。对于 example，以下两个 classes 符合此类自动检测的条件：</p>
<pre><code>@Service
public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Autowired
    public SimpleMovieLister(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;
&#125;
</code></pre>
<pre><code>@Repository
public class JpaMovieFinder implements MovieFinder &#123;
    // implementation elided for clarity
&#125;
</code></pre>
<p>要自动检测这些 classes 并注册相应的 beans，您需要将<code>@ComponentScan</code>添加到<code>@Configuration</code> class，其中<code>basePackages</code>属性是两个 classes 的 common parent 包。 (或者，您可以指定包含每个 class.)的 parent 包的逗号或分号或 space-separated 列表</p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;)
public class AppConfig  &#123;
    ...
&#125;
</code></pre>
<blockquote>
<p>为简洁起见，前面的 example 可能使用了 annotation 的<code>value</code>属性(即<code>@ComponentScan(&quot;org.example&quot;)</code>)。</p>
</blockquote>
<p>以下替代方法使用 XML：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;org.example&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<blockquote>
<p>使用<code>&lt;context:component-scan&gt;</code>隐式启用<code>&lt;context:annotation-config&gt;</code>的功能。使用<code>&lt;context:component-scan&gt;</code>时通常不需要包含<code>&lt;context:annotation-config&gt;</code>元素。</p>
</blockquote>
<blockquote>
<p>扫描 classpath 包需要在 classpath 中存在相应的目录条目。使用 Ant build JAR 时，请确保不要激活 JAR 任务的 files-only 开关。此外，在某些环境中，classpath 目录可能不会基于安全 policies 公开 - 例如，JDK 1.7.0_45 及更高版本上的独立应用程序(在清单中需要’Trusted-Library’设置 - 请参阅<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>)。</p>
</blockquote>
<p>在 JDK 9 的模块路径(Jigsaw)上，Spring 的 classpath 扫描通常按预期工作。但是，请确保在<code>module-info</code>描述符中导出 component classes。如果您希望 Spring 调用 classes 的 non-public 成员，请确保它们已被“打开”(即，它们在<code>module-info</code>描述符中使用<code>opens</code>声明而不是<code>exports</code>声明)。</p>
<p>此外，使用 component-scan 元素时，隐式包含<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>。这意味着这两个组件是自动检测并连接在一起的 - 所有这些都没有在 XML 中提供任何 bean configuration 元数据。</p>
<blockquote>
<p>您可以通过将属性与<code>false</code>的_val包含在一起来禁用<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>的注册。</p>
</blockquote>
<h4 id="1-10-4-使用过滤器自定义扫描"><a href="#1-10-4-使用过滤器自定义扫描" class="headerlink" title="1.10.4. 使用过滤器自定义扫描"></a>1.10.4. 使用过滤器自定义扫描</h4><p>默认情况下，使用<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>注释的 classes 或使用<code>@Component</code>注释的自定义注释是唯一检测到的候选组件。但是，您可以通过应用自定义筛选器来修改和扩展此行为。将它们添加为<code>@ComponentScan</code> annotation 的<code>includeFilters</code>或<code>excludeFilters</code>参数(或<code>component-scan</code>元素的<code>include-filter</code>或<code>exclude-filter</code> child 元素)。每个滤镜元素都需要<code>type</code>和<code>expression</code>属性。以下 table 描述了过滤选项：</p>
<table>
<thead>
<tr>
<th>过滤器类型</th>
<th>Example 表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>annotation(默认)</td>
<td><code>org.example.SomeAnnotation</code></td>
<td>目标组件中 level 类型的注释。</td>
</tr>
<tr>
<td>分配</td>
<td><code>org.example.SomeClass</code></td>
<td>目标组件可分配给(扩展或实现)的 class(或接口)。</td>
</tr>
<tr>
<td>AspectJ</td>
<td><code>org.example..*Service+</code></td>
<td>要由目标组件匹配的 AspectJ 类型表达式。</td>
</tr>
<tr>
<td>正则表达式</td>
<td><code>org\.example\.Default.*</code></td>
<td>要由目标组件 class 名称匹配的正则表达式。</td>
</tr>
<tr>
<td>习惯</td>
<td><code>org.example.MyTypeFilter</code></td>
<td><code>org.springframework.core.type .TypeFilter</code>接口的自定义 implementation。</td>
</tr>
</tbody></table>
<p>以下 example 显示 configuration 忽略所有<code>@Repository</code> 注释并使用“stub”repositories：</p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;,
        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),
        excludeFilters = @Filter(Repository.class))
public class AppConfig &#123;
    ...
&#125;
</code></pre>
<p>以下清单显示了等效的 XML：</p>
<pre><code>&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;&gt;
        &lt;context:include-filter type=&quot;regex&quot;
                expression=&quot;.*Stub.*Repository&quot;/&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot;
                expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
    &lt;/context:component-scan&gt;
&lt;/beans&gt;
</code></pre>
<blockquote>
<p>您还可以通过在 annotation 上设置<code>useDefaultFilters=false</code>或通过提供<code>use-default-filters=&quot;false&quot;</code>作为<code>&lt;component-scan/&gt;</code>元素的属性来禁用默认过滤器。实际上，这会禁用自动检测<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>或<code>@Configuration</code>注释的 classes。</p>
</blockquote>
<h4 id="1-10-5-在组件中定义-Bean-元数据"><a href="#1-10-5-在组件中定义-Bean-元数据" class="headerlink" title="1.10.5. 在组件中定义 Bean 元数据"></a>1.10.5. 在组件中定义 Bean 元数据</h4><p>Spring 组件还可以将 bean 定义元数据提供给容器。您可以使用用于在<code>@Configuration</code> annotated classes 中定义 bean 元数据的相同<code>@Bean</code> annotation 来执行此操作。以下 example 显示了如何执行此操作：</p>
<pre><code>@Component
public class FactoryMethodComponent &#123;

    @Bean
    @Qualifier(&quot;public&quot;)
    public TestBean publicInstance() &#123;
        return new TestBean(&quot;publicInstance&quot;);
    &#125;

    public void doWork() &#123;
        // Component method implementation omitted
    &#125;
&#125;
</code></pre>
<p>前面的 class 是 Spring component，在<code>doWork()</code>方法中有 application-specific code。但是，它还提供 bean 定义，其具有引用方法<code>publicInstance()</code>的工厂方法。 <code>@Bean</code> annotation 标识工厂方法和其他 bean 定义 properties，例如通过<code>@Qualifier</code> annotation 的限定符 value。可以指定的其他 method-level 注释是<code>@Scope</code>，<code>@Lazy</code>和自定义限定符注释。</p>
<blockquote>
<p>除了 component 初始化的作用外，您还可以将<code>@Lazy</code> annotation 放在标有<code>@Autowired</code>或<code>@Inject</code>的注入点上。在此 context 中，它会导致注入 lazy-resolution 代理。</p>
</blockquote>
<p>如前所述，支持自动装配的字段和方法，并支持自动装配<code>@Bean</code>方法。以下 example 显示了如何执行此操作：</p>
<pre><code>@Component
public class FactoryMethodComponent &#123;

    private static int i;

    @Bean
    @Qualifier(&quot;public&quot;)
    public TestBean publicInstance() &#123;
        return new TestBean(&quot;publicInstance&quot;);
    &#125;

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier(&quot;public&quot;) TestBean spouse,
            @Value(&quot;#&#123;privateInstance.age&#125;&quot;) String country) &#123;
        TestBean tb = new TestBean(&quot;protectedInstance&quot;, 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    &#125;

    @Bean
    private TestBean privateInstance() &#123;
        return new TestBean(&quot;privateInstance&quot;, i++);
    &#125;

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() &#123;
        return new TestBean(&quot;requestScopedInstance&quot;, 3);
    &#125;
&#125;
</code></pre>
<p>example 将<code>String</code>方法参数<code>country</code>自动装配到另一个名为<code>privateInstance</code>的 bean 上<code>age</code> property 的 value。 Spring Expression Language 元素通过符号<code>#&#123; &lt;expression&gt; &#125;</code>定义 property 的 value。对于<code>@Value</code> annotations，表达式解析器预先配置为在解析表达式文本时查找 bean 名称。</p>
<p>从 Spring Framework 4.3 开始，您还可以声明类型<code>InjectionPoint</code>(或其更具体的子类：<code>DependencyDescriptor</code>)的工厂方法参数，以访问触发创建当前 bean 的请求注入点。请注意，这仅适用于 bean 实例的实际创建，而不适用于现有实例的注入。因此，这种 feature 对原型范围的 beans 最有意义。对于其他作用域，工厂方法只能看到触发在给定作用域中创建新 bean 实例的注入点(对于 example，触发创建惰性 singleton bean 的依赖项)。在这种情况下，您可以使用提供的注入点元数据和语义关注。以下 example 显示了如何使用<code>InjectionPoint</code>：</p>
<pre><code>@Component
public class FactoryMethodComponent &#123;

    @Bean @Scope(&quot;prototype&quot;)
    public TestBean prototypeInstance(InjectionPoint injectionPoint) &#123;
        return new TestBean(&quot;prototypeInstance for &quot; + injectionPoint.getMember());
    &#125;
&#125;
</code></pre>
<p>常规 Spring component 中的<code>@Bean</code>方法的处理方式与 Spring <code>@Configuration</code> class 中的对应方式不同。不同之处在于，CGLIB 不会增强<code>@Component</code> classes 以拦截方法和字段的调用。 CGLIB 代理是调用<code>@Configuration</code> classes 中<code>@Bean</code>方法中的方法或字段创建 bean metadata references 以协作 objects 的方法。这些方法不是用普通的 Java 语义调用的，而是通过 order 中的容器来提供 Spring beans 的常规生命周期管理和代理，即使在通过程序 calls 到<code>@Bean</code>方法引用其他 beans 时也是如此。相反，在普通<code>@Component</code> class 中调用<code>@Bean</code>方法中的方法或字段具有标准 Java 语义，没有应用特殊的 CGLIB 处理或其他约束。</p>
<blockquote>
<p>您可以将<code>@Bean</code>方法声明为<code>static</code>，允许在不包含_conating 包含 configuration class 作为实例的情况下调用它们。这在定义 post-processor beans(对于 example，类型<code>BeanFactoryPostProcessor</code>或<code>BeanPostProcessor</code>)时特别有意义，因为这样的 beans 在容器生命周期的早期初始化，并且应避免在此时触发 configuration 的其他部分。</p>
</blockquote>
<p>Calls 到静态<code>@Bean</code>方法永远不会被容器截获，甚至在<code>@Configuration</code> classes 中也没有(如本节前面所述)，由于技术限制：CGLIB 子类化只能覆盖 non-static 方法。因此，直接调用另一个<code>@Bean</code>方法具有标准的 Java 语义，从而导致直接从工厂方法本身返回一个独立的实例。</p>
<p><code>@Bean</code>方法的 Java 语言可见性对 Spring 容器中生成的 bean 定义没有立即影响。您可以根据需要在非<code>@Configuration</code> classes 和任何地方的静态方法中自由声明工厂方法。但是，<code>@Configuration</code> classes 中的常规<code>@Bean</code>方法需要可覆盖 - 也就是说，它们不能声明为<code>private</code>或<code>final</code>。</p>
<p><code>@Bean</code>方法也可以在给定 component 或 configuration class 的 base classes 上发现，也可以在 component 或 configuration class 实现的接口中声明的 Java 8 默认方法上发现。这使得在编写复杂的配置安排时具有很大的灵活性，甚至可以通过 Spring 4.2 的 Java 8 默认方法实现多重继承。</p>
<p>最后，单个 class 可以为同一个 bean 保存多个<code>@Bean</code>方法，作为根据运行时可用依赖项使用的多个工厂方法的排列。这与在其他 configuration 场景中选择“最贪婪”构造函数或工厂方法的算法相同：在构造 time 中选择具有最多可满足依赖项的变体，类似于容器在多个<code>@Autowired</code>构造函数之间进行选择的方式。</p>
<h4 id="1-10-6-命名自动检测的组件"><a href="#1-10-6-命名自动检测的组件" class="headerlink" title="1.10.6. 命名自动检测的组件"></a>1.10.6. 命名自动检测的组件</h4><p>当 component 作为 scan process 的一部分自动检测时，其 bean name 由该扫描程序已知的<code>BeanNameGenerator</code>策略生成。默认情况下，任何包含 name <code>value</code>的 Spring 构造型 annotation(<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>)都会将 name 提供给相应的 bean 定义。</p>
<p>如果这样的 annotation 不包含 name <code>value</code>或任何其他检测到的 component(例如自定义过滤器发现的那些)，则默认的 bean name generator 将返回未大写的 non-qualified class name。对于 example，如果检测到以下 component classes，则名称将为<code>myMovieLister</code>和<code>movieFinderImpl</code>：</p>
<pre><code>@Service(&quot;myMovieLister&quot;)
public class SimpleMovieLister &#123;
    // ...
&#125;
</code></pre>
<pre><code>@Repository
public class MovieFinderImpl implements MovieFinder &#123;
    // ...
&#125;
</code></pre>
<blockquote>
<p>如果您不想依赖默认的 bean-naming 策略，则可以提供自定义 bean-naming 策略。首先，实现<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html">BeanNameGenerator</a>接口，并确保包含默认的 no-arg 构造函数。然后，在配置扫描程序时提供完全限定的 class name，如下面的 example annotation 和 bean 定义所示：</p>
</blockquote>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)
public class AppConfig &#123;
    ...
&#125;
</code></pre>
<pre><code>&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;
        name-generator=&quot;org.example.MyNameGenerator&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>作为一般规则，考虑使用 annotation 指定 name，只要其他组件可以对其进行显式 references。另一方面，只要容器负责接线，auto-generated 名称就足够了。</p>
<h4 id="1-10-7-为自动检测组件提供范围"><a href="#1-10-7-为自动检测组件提供范围" class="headerlink" title="1.10.7. 为自动检测组件提供范围"></a>1.10.7. 为自动检测组件提供范围</h4><p>与 Spring-managed 组件一样，自动检测组件的默认范围和最常见范围是<code>singleton</code>。但是，有时您需要一个可由<code>@Scope</code> annotation 指定的不同范围。您可以在 annotation 中提供范围的 name，如下面的 example 所示：</p>
<pre><code>@Scope(&quot;prototype&quot;)
@Repository
public class MovieFinderImpl implements MovieFinder &#123;
    // ...
&#125;
</code></pre>
<blockquote>
<p><code>@Scope</code> annotations 仅在具体的 bean class(对于带注释的组件)或工厂方法(对于<code>@Bean</code>方法)上进行了内省。与 XML bean 定义相比，没有 bean 定义继承的概念，class level 中的继承层次结构与元数据目的无关。</p>
</blockquote>
<p>有关 web-specific 范围的详细信息，例如 Spring context 中的“request”或“session”，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other">Request，Session，Application 和 WebSocket Scopes</a>。与这些范围的 pre-built 注释一样，您也可以使用 Spring 的 meta-annotation 方法编写自己的作用域注释：对于 example，自定义注释 meta-annotated 使用<code>@Scope(&quot;prototype&quot;)</code>，可能还会声明自定义 scoped-proxy 模式。</p>
<blockquote>
<p>要为范围解析提供自定义策略而不是依赖于 annotation-based 方法，可以实现<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html">ScopeMetadataResolver</a>接口。一定要包含默认的 no-arg 构造函数。然后，您可以在配置扫描程序时提供完全限定的 class name，因为 annotation 和 bean 定义的以下示例显示：</p>
</blockquote>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, scopeResolver = MyScopeResolver.class)
public class AppConfig &#123;
    ...
&#125;
</code></pre>
<pre><code>&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot; scope-resolver=&quot;org.example.MyScopeResolver&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>使用某些 non-singleton 范围时，可能需要为范围的 objects 生成代理。推理在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">将 Beans 视为依赖关系</a>中描述。为此，component-scan 元素上有 scoped-proxy 属性。三个可能的值是：<code>no</code>，<code>interfaces</code>和<code>targetClass</code>。对于 example，以下 configuration 会生成标准 JDK 动态代理：</p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig &#123;
    ...
&#125;
</code></pre>
<pre><code>&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot; scoped-proxy=&quot;interfaces&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="1-10-8-使用-Annotations-提供限定符元数据"><a href="#1-10-8-使用-Annotations-提供限定符元数据" class="headerlink" title="1.10.8. 使用 Annotations 提供限定符元数据"></a>1.10.8. 使用 Annotations 提供限定符元数据</h4><p><code>@Qualifier</code> annotation 在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-autowired-annotation-qualifiers">Fine-tuning Annotation-based 使用限定符自动装配</a>中讨论。该部分中的示例演示了在解析自动线候选时使用<code>@Qualifier</code> annotation 和自定义限定符注释来提供 fine-grained 控件。因为这些示例基于 XML bean 定义，所以通过使用 XML 中<code>bean</code>元素的<code>qualifier</code>或<code>meta</code> child 元素，在候选 bean 定义上提供了限定符元数据。当依赖 classpath 扫描 auto-detection 组件时，可以在候选 class 上为 type-level 注释提供限定符元数据。以下三个示例演示了此技术：</p>
<pre><code>@Component
@Qualifier(&quot;Action&quot;)
public class ActionMovieCatalog implements MovieCatalog &#123;
    // ...
&#125;
</code></pre>
<pre><code>@Component
@Genre(&quot;Action&quot;)
public class ActionMovieCatalog implements MovieCatalog &#123;
    // ...
&#125;
</code></pre>
<pre><code>@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog &#123;
    // ...
&#125;
</code></pre>
<blockquote>
<p>与大多数 annotation-based 替代方案一样，请记住 annotation 元数据绑定到 class 定义本身，而使用 XML 允许多个相同类型的 beans 提供其限定符元数据的变体，因为提供的元数据是 per-instance 而不是 per-class。</p>
</blockquote>
<h4 id="1-10-9-生成候选组件索引"><a href="#1-10-9-生成候选组件索引" class="headerlink" title="1.10.9. 生成候选组件索引"></a>1.10.9. 生成候选组件索引</h4><p>虽然 classpath 扫描非常快，但是可以通过在编译 time 时创建候选的静态列表来改进大应用程序的启动性能。在此模式下，application 的所有模块都必须使用此机制，因为当<code>ApplicationContext</code>检测到这样的索引时，它会自动使用它而不是扫描 classpath。</p>
<p>要生成索引，请为包含作为 component scan 指令目标的组件的每个模块添加其他依赖项。以下 example 显示了如何使用 Maven 执行此操作：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;
        &lt;version&gt;5.1.3.RELEASE&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>以下 example 显示了如何使用 Gradle 执行此操作：</p>
<pre><code>dependencies &#123;
    compileOnly(&quot;org.springframework:spring-context-indexer:5.1.3.RELEASE&quot;)
&#125;
</code></pre>
<p>该 process 生成一个包含在 jar 文件中的<code>META-INF/spring.components</code>文件。</p>
<blockquote>
<p>在 IDE 中使用此模式时，必须将<code>spring-context-indexer</code>注册为 annotation 处理器，以确保在更新候选组件时索引为 up-to-date。</p>
</blockquote>
<blockquote>
<p>在 classpath 上找到<code>META-INF/spring.components</code>时，将自动启用索引。如果索引部分可用于某些 libraries(或用例)但无法为整个 application 构建，则可以通过将<code>spring.index.ignore</code>设置为<code>true</code>来回退到常规 classpath 排列(就好像根本没有索引)系统 property 或 classpath 根目录下的<code>spring.properties</code>文件。</p>
</blockquote>
<h3 id="1-11-使用-JSR-330-Standard-Annotations"><a href="#1-11-使用-JSR-330-Standard-Annotations" class="headerlink" title="1.11. 使用 JSR 330 Standard Annotations"></a>1.11. 使用 JSR 330 Standard Annotations</h3><p>从 Spring 3.0 开始，Spring 支持 JSR-330 standard annotations(依赖注入)。这些注释的扫描方式与 Spring annotations 相同。要使用它们，您需要在 classpath 中包含相关的 jars。</p>
<blockquote>
<p>如果使用 Maven，则<code>javax.inject</code> artifact 在标准 Maven repository(<a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/javax/inject/javax.inject/1/">http://repo1.maven.org/maven2/javax/inject/javax.inject/1/</a>)中可用。您可以将以下依赖项添加到文件 pom.xml：</p>
</blockquote>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.inject&lt;/groupId&gt;
    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="1-11-1-使用-Inject-和-Named-进行依赖注入"><a href="#1-11-1-使用-Inject-和-Named-进行依赖注入" class="headerlink" title="1.11.1. 使用 @Inject 和 @Named 进行依赖注入"></a>1.11.1. 使用 @Inject 和 @Named 进行依赖注入</h4><p>而不是<code>@Autowired</code>，您可以使用<code>@javax.inject.Inject</code>，如下所示：</p>
<pre><code>import javax.inject.Inject;

public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    public void listMovies() &#123;
        this.movieFinder.findMovies(...);
        ...
    &#125;
&#125;
</code></pre>
<p>与<code>@Autowired</code>一样，您可以在字段 level，method level 和 constructor-argument level 中使用<code>@Inject</code>。此外，您可以将注入点声明为<code>Provider</code>，允许 on-demand 访问较短范围的 beans 或通过<code>Provider.get()</code>调用延迟访问其他 beans。以下 example 提供了前面的 example 的变体：</p>
<pre><code>import javax.inject.Inject;
import javax.inject.Provider;

public class SimpleMovieLister &#123;

    private Provider&lt;MovieFinder&gt; movieFinder;

    @Inject
    public void setMovieFinder(Provider&lt;MovieFinder&gt; movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    public void listMovies() &#123;
        this.movieFinder.get().findMovies(...);
        ...
    &#125;
&#125;
</code></pre>
<p>如果要对应注入的依赖项使用限定的 name，则应使用<code>@Named</code> annotation，如下面的 example 所示：</p>
<pre><code>import javax.inject.Inject;
import javax.inject.Named;

public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named(&quot;main&quot;) MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    // ...
&#125;
</code></pre>
<p>与<code>@Autowired</code>一样，<code>@Inject</code>也可以与<code>java.util.Optional</code>或<code>@Nullable</code>一起使用。这更适用于此，因为<code>@Inject</code>没有<code>required</code>属性。以下一对示例显示了如何使用<code>@Inject</code>和<code>@Nullable</code>：</p>
<pre><code>public class SimpleMovieLister &#123;

    @Inject
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) &#123;
        ...
    &#125;
&#125;
</code></pre>
<pre><code>public class SimpleMovieLister &#123;

    @Inject
    public void setMovieFinder(@Nullable MovieFinder movieFinder) &#123;
        ...
    &#125;
&#125;
</code></pre>
<h4 id="1-11-2-Named-和-ManagedBean：-Component-注释的标准等价物"><a href="#1-11-2-Named-和-ManagedBean：-Component-注释的标准等价物" class="headerlink" title="1.11.2. @Named 和@ManagedBean： @Component 注释的标准等价物"></a>1.11.2. @Named 和@ManagedBean： @Component 注释的标准等价物</h4><p>您可以使用<code>@javax.inject.Named</code>或<code>javax.annotation.ManagedBean</code>代替<code>@Component</code>，如下面的 example 所示：</p>
<pre><code>import javax.inject.Inject;
import javax.inject.Named;

@Named(&quot;movieListener&quot;)  // @ManagedBean(&quot;movieListener&quot;) could be used as well
public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    // ...
&#125;
</code></pre>
<p>在没有为 component 指定 name 的情况下使用<code>@Component</code>非常常见。 <code>@Named</code>可以以类似的方式使用，如下面的示例所示：</p>
<pre><code>import javax.inject.Inject;
import javax.inject.Named;

@Named
public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) &#123;
        this.movieFinder = movieFinder;
    &#125;

    // ...
&#125;
</code></pre>
<p>使用<code>@Named</code>或<code>@ManagedBean</code>时，可以使用与使用 Spring annotations 时完全相同的方式使用 component 扫描，如下面的 example 所示：</p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;)
public class AppConfig  &#123;
    ...
&#125;
</code></pre>
<blockquote>
<p>与<code>@Component</code>相反，JSR-330 <code>@Named</code>和 JSR-250 <code>ManagedBean</code> 注释不可组合。你应该使用 Spring 的构造型 model 来构建 building custom component annotations。</p>
</blockquote>
<h4 id="1-11-3-JSR-330-标准注释的局限性"><a href="#1-11-3-JSR-330-标准注释的局限性" class="headerlink" title="1.11.3. JSR-330 标准注释的局限性"></a>1.11.3. JSR-330 标准注释的局限性</h4><p>当您使用标准 annotations 时，您应该知道某些重要的 features 不可用，如下面的 table 所示：</p>
<table>
<thead>
<tr>
<th>弹簧</th>
<th>javax.inject.*</th>
<th>javax.inject restrictions/comments</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>@Inject</td>
<td><code>@Inject</code>没有’required’属性。可以与 Java 8 的<code>Optional</code>一起使用。</td>
</tr>
<tr>
<td>@Component</td>
<td>@Named/@ManagedBean</td>
<td>JSR-330 不提供可组合的 model，只是一种识别命名组件的方法。</td>
</tr>
<tr>
<td>@Scope(“singleton”)</td>
<td>@Singleton</td>
<td>JSR-330 默认范围就像 Spring 的<code>prototype</code>。但是，为了使其与 Spring 的一般默认值保持一致，Spring 容器中声明的 JSR-330 bean 默认为<code>singleton</code>。在 order 中使用<code>singleton</code>以外的范围，您应该使用 Spring 的<code>@Scope</code> annotation。 <code>javax.inject</code>还提供<a target="_blank" rel="noopener" href="https://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a> 注释。然而，这个仅用于创建自己的注释。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>@Qualifier/@Named</td>
<td>对于 building 自定义限定符，<code>javax.inject.Qualifier</code>只是 meta-annotation。具体的<code>String</code>限定符(如 Spring 的<code>@Qualifier</code>带有 value)可以通过<code>javax.inject.Named</code>关联。</td>
</tr>
<tr>
<td>@Value</td>
<td>-</td>
<td>没有等价物</td>
</tr>
<tr>
<td>@Required</td>
<td>-</td>
<td>没有等价物</td>
</tr>
<tr>
<td>@Lazy</td>
<td>-</td>
<td>没有等价物</td>
</tr>
<tr>
<td>ObjectFactory</td>
<td>提供商</td>
<td><code>javax.inject.Provider</code>是 Spring 的<code>ObjectFactory</code>的直接替代，只有更短的<code>get()</code>方法 name。它也可以与 Spring 的<code>@Autowired</code>或 non-annotated 构造函数和 setter 方法结合使用。</td>
</tr>
</tbody></table>
<h3 id="1-12-Java-based-Container-Configuration"><a href="#1-12-Java-based-Container-Configuration" class="headerlink" title="1.12. Java-based Container Configuration"></a>1.12. Java-based Container Configuration</h3><p>本节介绍如何在 Java code 中使用 annotations 来配置 Spring 容器。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-basic-concepts">基本概念： @Bean 和 @Configuration</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-instantiating-container">使用 AnnotationConfigApplicationContext 实例化 Spring 容器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-bean-annotation">使用 @Bean Annotation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-configuration-annotation">使用 @Configuration annotation</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-composing-configuration-classes">编写 Java-based 配置</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles">Bean 定义 Profiles</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction">PropertySource 抽象</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-using-propertysource">使用 @PropertySource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-placeholder-resolution-in-statements">Statements 中的占位符解析</a></li>
</ul>
<h4 id="1-12-1-基本概念：-Bean-和-Configuration"><a href="#1-12-1-基本概念：-Bean-和-Configuration" class="headerlink" title="1.12.1. 基本概念： @Bean 和 @Configuration"></a>1.12.1. 基本概念： @Bean 和 @Configuration</h4><p>Spring 新的 Java-configuration 支持中的中心 artifacts 是<code>@Configuration</code> -annotated classes 和<code>@Bean</code> -annotated 方法。</p>
<p><code>@Bean</code> annotation 用于指示方法实例化，配置和初始化由 Spring IoC 容器管理的新 object。对于那些熟悉 Spring 的<code>&lt;beans/&gt;</code> XML configuration 的人来说，<code>@Bean</code> annotation 与<code>&lt;bean/&gt;</code>元素扮演的角色相同。您可以将<code>@Bean</code> -annotated 方法与任何 Spring <code>@Component</code>一起使用。但是，它们最常用于<code>@Configuration</code> beans。</p>
<p>使用<code>@Configuration</code>注释 class 表示其主要目的是作为 bean 定义的源。此外，<code>@Configuration</code> classes 允许通过调用同一 class 中的其他<code>@Bean</code>方法来定义 inter-bean 依赖项。最简单的<code>@Configuration</code> class 如下：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean
    public MyService myService() &#123;
        return new MyServiceImpl();
    &#125;
&#125;
</code></pre>
<p>前面的<code>AppConfig</code> class 等效于以下 Spring <code>&lt;beans/&gt;</code> XML：</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;myService&quot; class=&quot;com.acme.services.MyServiceImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>完整 @Configuration vs“精简” @Bean 模式？</p>
<p>当_c方法在 classes 中声明未使用<code>@Configuration</code>注释时，它们被称为以“精简”模式处理。在<code>@Component</code>或甚至普通的旧 class 中声明的 Bean 方法被认为是“lite”，包含 class 的主要目的不同，<code>@Bean</code>方法在那里是一种奖励。对于 example，服务组件可以通过每个适用的 component class 上的附加<code>@Bean</code>方法将 management 视图公开给容器。在这种情况下，<code>@Bean</code>方法是 general-purpose 工厂方法机制。</p>
<p>与完整的<code>@Configuration</code>不同，lite <code>@Bean</code>方法不能声明 inter-bean 依赖项。相反，它们在包含 component 的内部 state 上运行，并且可选地在它们可能声明的 arguments 上运行。因此，这样的<code>@Bean</code>方法不应该调用其他<code>@Bean</code>方法。每个这样的方法实际上只是特定 bean reference 的工厂方法，没有任何特殊的运行时语义。这里的正面 side-effect 是没有 CGLIB 子类必须在运行时应用，所以在 class 设计方面没有限制(也就是说，包含 class 可能是<code>final</code>等等)。</p>
<p>在 common 场景中，<code>@Bean</code>方法将在<code>@Configuration</code> classes 中声明，确保始终使用“完整”模式，因此 cross-method references 会被重定向到容器的生命周期 management。这可以防止通过常规 Java 调用意外地调用相同的<code>@Bean</code>方法，这有助于减少在“精简”模式下操作时难以跟踪的细微错误。</p>
<p><code>@Bean</code>和<code>@Configuration</code> 注释将在以下部分中进行深入讨论。首先，我们将介绍使用 Java-based configuration 创建 spring 容器的各种方法。</p>
<h4 id="1-12-2-使用-AnnotationConfigApplicationContext-实例化-Spring-容器"><a href="#1-12-2-使用-AnnotationConfigApplicationContext-实例化-Spring-容器" class="headerlink" title="1.12.2. 使用 AnnotationConfigApplicationContext 实例化 Spring 容器"></a>1.12.2. 使用 AnnotationConfigApplicationContext 实例化 Spring 容器</h4><p>以下部分记录了 Spring 3.0 中引入的 Spring 的<code>AnnotationConfigApplicationContext</code>。这个多功能的<code>ApplicationContext</code> implementation 不仅能够接受<code>@Configuration</code> classes 作为输入，还能接受使用 JSR-330 元数据注释的普通<code>@Component</code> classes 和 classes。</p>
<p>当<code>@Configuration</code> classes 作为输入提供时，<code>@Configuration</code> class 本身被注册为 bean 定义，class 中所有声明的<code>@Bean</code>方法也被注册为 bean 定义。</p>
<p>当提供<code>@Component</code>和 JSR-330 classes 时，它们被注册为 bean 定义，并且假设在必要时在那些 classes 中使用诸如<code>@Autowired</code>或<code>@Inject</code>的 DI 元数据。</p>
<h5 id="简单构造"><a href="#简单构造" class="headerlink" title="简单构造"></a>简单构造</h5><p>与实例化<code>ClassPathXmlApplicationContext</code>时 Spring XML files 用作输入的方式大致相同，在实例化<code>AnnotationConfigApplicationContext</code>时可以使用<code>@Configuration</code> classes 作为输入。这允许完全 XML-free 使用 Spring 容器，如下面的示例所示：</p>
<pre><code>public static void main(String[] args) &#123;
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
&#125;
</code></pre>
<p>如前所述，<code>AnnotationConfigApplicationContext</code>不仅限于使用<code>@Configuration</code> classes。任何<code>@Component</code>或 JSR-330 带注释的 class 都可以作为输入提供给构造函数，如下面的 example 所示：</p>
<pre><code>public static void main(String[] args) &#123;
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
&#125;
</code></pre>
<p>前面的 example 假定<code>MyServiceImpl</code>，<code>Dependency1</code>和<code>Dependency2</code>使用 Spring 依赖注入注释，例如<code>@Autowired</code>。</p>
<h5 id="使用-register-Class-lt-gt-以编程方式构建容器…"><a href="#使用-register-Class-lt-gt-以编程方式构建容器…" class="headerlink" title="使用 register(Class &lt;?&gt;以编程方式构建容器…)"></a>使用 register(Class &lt;?&gt;以编程方式构建容器…)</h5><p>您可以使用 no-arg 构造函数实例化<code>AnnotationConfigApplicationContext</code>，然后使用<code>register()</code>方法对其进行配置。当以编程方式 building <code>AnnotationConfigApplicationContext</code>时，此方法特别有用。以下 example 显示了如何执行此操作：</p>
<pre><code>public static void main(String[] args) &#123;
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
&#125;
</code></pre>
<h5 id="使用-scan-String-启用-Component-扫描…"><a href="#使用-scan-String-启用-Component-扫描…" class="headerlink" title="使用 scan(String 启用 Component 扫描…)"></a>使用 scan(String 启用 Component 扫描…)</h5><p>要启用 component 扫描，您可以按如下方式注释<code>@Configuration</code> class：</p>
<pre><code>@Configuration
@ComponentScan(basePackages = &quot;com.acme&quot;) (1)
public class AppConfig  &#123;
    ...
&#125;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>此 annotation 启用 component 扫描。</td>
</tr>
</tbody></table>
<blockquote>
<p>有经验的 Spring 用户可能熟悉与 Spring 的<code>context:</code>名称空间等效的 XML 声明，如下面的示例所示：</p>
</blockquote>
<pre><code>&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;com.acme&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>在前面的 example 中，扫描<code>com.acme</code>包以查找任何<code>@Component</code> -annotated classes，并且这些 classes 在容器中注册为 Spring bean 定义。 <code>AnnotationConfigApplicationContext</code>公开<code>scan(String…)</code>方法以允许相同的 component-scanning 功能，如下面的 example 所示：</p>
<pre><code>public static void main(String[] args) &#123;
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan(&quot;com.acme&quot;);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
&#125;
</code></pre>
<blockquote>
<p>请记住，<code>@Configuration</code> classes 是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-meta-annotations">meta-annotated</a>和<code>@Component</code>，因此它们是 component-scanning 的候选者。在前面的 example 中，假设<code>AppConfig</code>在<code>com.acme</code>包(或下面的任何包)中声明，它在调用<code>scan()</code>期间被拾取。在<code>refresh()</code>之后，它的所有<code>@Bean</code>方法都被处理并在容器中注册为 bean 定义。</p>
</blockquote>
<h5 id="使用-AnnotationConfigWebApplicationContext-支持-Web-Applications"><a href="#使用-AnnotationConfigWebApplicationContext-支持-Web-Applications" class="headerlink" title="使用 AnnotationConfigWebApplicationContext 支持 Web Applications"></a>使用 AnnotationConfigWebApplicationContext 支持 Web Applications</h5><p><code>AnnotationConfigWebApplicationContext</code>的<code>WebApplicationContext</code>变体可用于<code>AnnotationConfigWebApplicationContext</code>。配置 Spring <code>ContextLoaderListener</code> servlet listener，Spring MVC <code>DispatcherServlet</code>等时，可以使用此 implementation。以下<code>web.xml</code>片段配置典型的 Spring MVC web application(注意使用<code>contextClass</code> context-param 和 init-param)：</p>
<pre><code>&lt;web-app&gt;
    &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;com.acme.AppConfig&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextClass&lt;/param-name&gt;
            &lt;param-value&gt;
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            &lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;com.acme.web.MvcConfig&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<h4 id="1-12-3-使用-Bean-Annotation"><a href="#1-12-3-使用-Bean-Annotation" class="headerlink" title="1.12.3. 使用 @Bean Annotation"></a>1.12.3. 使用 @Bean Annotation</h4><p><code>@Bean</code>是 method-level annotation，是 XML <code>&lt;bean/&gt;</code>元素的直接模拟。 annotation 支持<code>&lt;bean/&gt;</code>提供的一些属性，例如：* <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">init-method</a> * <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean">destroy-method</a> * <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">自动装配</a> * <code>name</code>。</p>
<p>您可以在<code>@Configuration</code> -annotated 或<code>@Component</code> -annotated class 中使用<code>@Bean</code> annotation。</p>
<h5 id="声明-Bean"><a href="#声明-Bean" class="headerlink" title="声明 Bean"></a>声明 Bean</h5><p>要声明 bean，可以使用<code>@Bean</code> annotation 注释方法。您可以使用此方法在指定为方法的 return value 的类型的<code>ApplicationContext</code>中注册 bean 定义。默认情况下， bean name 与方法 name 相同。以下 example 显示了一个<code>@Bean</code>方法声明：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean
    public TransferServiceImpl transferService() &#123;
        return new TransferServiceImpl();
    &#125;
&#125;
</code></pre>
<p>前面的 configuration 与以下 Spring XML 完全等效：</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>两个声明都在<code>ApplicationContext</code>中创建一个名为<code>transferService</code>的 bean，绑定到<code>TransferServiceImpl</code>类型的 object 实例，如下面的文本图像所示：</p>
<pre><code>transferService -&gt; com.acme.TransferServiceImpl
</code></pre>
<p>您还可以使用接口(或 base class)return 类型声明<code>@Bean</code>方法，如下面的 example 所示：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean
    public TransferService transferService() &#123;
        return new TransferServiceImpl();
    &#125;
&#125;
</code></pre>
<p>但是，这会将高级类型预测的可见性限制为指定的接口类型(<code>TransferService</code>)。然后，只有容器已知的完整类型(<code>TransferServiceImpl</code>)一次，受影响的 singleton bean 已被实例化。 Non-lazy singleton beans 根据其声明 order 进行实例化，因此您可能会看到不同的类型匹配结果，具体取决于另一个 component 尝试按 non-declared 类型匹配的情况(例如<code>@Autowired TransferServiceImpl</code>，只有在<code>transferService</code> bean 实例化后才会解析)。</p>
<blockquote>
<p>如果您始终通过声明的服务接口引用您的类型，则<code>@Bean</code> return 类型可以安全地加入该设计决策。但是，对于实现多个接口的组件或可能由其 implementation 类型引用的组件，更可能更容易地声明最具体的 return 类型(至少与引用 bean 的注入点所需的特定类型一样)。</p>
</blockquote>
<h5 id="Bean-依赖项"><a href="#Bean-依赖项" class="headerlink" title="Bean 依赖项"></a>Bean 依赖项</h5><p><code>@Bean</code> -annotated 方法可以有任意数量的参数来描述 build bean 所需的依赖关系。例如，如果我们的<code>TransferService</code>需要<code>AccountRepository</code>，我们可以使用方法参数来实现该依赖关系，如下面的 example 所示：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean
    public TransferService transferService(AccountRepository accountRepository) &#123;
        return new TransferServiceImpl(accountRepository);
    &#125;
&#125;
</code></pre>
<p>解决机制与 constructor-based 依赖注入非常相似。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-constructor-injection">相关部分</a>。</p>
<h5 id="接收生命周期回调"><a href="#接收生命周期回调" class="headerlink" title="接收生命周期回调"></a>接收生命周期回调</h5><p>使用<code>@Bean</code> annotation 定义的任何 classes 都支持常规生命周期回调，并且可以使用 JSR-250 中的<code>@PostConstruct</code>和<code>@PreDestroy</code> 注释。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-postconstruct-and-predestroy-annotations">JSR-250 注释</a>。</p>
<p>完全支持常规 Spring <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-nature">生命周期</a>回调。如果 bean 实现<code>InitializingBean</code>，<code>DisposableBean</code>或<code>Lifecycle</code>，则容器将调用它们各自的方法。</p>
<p>还完全支持标准的<code>*Aware</code>接口集(例如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanfactory">实现 BeanFactoryAware</a>，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">BeanNameAware</a>，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#context-functionality-messagesource">MessageSourceAware</a>，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">了 ApplicationContextAware</a>等)。</p>
<p><code>@Bean</code> annotation 支持指定任意初始化和销毁回调方法，就像<code>bean</code>元素上 Spring XML 的<code>init-method</code>和<code>destroy-method</code>属性一样，如下面的 example 所示：</p>
<pre><code>public class BeanOne &#123;

    public void init() &#123;
        // initialization logic
    &#125;
&#125;

public class BeanTwo &#123;

    public void cleanup() &#123;
        // destruction logic
    &#125;
&#125;

@Configuration
public class AppConfig &#123;

    @Bean(initMethod = &quot;init&quot;)
    public BeanOne beanOne() &#123;
        return new BeanOne();
    &#125;

    @Bean(destroyMethod = &quot;cleanup&quot;)
    public BeanTwo beanTwo() &#123;
        return new BeanTwo();
    &#125;
&#125;
</code></pre>
<blockquote>
<p>默认情况下，使用具有公共<code>close</code>或<code>shutdown</code>方法的 Java configuration 定义的 beans 将自动使用销毁回调登记。如果您有一个公共的<code>close</code>或<code>shutdown</code>方法，并且您不希望在容器关闭时调用它，则可以将<code>@Bean(destroyMethod=&quot;&quot;)</code>添加到 bean 定义以禁用默认的<code>(inferred)</code>模式。</p>
</blockquote>
<p>对于使用 JNDI 获取的资源，您可能希望默认执行此操作，因为其生命周期在 application 之外进行管理。特别是，确保始终为<code>DataSource</code>执行此操作，因为已知它在 Java EE application 服务器上存在问题。</p>
<p>以下 example 显示了如何防止<code>DataSource</code>的自动销毁回调：</p>
<pre><code>@Bean(destroyMethod=&quot;&quot;)
public DataSource dataSource() throws NamingException &#123;
    return (DataSource) jndiTemplate.lookup(&quot;MyDS&quot;);
&#125;
</code></pre>
<p>此外，使用<code>@Bean</code>方法，您通常使用编程 JNDI 查找，使用 Spring 的<code>JndiTemplate</code>或<code>JndiLocatorDelegate</code>帮助器或直接 JNDI <code>InitialContext</code>用法但不使用<code>JndiObjectFactoryBean</code>变体(这会强制您将 return 类型声明为<code>FactoryBean</code>类型而不是实际目标类型，使其更难用于其他<code>@Bean</code>方法中的 cross-reference calls，这些方法打算在这里引用提供的资源)。</p>
<p>对于前面注释上方 example 的<code>BeanOne</code>，在构造过程中直接调用<code>init()</code>方法同样有效，如下面的 example 所示：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean
    public BeanOne beanOne() &#123;
        BeanOne beanOne = new BeanOne();
        beanOne.init();
        return beanOne;
    &#125;

    // ...
&#125;
</code></pre>
<blockquote>
<p>当您直接使用 Java 工作时，您可以使用 objects 执行任何您喜欢的操作，并且不必总是依赖于容器生命周期。</p>
</blockquote>
<h5 id="指定-Bean-范围"><a href="#指定-Bean-范围" class="headerlink" title="指定 Bean 范围"></a>指定 Bean 范围</h5><p>Spring 包含<code>@Scope</code> annotation，以便您可以指定 bean 的范围。</p>
<h6 id="使用-Scope-Annotation"><a href="#使用-Scope-Annotation" class="headerlink" title="使用 @Scope Annotation"></a>使用 @Scope Annotation</h6><p>您可以指定使用<code>@Bean</code> annotation 定义的 beans 应具有特定范围。您可以使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">Bean 范围</a>部分中指定的任何标准范围。</p>
<p>默认范围是<code>singleton</code>，但您可以使用<code>@Scope</code> annotation 覆盖它，如下面的 example 所示：</p>
<pre><code>@Configuration
public class MyConfiguration &#123;

    @Bean
    @Scope(&quot;prototype&quot;)
    public Encryptor encryptor() &#123;
        // ...
    &#125;
&#125;
</code></pre>
<h6 id="Scope-和-scoped-proxy"><a href="#Scope-和-scoped-proxy" class="headerlink" title="@Scope 和 scoped-proxy"></a>@Scope 和 scoped-proxy</h6><p>Spring 提供了一种通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">范围代理</a>处理作用域依赖项的便捷方式。使用 XML configuration 时创建此类代理的最简单方法是<code>&lt;aop:scoped-proxy/&gt;</code>元素。使用<code>@Scope</code> annotation 在 Java 中配置 beans 可提供与<code>proxyMode</code>属性的等效支持。默认值为无代理(<code>ScopedProxyMode.NO</code>)，但您可以指定<code>ScopedProxyMode.TARGET_CLASS</code>或<code>ScopedProxyMode.INTERFACES</code>。</p>
<p>如果使用 Java 将 XML 范围内的 scoped proxy example port(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection">范围代理</a>)传递到我们的<code>@Bean</code>，它类似于以下内容：</p>
<pre><code>// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
public UserPreferences userPreferences() &#123;
    return new UserPreferences();
&#125;

@Bean
public Service userService() &#123;
    UserService service = new SimpleUserService();
    // a reference to the proxied userPreferences bean
    service.setUserPreferences(userPreferences());
    return service;
&#125;
</code></pre>
<h5 id="自定义-Bean-命名"><a href="#自定义-Bean-命名" class="headerlink" title="自定义 Bean 命名"></a>自定义 Bean 命名</h5><p>默认情况下，configuration classes 使用<code>@Bean</code>方法的 name 作为生成的 bean 的 name。但是，使用<code>name</code>属性可以覆盖此功能，如下面的 example 所示：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean(name = &quot;myThing&quot;)
    public Thing thing() &#123;
        return new Thing();
    &#125;
&#125;
</code></pre>
<h5 id="Bean-Aliasing"><a href="#Bean-Aliasing" class="headerlink" title="Bean Aliasing"></a>Bean Aliasing</h5><p>如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanname">命名 Beans</a>中所讨论的，有时需要给出一个 bean 多个名称，也称为 bean 别名。为此，<code>@Bean</code> annotation 的<code>name</code>属性接受 String array。以下 example 显示了如何为 bean 设置多个别名：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean(&#123;&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;&#125;)
    public DataSource dataSource() &#123;
        // instantiate, configure and return DataSource bean...
    &#125;
&#125;
</code></pre>
<h5 id="Bean-描述"><a href="#Bean-描述" class="headerlink" title="Bean 描述"></a>Bean 描述</h5><p>有时，提供 bean 的更详细的文本描述是有帮助的。当 beans 暴露(可能通过 JMX)用于监视目的时，这可能特别有用。</p>
<p>要向<code>@Bean</code>添加描述，可以使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html">@Description</a> annotation，如下面的 example 所示：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean
    @Description(&quot;Provides a basic example of a bean&quot;)
    public Thing thing() &#123;
        return new Thing();
    &#125;
&#125;
</code></pre>
<h4 id="1-12-4-使用-Configuration-annotation"><a href="#1-12-4-使用-Configuration-annotation" class="headerlink" title="1.12.4. 使用 @Configuration annotation"></a>1.12.4. 使用 @Configuration annotation</h4><p><code>@Configuration</code>是 class-level annotation，表示 object 是 bean 定义的来源。 <code>@Configuration</code> classes 通过 public <code>@Bean</code> annotated 方法声明 beans。 Calls 到<code>@Configuration</code> classes 上的<code>@Bean</code>方法也可用于定义 inter-bean 依赖项。有关一般介绍，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-basic-concepts">基本概念： @Bean 和 @Configuration</a>。</p>
<h5 id="注入-Inter-bean-依赖项"><a href="#注入-Inter-bean-依赖项" class="headerlink" title="注入 Inter-bean 依赖项"></a>注入 Inter-bean 依赖项</h5><p>当 beans 彼此依赖时，表达该依赖关系就像让一个 bean 方法调用另一个一样简单，如下面的 example 所示：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean
    public BeanOne beanOne() &#123;
        return new BeanOne(beanTwo());
    &#125;

    @Bean
    public BeanTwo beanTwo() &#123;
        return new BeanTwo();
    &#125;
&#125;
</code></pre>
<p>在前面的 example 中，<code>beanOne</code>通过构造函数注入接收到<code>beanTwo</code>的 reference。</p>
<blockquote>
<p>这种声明 inter-bean 依赖项的方法仅在<code>@Configuration</code> class 中声明<code>@Bean</code>方法时才有效。您不能使用普通<code>@Component</code> classes 声明 inter-bean 依赖项。</p>
</blockquote>
<h5 id="查找方法注入-1"><a href="#查找方法注入-1" class="headerlink" title="查找方法注入"></a>查找方法注入</h5><p>如前所述，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-method-injection">查找方法注入</a>是一种您应该很少使用的高级 feature。在 singleton-scoped bean 依赖于 prototype-scoped bean 的情况下，它很有用。使用 Java 进行此类型的 configuration 提供了实现此 pattern 的自然方法。以下 example 显示了如何使用查找方法注入：</p>
<pre><code>public abstract class CommandManager &#123;
    public Object process(Object commandState) &#123;
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    &#125;

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
&#125;
</code></pre>
<p>通过使用 Java configuration，您可以创建<code>CommandManager</code>的子类，其中抽象<code>createCommand()</code>方法被覆盖，以便查找新的(原型)命令 object。以下 example 显示了如何执行此操作：</p>
<pre><code>@Bean
@Scope(&quot;prototype&quot;)
public AsyncCommand asyncCommand() &#123;
    AsyncCommand command = new AsyncCommand();
    // inject dependencies here as required
    return command;
&#125;

@Bean
public CommandManager commandManager() &#123;
    // return new anonymous implementation of CommandManager with command() overridden
    // to return a new prototype Command object
    return new CommandManager() &#123;
        protected Command createCommand() &#123;
            return asyncCommand();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="关于-Java-based-Configuration-如何在内部工作的更多信息"><a href="#关于-Java-based-Configuration-如何在内部工作的更多信息" class="headerlink" title="关于 Java-based Configuration 如何在内部工作的更多信息"></a>关于 Java-based Configuration 如何在内部工作的更多信息</h5><p>考虑以下 example，它显示了一个被调用两次的<code>@Bean</code>注释方法：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean
    public ClientService clientService1() &#123;
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    &#125;

    @Bean
    public ClientService clientService2() &#123;
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    &#125;

    @Bean
    public ClientDao clientDao() &#123;
        return new ClientDaoImpl();
    &#125;
&#125;
</code></pre>
<p><code>clientDao()</code>在<code>clientService1()</code>中被调用一次，在<code>clientService2()</code>中被调用一次。由于此方法创建<code>ClientDaoImpl</code>的新实例并将其返回，因此通常需要两个实例(每个服务一个)。这肯定会有问题：在 Spring 中，实例化的 beans 默认具有<code>singleton</code>范围。这就是魔术的用武之地：所有<code>@Configuration</code> class 都在 startup-time 和<code>CGLIB</code>进行了子类化。在子类中，child 方法首先检查容器是否有任何缓存(作用域)beans，然后 calls parent 方法并创建一个新实例。</p>
<blockquote>
<p>根据 bean 的范围，行为可能会有所不同。我们在这里谈论单身人士。</p>
</blockquote>
<blockquote>
<p>从 Spring 3.2 开始，不再需要将 CGLIB 添加到 classpath 中，因为 CGLIB classes 已经在<code>org.springframework.cglib</code>下重新打包并直接包含在 spring-core JAR 中。</p>
</blockquote>
<blockquote>
<p>由于 CGLIB 在 startup-time 处动态添加 features，因此存在一些限制。特别是，configuration classes 不能是 final。但是，从 4.3 开始，configuration classes 上允许使用任何构造函数，包括使用<code>@Autowired</code>或单个 non-default 构造函数声明进行默认注入。</p>
</blockquote>
<p>如果您希望避免任何 CGLIB-imposed 限制，请考虑在非<code>@Configuration</code> classes 上声明<code>@Bean</code>方法(对于 example，而不是在<code>@Component</code> classes 上)。然后，<code>@Bean</code>方法之间的 Cross-method calls 不会被截获，因此您必须完全依赖于构造函数或方法 level 的依赖注入。</p>
<h4 id="1-12-5-撰写-Java-based-配置"><a href="#1-12-5-撰写-Java-based-配置" class="headerlink" title="1.12.5. 撰写 Java-based 配置"></a>1.12.5. 撰写 Java-based 配置</h4><p>Spring 的 Java-based configuration feature 允许您撰写 annotations，这可以降低 configuration 的复杂性。</p>
<h5 id="使用-Import-Annotation"><a href="#使用-Import-Annotation" class="headerlink" title="使用 @Import Annotation"></a>使用 @Import Annotation</h5><p>就像在 Spring XML files 中使用<code>&lt;import/&gt;</code>元素来帮助模块化配置一样，<code>@Import</code> annotation 允许从另一个 configuration class 中加载<code>@Bean</code>定义，如下面的 example 所示：</p>
<pre><code>@Configuration
public class ConfigA &#123;

    @Bean
    public A a() &#123;
        return new A();
    &#125;
&#125;

@Configuration
@Import(ConfigA.class)
public class ConfigB &#123;

    @Bean
    public B b() &#123;
        return new B();
    &#125;
&#125;
</code></pre>
<p>现在，在实例化 context 时，不需要同时指定<code>ConfigA.class</code>和<code>ConfigB.class</code>，只需要显式提供<code>ConfigB</code>，如下面的 example 所示：</p>
<pre><code>public static void main(String[] args) &#123;
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
&#125;
</code></pre>
<p>这种方法简化了容器实例化，因为只需要处理一个 class，而不是要求你在构造期间记住可能大量的<code>@Configuration</code> classes。</p>
<blockquote>
<p>从 Spring Framework 4.2 开始，<code>@Import</code>也支持 references regular component classes，类似于<code>AnnotationConfigApplicationContext.register</code>方法。如果要通过使用一些 configuration classes 作为明确定义所有组件的入口点来避免 component 扫描，这将非常有用。</p>
</blockquote>
<h6 id="在导入的-Bean-定义上注入依赖项"><a href="#在导入的-Bean-定义上注入依赖项" class="headerlink" title="在导入的 @Bean 定义上注入依赖项"></a>在导入的 @Bean 定义上注入依赖项</h6><p>前面的 example 有效，但很简单。在大多数实际场景中，beans 在 configuration classes 之间依赖于彼此。使用 XML 时，这不是问题，因为不涉及编译器，并且您可以在容器初始化期间声明<code>ref=&quot;someBean&quot;</code>并信任 Spring 来解决它。使用<code>@Configuration</code> classes 时，Java 编译器会在 configuration model 上设置约束，因为对其他 beans 的引用必须是有效的 Java 语法。</p>
<p>幸运的是，解决这个问题很简单。作为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-dependencies">我们已经讨论过</a>，<code>@Bean</code>方法可以具有任意数量的参数来描述 bean 依赖项。考虑以下更多带有几个<code>@Configuration</code> classes 的 real-world 场景，每个场景都取决于其他人声明的 beans：</p>
<pre><code>@Configuration
public class ServiceConfig &#123;

    @Bean
    public TransferService transferService(AccountRepository accountRepository) &#123;
        return new TransferServiceImpl(accountRepository);
    &#125;
&#125;

@Configuration
public class RepositoryConfig &#123;

    @Bean
    public AccountRepository accountRepository(DataSource dataSource) &#123;
        return new JdbcAccountRepository(dataSource);
    &#125;
&#125;

@Configuration
@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)
public class SystemTestConfig &#123;

    @Bean
    public DataSource dataSource() &#123;
        // return new DataSource
    &#125;
&#125;

public static void main(String[] args) &#123;
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);
&#125;
</code></pre>
<p>还有另一种方法可以达到相同的效果。请记住，<code>@Configuration</code> classes 最终只是容器中的另一个 bean：这意味着它们可以利用<code>@Autowired</code>和<code>@Value</code>注入和其他 features 与任何其他 bean 相同。</p>
<blockquote>
<p>确保您以这种方式注入的依赖项仅为最简单的依赖项。在 context 初始化期间很早就处理了<code>@Configuration</code> classes，并且强制以这种方式注入依赖项可能会导致意外的早期初始化。尽可能采用 parameter-based 注入，如前面的 example 中所示。</p>
</blockquote>
<p>另外，要特别注意通过<code>@Bean</code>的<code>BeanPostProcessor</code>和<code>BeanFactoryPostProcessor</code>定义。那些应该通常被声明为<code>static @Bean</code>方法，而不是触发它们包含 configuration class 的实例化。否则，<code>@Autowired</code>和<code>@Value</code>在 configuration class 本身上不起作用，因为它太早创建为 bean 实例。</p>
<p>以下 example 显示了如何将一个 bean 自动连接到另一个 bean：</p>
<pre><code>@Configuration
public class ServiceConfig &#123;

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() &#123;
        return new TransferServiceImpl(accountRepository);
    &#125;
&#125;

@Configuration
public class RepositoryConfig &#123;

    private final DataSource dataSource;

    @Autowired
    public RepositoryConfig(DataSource dataSource) &#123;
        this.dataSource = dataSource;
    &#125;

    @Bean
    public AccountRepository accountRepository() &#123;
        return new JdbcAccountRepository(dataSource);
    &#125;
&#125;

@Configuration
@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)
public class SystemTestConfig &#123;

    @Bean
    public DataSource dataSource() &#123;
        // return new DataSource
    &#125;
&#125;

public static void main(String[] args) &#123;
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);
&#125;
</code></pre>
<blockquote>
<p>仅在 Spring Framework 4.3 时支持<code>@Configuration</code> classes 中的构造函数注入。另请注意，如果 target bean 仅定义了一个构造函数，则无需指定<code>@Autowired</code>。在前面的 example 中，<code>RepositoryConfig</code>构造函数不需要<code>@Autowired</code>。</p>
</blockquote>
<p>Fully-qualifying 导入 beans 以方便导航</p>
<p>在前面的场景中，使用<code>@Autowired</code>可以很好地工作并提供所需的模块化，但确定声明自动装配的 bean 定义的确切位置仍然有些模棱两可。对于 example，作为一个查看<code>ServiceConfig</code>的开发人员，您如何确切地知道<code>@Autowired AccountRepository</code> bean 的声明位置？它在 code 中并不明确，这可能就好了。请记住，<a target="_blank" rel="noopener" href="https://spring.io/tools/sts">Spring 工具套件</a>提供的工具可以呈现图表，显示所有内容的连线方式，这可能就是您所需要的。此外，您的 Java IDE 可以轻松找到<code>AccountRepository</code>类型的所有声明和用法，并快速显示方法的位置 return 该类型。</p>
<p>如果这种歧义是不可接受的，并且您希望从 IDE 中直接从一个<code>@Configuration</code> class 导航到另一个<code>@Configuration</code> class，请考虑自动装配 configuration classes 本身。以下 example 显示了如何执行此操作：</p>
<pre><code>@Configuration
public class ServiceConfig &#123;

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() &#123;
        // navigate &#39;through&#39; the config class to the @Bean method!
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    &#125;
&#125;
</code></pre>
<p>在前面的情况中，定义<code>AccountRepository</code>是完全明确的。但是，<code>ServiceConfig</code>现在与<code>RepositoryConfig</code>紧密耦合。这是权衡。通过使用 interface-based 或 abstract class-based <code>@Configuration</code> classes，可以在某种程度上减轻这种紧密耦合。考虑以下 example：</p>
<pre><code>@Configuration
public class ServiceConfig &#123;

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() &#123;
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    &#125;
&#125;

@Configuration
public interface RepositoryConfig &#123;

    @Bean
    AccountRepository accountRepository();
&#125;

@Configuration
public class DefaultRepositoryConfig implements RepositoryConfig &#123;

    @Bean
    public AccountRepository accountRepository() &#123;
        return new JdbcAccountRepository(...);
    &#125;
&#125;

@Configuration
@Import(&#123;ServiceConfig.class, DefaultRepositoryConfig.class&#125;)  // import the concrete config!
public class SystemTestConfig &#123;

    @Bean
    public DataSource dataSource() &#123;
        // return DataSource
    &#125;

&#125;

public static void main(String[] args) &#123;
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);
&#125;
</code></pre>
<p>现在<code>ServiceConfig</code>与具体的<code>DefaultRepositoryConfig</code>松散耦合，并且 built-in IDE 工具仍然有用：您可以轻松获得<code>RepositoryConfig</code> __mplement 的类型层次结构。通过这种方式，导航<code>@Configuration</code> classes 及其依赖项与导航 interface-based code 的常用 process 没有什么不同。</p>
<blockquote>
<p>如果要影响某些 beans 的启动创建 order，请考虑将其中一些声明为<code>@Lazy</code>(用于在首次访问时创建而不是在启动时)或<code>@DependsOn</code>某些其他 beans(确保在当前 bean 之前创建特定的其他 beans) ，超出后者的直接依赖性所暗示的)。</p>
</blockquote>
<h5 id="有条件地包含-Configuration-Classes-或-Bean-方法"><a href="#有条件地包含-Configuration-Classes-或-Bean-方法" class="headerlink" title="有条件地包含 @Configuration Classes 或 @Bean 方法"></a>有条件地包含 @Configuration Classes 或 @Bean 方法</h5><p>基于某个任意系统 state，有条件地启用或禁用完整的<code>@Configuration</code> class 甚至单个<code>@Bean</code>方法通常很有用。一个 common example 是使用<code>@Profile</code> annotation 只有在 Spring <code>Environment</code>中启用了特定的 profile 时才激活_beof(详见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles">Bean 定义 Profiles</a>)。</p>
<p><code>@Profile</code> annotation 实际上是通过使用名为<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html">@Conditional</a>的更灵活的 annotation 实现的。 <code>@Conditional</code> annotation 指示在注册<code>@Bean</code>之前应查阅的特定<code>org.springframework.context.annotation.Condition</code> __mplement。</p>
<p>接口的实现提供了一个返回<code>true</code>或<code>false</code>的<code>matches(…)</code>方法。对于 example，以下列表显示了用于<code>@Profile</code>的实际<code>Condition</code> implementation：</p>
<pre><code>@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;
    if (context.getEnvironment() != null) &#123;
        // Read the @Profile annotation attributes
        MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
        if (attrs != null) &#123;
            for (Object value : attrs.get(&quot;value&quot;)) &#123;
                if (context.getEnvironment().acceptsProfiles(((String[]) value))) &#123;
                    return true;
                &#125;
            &#125;
            return false;
        &#125;
    &#125;
    return true;
&#125;
</code></pre>
<p>有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html">@Conditional</a> javadoc。</p>
<h5 id="结合-Java-和-XML-Configuration"><a href="#结合-Java-和-XML-Configuration" class="headerlink" title="结合 Java 和 XML Configuration"></a>结合 Java 和 XML Configuration</h5><p>Spring 的<code>@Configuration</code> class 支持并非旨在成为 Spring XML 的 100％完全替代品。某些工具(如 Spring XML 命名空间)仍然是配置容器的理想方法。在 XML 方便或必要的情况下，您可以选择：通过使用，example，<code>ClassPathXmlApplicationContext</code>以“XML-centric”方式实例化容器，或者使用<code>AnnotationConfigApplicationContext</code>以及<code>@ImportResource</code> annotation 到 import 以“Java-centric”方式实例化它根据需要使用 XML。</p>
<h6 id="XML-centric-使用-Configuration-Classes"><a href="#XML-centric-使用-Configuration-Classes" class="headerlink" title="XML-centric 使用 @Configuration Classes"></a>XML-centric 使用 @Configuration Classes</h6><p>最好从 XML 引导 Spring 容器，并以 ad-hoc 方式包含<code>@Configuration</code> classes。例如，在使用 Spring XML 的大型现有代码库中，更容易在 as-needed 基础上创建<code>@Configuration</code> classes 并将其包含在现有的 XML files 中。在本节的后面部分，我们将介绍在这种“XML-centric”情况下使用<code>@Configuration</code> classes 的选项。</p>
<p>将<code>@Configuration</code> classes 声明为普通的 Spring <code>&lt;bean/&gt;</code>元素</p>
<p>请记住，<code>@Configuration</code> classes 最终是容器中的 bean 定义。在本系列示例中，我们创建一个名为<code>AppConfig</code>的<code>@Configuration</code> class，并将其作为<code>&lt;bean/&gt;</code>定义包含在<code>system-test-config.xml</code>中。因为<code>&lt;context:annotation-config/&gt;</code>已打开，容器会识别<code>@Configuration</code> annotation 并正确处理<code>AppConfig</code>中声明的<code>@Bean</code>方法。</p>
<p>以下 example 显示了 Java 中的普通 configuration class：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Autowired
    private DataSource dataSource;

    @Bean
    public AccountRepository accountRepository() &#123;
        return new JdbcAccountRepository(dataSource);
    &#125;

    @Bean
    public TransferService transferService() &#123;
        return new TransferService(accountRepository());
    &#125;
&#125;
</code></pre>
<p>以下 example 显示了 sample <code>system-test-config.xml</code>文件的一部分：</p>
<pre><code>&lt;beans&gt;
    &lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;
    &lt;context:annotation-config/&gt;
    &lt;context:property-placeholder location=&quot;classpath:/com/acme/jdbc.properties&quot;/&gt;

    &lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;

    &lt;bean class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>以下 example 显示了一个可能的<code>jdbc.properties</code>文件：</p>
<pre><code>jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
</code></pre>
<pre><code>public static void main(String[] args) &#123;
    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:/com/acme/system-test-config.xml&quot;);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
&#125;
</code></pre>
<blockquote>
<p>在<code>system-test-config.xml</code>文件中，<code>AppConfig</code> <code>&lt;bean/&gt;</code>不声明<code>id</code>元素。虽然这样做是可以接受的，但是没有必要，因为没有其他 bean 引用它，并且不太可能通过 name 从容器中明确地获取它。类似地，<code>DataSource</code> bean 仅由类型自动装配，因此不严格要求显式 bean <code>id</code>。</p>
</blockquote>
<p>使用&lt; hh:// +2343+ .h &gt;来获取<code>@Configuration</code> classes</p>
<p>因为<code>@Configuration</code>是带有<code>@Component</code>的 meta-annotated，<code>@Configuration</code> -annotated classes 自动成为 component 扫描的候选者。使用与上一个 example 中描述的相同的场景，我们可以重新定义<code>system-test-config.xml</code>以利用 component-scanning。请注意，在这种情况下，我们不需要显式声明<code>&lt;context:annotation-config/&gt;</code>，因为<code>&lt;context:component-scan/&gt;</code>启用相同的功能。</p>
<p>以下 example 显示了修改后的<code>system-test-config.xml</code>文件：</p>
<pre><code>&lt;beans&gt;
    &lt;!-- picks up and registers AppConfig as a bean definition --&gt;
    &lt;context:component-scan base-package=&quot;com.acme&quot;/&gt;
    &lt;context:property-placeholder location=&quot;classpath:/com/acme/jdbc.properties&quot;/&gt;

    &lt;bean class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="Configuration-Class-centric-将-XML-与-ImportResource-一起使用"><a href="#Configuration-Class-centric-将-XML-与-ImportResource-一起使用" class="headerlink" title="@Configuration Class-centric 将 XML 与 @ImportResource 一起使用"></a>@Configuration Class-centric 将 XML 与 @ImportResource 一起使用</h6><p>在 application 中<code>@Configuration</code> classes 是配置容器的主要机制，仍然可能需要使用至少一些 XML。在这些场景中，您可以使用<code>@ImportResource</code>并根据需要定义尽可能多的 XML。这样做可以实现配置容器的“Java-centric”方法，并将 XML 保持在最低限度。以下 example(包括 configuration class，定义 bean，properties 文件和<code>main</code> class 的 XML 文件)显示了如何使用<code>@ImportResource</code> annotation 来实现根据需要使用 XML 的“Java-centric”configuration：</p>
<pre><code>@Configuration
@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)
public class AppConfig &#123;

    @Value(&quot;$&#123;jdbc.url&#125;&quot;)
    private String url;

    @Value(&quot;$&#123;jdbc.username&#125;&quot;)
    private String username;

    @Value(&quot;$&#123;jdbc.password&#125;&quot;)
    private String password;

    @Bean
    public DataSource dataSource() &#123;
        return new DriverManagerDataSource(url, username, password);
    &#125;
&#125;
</code></pre>
<pre><code>properties-config.xml
&lt;beans&gt;
    &lt;context:property-placeholder location=&quot;classpath:/com/acme/jdbc.properties&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
</code></pre>
<pre><code>public static void main(String[] args) &#123;
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
&#125;
</code></pre>
<h3 id="1-13-环境抽象"><a href="#1-13-环境抽象" class="headerlink" title="1.13. 环境抽象"></a>1.13. 环境抽象</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/Environment.html">环境</a>接口是集成在容器中的抽象，它为 application 环境的两个 key 方面建模：<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles">profiles</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction">properties</a>。</p>
<p>profile 是 bean 定义的命名逻辑 group，仅当给定的 profile 为 active 时才向容器注册。 Beans 可以分配给 profile，无论是用 XML 定义还是用 annotations 定义。与 profiles 相关的<code>Environment</code> object 的作用是确定哪些 profiles(如果有)当前是 active，以及哪些 profiles(如果有)默认情况下应该 active。</p>
<p>Properties 在几乎所有 applications 中都发挥着重要作用，可能来自各种来源：properties files，JVM 系统 properties，系统环境变量，JNDI，servlet context 参数，ad-hoc <code>Properties</code> objects，<code>Map</code>objects 等等。与 properties 相关的<code>Environment</code> object 的作用是为用户提供方便的服务接口，用于配置 property 源和从中解析 properties。</p>
<h4 id="1-13-1-Bean-定义-Profiles"><a href="#1-13-1-Bean-定义-Profiles" class="headerlink" title="1.13.1. Bean 定义 Profiles"></a>1.13.1. Bean 定义 Profiles</h4><p>Bean 定义 profiles 在核心容器中提供了一种机制，允许在不同的环境中注册不同的 beans。 “环境”这个词对不同的用户来说意味着不同的东西，这个 feature 可以帮助许多用例，包括：</p>
<ul>
<li>在 QA 或 production 中，在开发中使用 in-memory 数据源而不是从 JNDI 查找相同的数据源。</li>
<li>仅在将 application 部署到 performance 环境时注册监视基础结构。</li>
<li>为客户 A 和客户 B 部署注册 beans 的自定义 implementations。</li>
</ul>
<p>考虑一个需要<code>DataSource</code>的实际 application 中的第一个用例。在测试环境中，configuration 可能类似于以下内容：</p>
<pre><code>@Bean
public DataSource dataSource() &#123;
    return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.HSQL)
        .addScript(&quot;my-schema.sql&quot;)
        .addScript(&quot;my-test-data.sql&quot;)
        .build();
&#125;
</code></pre>
<p>现在考虑如何将此 application 部署到 QA 或 production 环境中，假设 application 的数据源已在 production application 服务器的 JNDI 目录中注册。我们的<code>dataSource</code> bean 现在看起来如下：</p>
<pre><code>@Bean(destroyMethod=&quot;&quot;)
public DataSource dataSource() throws Exception &#123;
    Context ctx = new InitialContext();
    return (DataSource) ctx.lookup(&quot;java:comp/env/jdbc/datasource&quot;);
&#125;
</code></pre>
<p>问题是如何根据当前环境在使用这两种变体之间切换。在 time 时，Spring 用户已经设计了许多方法来完成这项工作，通常依赖于系统环境变量和包含<code>$&#123;placeholder&#125;</code>标记的 XML <code>&lt;import/&gt;</code> statements 的组合，这些标记根据环境变量的 value 解析为正确的 configuration 文件路径。 Bean 定义 profiles 是一个核心容器 feature，它提供了解决此问题的方法。</p>
<p>如果我们概括前面 environment-specific bean 定义的 example 中显示的用例，我们最终需要在某些上下文中注册某些 bean 定义，但在其他上下文中则不需要。你可以说你想在情况 A 中注册某个 profile 的 bean 定义，在情况 B 中注册一个不同的 profile。我们首先更新我们的 configuration 以反映这种需要。</p>
<h5 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用 @Profile"></a>使用 @Profile</h5><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Profile.html">@Profile</a> annotation 允许您指示当一个或多个指定的 profiles 为 active 时，component 符合注册条件。使用我们之前的 example，我们可以 rewrite <code>dataSource</code> configuration，如下所示：</p>
<pre><code>@Configuration
@Profile(&quot;development&quot;)
public class StandaloneDataConfig &#123;

    @Bean
    public DataSource dataSource() &#123;
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .addScript(&quot;classpath:com/bank/config/sql/test-data.sql&quot;)
            .build();
    &#125;
&#125;
</code></pre>
<pre><code>@Configuration
@Profile(&quot;production&quot;)
public class JndiDataConfig &#123;

    @Bean(destroyMethod=&quot;&quot;)
    public DataSource dataSource() throws Exception &#123;
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup(&quot;java:comp/env/jdbc/datasource&quot;);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>如前所述，使用<code>@Bean</code>方法，您通常选择使用编程 JNDI 查找，使用 Spring 的<code>JndiTemplate</code>/<code>JndiLocatorDelegate</code>帮助器或前面显示的直接 JNDI <code>InitialContext</code>用法但不使用<code>JndiObjectFactoryBean</code>变体，这会强制您将 return 类型声明为<code>FactoryBean</code>型。</p>
</blockquote>
<p>profile string 可能包含一个简单的 profile name(用于 example，<code>production</code>)或一个 profile 表达式。 profile 表达式允许表达更复杂的 profile 逻辑(对于 example，<code>production &amp; us-east</code>)。 profile 表达式支持以下 operators：</p>
<ul>
<li><code>!</code>：profile 的逻辑“not”</li>
<li><code>&amp;</code>：profiles 的逻辑“和”</li>
<li><code>|</code>：profiles 的逻辑“或”</li>
</ul>
<blockquote>
<p>如果不使用括号，则无法混合<code>&amp;</code>和<code>|</code> 运算符。对于 example，<code>production &amp; us-east | eu-central</code>不是有效的表达式。它必须表示为<code>production &amp; (us-east | eu-central)</code>。</p>
</blockquote>
<p>您可以使用<code>@Profile</code>作为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-meta-annotations">meta-annotation</a>来创建自定义组合注释。以下 example 定义了一个自定义<code>@Production</code> 注释，您可以将其用作<code>@Profile(&quot;production&quot;)</code>的 drop-in 替换：</p>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Profile(&quot;production&quot;)
public @interface Production &#123;
&#125;
</code></pre>
<blockquote>
<p>如果<code>@Configuration</code> class 标记为<code>@Profile</code>，则除非一个或多个指定的 profiles 为 active，否则将绕过与该 class 关联的所有<code>@Bean</code>方法和<code>@Import</code> 注释。如果<code>@Component</code>或<code>@Configuration</code> class 标有<code>@Profile(&#123;&quot;p1&quot;, &quot;p2&quot;&#125;)</code>，则除非已激活 profiles’p1’或’p2’，否则不会注册或处理该 class。如果给定的 profile 以 NOT operator(<code>!</code>)作为前缀，则仅当 profile 不是 active 时才会注册带注释的元素。例如，给定<code>@Profile(&#123;&quot;p1&quot;, &quot;!p2&quot;&#125;)</code>，如果 profile’p1’为 active 或 profile’p2’不是 active，则会发生注册。</p>
</blockquote>
<p><code>@Profile</code>也可以在 level 方法中声明，只包含 configuration class 的一个特定 bean(对于 example，对于特定 bean 的替代变体)，如下面的 example 所示：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean(&quot;dataSource&quot;)
    @Profile(&quot;development&quot;) (1)
    public DataSource standaloneDataSource() &#123;
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .addScript(&quot;classpath:com/bank/config/sql/test-data.sql&quot;)
            .build();
    &#125;

    @Bean(&quot;dataSource&quot;)
    @Profile(&quot;production&quot;) (2)
    public DataSource jndiDataSource() throws Exception &#123;
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup(&quot;java:comp/env/jdbc/datasource&quot;);
    &#125;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>standaloneDataSource</code>方法仅在<code>development</code> profile 中可用。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><code>jndiDataSource</code>方法仅在<code>production</code> profile 中可用。</td>
</tr>
</tbody></table>
<blockquote>
<p>使用<code>@Profile</code> on <code>@Bean</code>方法时，可能会应用特殊方案：对于相同 Java 方法 name 的重载<code>@Bean</code>方法(类似于构造函数重载)，需要在所有重载方法上一致地声明<code>@Profile</code>条件。如果条件不一致，则只有重载方法中第一个声明的条件才重要。因此，<code>@Profile</code>不能用于选择具有特定参数签名的重载方法而不是另一个。在创建 time 时，Spring 的构造函数解析算法遵循同一 bean 的所有工厂方法之间的分辨率。</p>
</blockquote>
<p>如果要使用不同的 profile 条件定义备用 beans，请使用<code>@Bean</code> name 属性指向相同 bean name 的不同 Java 方法名称，如前面的 example 所示。如果参数签名都是相同的(对于 example，所有变体都有 no-arg 工厂方法)，这是首先在有效的 Java class 中表示这种排列的唯一方法(因为只有一种方法可以一个特定的 name 和参数签名)。</p>
<h5 id="XML-Bean-定义-Profiles"><a href="#XML-Bean-定义-Profiles" class="headerlink" title="XML Bean 定义 Profiles"></a>XML Bean 定义 Profiles</h5><p>XML 对应物是<code>&lt;beans&gt;</code>元素的<code>profile</code>属性。我们之前的 sample configuration 可以在两个 XML files 中重写，如下所示：</p>
<pre><code>&lt;beans profile=&quot;development&quot;
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
    &lt;/jdbc:embedded-database&gt;
&lt;/beans&gt;
</code></pre>
<pre><code>&lt;beans profile=&quot;production&quot;
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>也可以避免在同一文件中拆分和嵌套<code>&lt;beans/&gt;</code>元素，如下面的 example 所示：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile=&quot;development&quot;&gt;
        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile=&quot;production&quot;&gt;
        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
    &lt;/beans&gt;
&lt;/beans&gt;
</code></pre>
<p><code>spring-bean.xsd</code>已被约束为仅允许此类元素作为文件中的最后一个元素。这应该有助于提供灵活性，而不会在 XML files 中引起混乱。</p>
<blockquote>
<p>XML 副本不支持前面描述的 profile 表达式。但是，可以通过使用<code>!</code> operator 来否定 profile。也可以通过嵌套 profiles 来应用逻辑“和”，如下面的 example 所示：</p>
</blockquote>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile=&quot;production&quot;&gt;
        &lt;beans profile=&quot;us-east&quot;&gt;
            &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
        &lt;/beans&gt;
    &lt;/beans&gt;
&lt;/beans&gt;
</code></pre>
<p>在前面的 example 中，如果<code>production</code>和<code>us-east</code> profiles 都是 active，则会公开<code>dataSource</code> bean。</p>
<h5 id="激活-Profile"><a href="#激活-Profile" class="headerlink" title="激活 Profile"></a>激活 Profile</h5><p>现在我们已经更新了 configuration，我们仍然需要指示 Spring profile 是 active。如果我们现在开始使用 sample application，我们会看到抛出<code>NoSuchBeanDefinitionException</code>，因为容器找不到名为<code>dataSource</code>的 Spring bean。</p>
<p>激活 profile 可以通过多种方式完成，但最直接的方法是以编程方式对<code>Environment</code> API 进行编程，这可以通过<code>ApplicationContext</code>获得。以下 example 显示了如何执行此操作：</p>
<pre><code>AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
</code></pre>
<p>此外，您还可以通过<code>spring.profiles.active</code> property 声明性地激活 profile，这可以通过系统环境变量，<code>web.xml</code>中的 JVM 系统 properties，servlet context 参数指定，甚至可以作为 JNDI 中的条目指定(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction">PropertySource 抽象</a>)。在 integration 测试中，可以使用<code>spring-test</code>模块中的<code>@ActiveProfiles</code> annotation 声明 active profiles(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#testcontext-ctx-management-env-profiles">Context configuration with environment profiles</a>)。</p>
<p>请注意，profiles 不是“either-or”命题。您可以一次激活多个 profiles。在编程方面，您可以为<code>setActiveProfiles()</code>方法提供多个 profile 名称，该方法接受<code>String…</code> varargs。以下 example 激活多个 profiles：</p>
<pre><code>ctx.getEnvironment().setActiveProfiles(&quot;profile1&quot;, &quot;profile2&quot;);
</code></pre>
<p>声明性地，<code>spring.profiles.active</code>可以接受 comma-separated 列表的 profile 名称，如下面的 example 所示：</p>
<pre><code>-Dspring.profiles.active=&quot;profile1,profile2&quot;
</code></pre>
<h5 id="默认-Profile"><a href="#默认-Profile" class="headerlink" title="默认 Profile"></a>默认 Profile</h5><p>默认的 profile 表示默认启用的 profile。考虑以下 example：</p>
<pre><code>@Configuration
@Profile(&quot;default&quot;)
public class DefaultDataConfig &#123;

    @Bean
    public DataSource dataSource() &#123;
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .build();
    &#125;
&#125;
</code></pre>
<p>如果没有 profile 是 active，则创建<code>dataSource</code>。您可以将此视为一种为一个或多个 beans 提供默认定义的方法。如果启用了任何 profile，则默认的 profile 不适用。</p>
<p>您可以使用<code>Environment</code>上的<code>setDefaultProfiles()</code>或使用<code>spring.profiles.default</code> property 声明性地更改默认 profile 的 name。</p>
<h4 id="1-13-2-PropertySource-抽象"><a href="#1-13-2-PropertySource-抽象" class="headerlink" title="1.13.2. PropertySource 抽象"></a>1.13.2. PropertySource 抽象</h4><p>Spring 的<code>Environment</code>抽象提供了 property 源的可配置层次结构上的搜索操作。请考虑以下列表：</p>
<pre><code>ApplicationContext ctx = new GenericApplicationContext();
Environment env = ctx.getEnvironment();
boolean containsMyProperty = env.containsProperty(&quot;my-property&quot;);
System.out.println(&quot;Does my environment contain the &#39;my-property&#39; property? &quot; + containsMyProperty);
</code></pre>
<p>在前面的代码片段中，我们看到 high-level 方式询问 Spring 是否为当前环境定义了<code>my-property</code> property。要回答这个问题，<code>Environment</code> object 会对一组<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html">PropertySource</a> objects 执行搜索。 <code>PropertySource</code>是对 key-value 对的任何源的简单抽象，Spring 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html">StandardEnvironment</a>配置有两个 PropertySource objects - 一个表示 JVM 系统 properties(<code>System.getProperties()</code>)的集合，另一个表示系统环境变量集(<code>System.getenv()</code>)。</p>
<blockquote>
<p>这些默认的 property 源存在于<code>StandardEnvironment</code>中，用于独立的 applications。 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html">StandardServletEnvironment</a>填充了其他默认的 property 源，包括 servlet config 和 servlet context 参数。它可以选择启用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jndi/JndiPropertySource.html">JndiPropertySource</a>。有关详细信息，请参阅 javadoc。</p>
</blockquote>
<p>具体来说，当您使用<code>StandardEnvironment</code>时，如果在运行时存在<code>my-property</code> system property 或<code>my-propertyi</code>环境变量，则对<code>env.containsProperty(&quot;my-property&quot;)</code>的调用将返回 true。</p>
<blockquote>
<p>执行的搜索是分层的。默认情况下，system properties 优先于环境变量。因此，如果在调用<code>env.getProperty(&quot;my-property&quot;)</code>期间恰好在两个位置都设置了<code>my-property</code> property，则系统 property value 将“获胜”并返回。请注意，property 值未合并，而是由前面的条目完全覆盖。</p>
</blockquote>
<p>对于 common <code>StandardServletEnvironment</code>，完整层次结构如下，顶部有 highest-precedence 个条目：</p>
<ul>
<li>ServletConfig 参数(如果适用 - 对于 example，如果是<code>DispatcherServlet</code> context)</li>
<li>ServletContext 参数(web.xml context-param 条目)</li>
<li>JNDI 环境变量(<code>java:comp/env/</code>条目)</li>
<li>JVM 系统 properties(<code>-D</code> command-line arguments)</li>
<li>JVM 系统环境(操作系统环境变量)</li>
</ul>
<p>最重要的是，整个机制是可配置的。也许您有一个自定义的 properties 源要集成到此搜索中。为此，请实现并实例化您自己的<code>PropertySource</code>并将其添加到当前<code>Environment</code>的<code>PropertySources</code>集合中。以下 example 显示了如何执行此操作：</p>
<pre><code>ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());
</code></pre>
<p>在前面的 code 中，<code>MyPropertySource</code>在搜索中添加了最高优先级。如果它包含<code>my-property</code> property，则检测并返回 property，以支持任何其他<code>PropertySource</code>中的任何<code>my-property</code> property。 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/MutablePropertySources.html">MutablePropertySources</a> API 公开了许多方法，允许精确操作 property 源集。</p>
<h4 id="1-13-3-使用-PropertySource"><a href="#1-13-3-使用-PropertySource" class="headerlink" title="1.13.3. 使用 @PropertySource"></a>1.13.3. 使用 @PropertySource</h4><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html">@PropertySource</a> annotation 提供了一种方便的声明式机制，用于将<code>PropertySource</code>添加到 Spring 的<code>Environment</code>。</p>
<p>给定一个名为<code>app.properties</code>的文件，其中包含 key-value 对<code>testbean.name=myTestBean</code>，以下<code>@Configuration</code> class 使用<code>@PropertySource</code>，以便调用<code>testBean.getName()</code>返回<code>myTestBean</code>：</p>
<pre><code>@Configuration
@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)
public class AppConfig &#123;

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() &#123;
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty(&quot;testbean.name&quot;));
        return testBean;
    &#125;
&#125;
</code></pre>
<p><code>@PropertySource</code>资源位置中存在的任何<code>$&#123;…&#125;</code>占位符将根据已针对环境注册的 property 源集合进行解析，如以下 example 所示：</p>
<pre><code>@Configuration
@PropertySource(&quot;classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties&quot;)
public class AppConfig &#123;

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() &#123;
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty(&quot;testbean.name&quot;));
        return testBean;
    &#125;
&#125;
</code></pre>
<p>假设<code>my.placeholder</code>存在于已注册的 property 源之一中(对于 example，系统 properties 或环境变量)，占位符将解析为相应的 value。如果不是，则<code>default/path</code>用作默认值。如果未指定缺省值且无法解析 property，则抛出<code>IllegalArgumentException</code>。</p>
<blockquote>
<p>根据 Java 8 惯例，<code>@PropertySource</code> annotation 是可重复的。但是，所有这些<code>@PropertySource</code> 注解都需要在同一 level 中声明，可以直接在 configuration class 上声明，也可以在同一个 customannotation 中声明为 meta-annotations。不建议混合使用直接注释和 meta-annotations，因为直接注释有效地覆盖 meta-annotations。</p>
</blockquote>
<h4 id="1-13-4-Statements-中的占位符解析"><a href="#1-13-4-Statements-中的占位符解析" class="headerlink" title="1.13.4. Statements 中的占位符解析"></a>1.13.4. Statements 中的占位符解析</h4><p>从历史上看，元素中占位符的 value 只能针对 JVM 系统 properties 或环境变量进行解析。这已不再是这种情况。因为<code>Environment</code>抽象集成在整个容器中，所以很容易通过它来解析占位符。这意味着您可以以任何您喜欢的方式配置分辨率 process。您可以更改搜索系统 properties 和环境变量的优先级，或者完全删除它们。您也可以根据需要将自己的 property 源添加到组合中。</p>
<p>具体而言，无论<code>customer</code> property 的定义位置如何，以下语句都可以正常工作，因为它在<code>Environment</code>中可用 long：</p>
<pre><code>&lt;beans&gt;
    &lt;import resource=&quot;com/bank/service/$&#123;customer&#125;-config.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="1-14-注册-LoadTimeWeaver"><a href="#1-14-注册-LoadTimeWeaver" class="headerlink" title="1.14. 注册 LoadTimeWeaver"></a>1.14. 注册 LoadTimeWeaver</h3><p>_Sp用于在 classes 加载到 Java 虚拟机(JVM)时动态转换 class。</p>
<p>要启用 load-time 编织，您可以将<code>@EnableLoadTimeWeaving</code>添加到一个<code>@Configuration</code> classes 中，如下面的 example 所示：</p>
<pre><code>@Configuration
@EnableLoadTimeWeaving
public class AppConfig &#123;
&#125;
</code></pre>
<p>或者，对于 XML configuration，您可以使用<code>context:load-time-weaver</code>元素：</p>
<pre><code>&lt;beans&gt;
    &lt;context:load-time-weaver/&gt;
&lt;/beans&gt;
</code></pre>
<p>一旦为<code>ApplicationContext</code>配置，该<code>ApplicationContext</code>中的任何 bean 都可以实现<code>LoadTimeWeaverAware</code>，从而接收 load-time weaver 实例的 reference。这与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa">Spring 的 JPA 支持</a>结合使用特别有用，其中 load-time 编织可能是 JPA class 转换所必需的。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html">LocalContainerEntityManagerFactoryBean</a> javadoc。有关 AspectJ load-time 编织的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">Load-time 在 Spring Framework 中使用 AspectJ 进行编织</a>。</p>
<h3 id="1-15-ApplicationContext-的附加功能"><a href="#1-15-ApplicationContext-的附加功能" class="headerlink" title="1.15. ApplicationContext 的附加功能"></a>1.15. ApplicationContext 的附加功能</h3><p>正如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans">章节介绍</a>中所讨论的，<code>org.springframework.beans.factory</code>包提供了管理和操作 beans 的基本功能，包括以编程方式。除了扩展其他接口以提供更多 application framework-oriented 样式的附加功能外，<code>org.springframework.context</code>包还添加了扩展<code>BeanFactory</code>接口的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html">ApplicationContext</a>接口。许多人以完全声明的方式使用<code>ApplicationContext</code>，甚至不以编程方式创建它，而是依靠支持 class(如<code>ContextLoader</code>)来自动实例化<code>ApplicationContext</code>作为 Java EE web application 的正常启动 process 的一部分。</p>
<p>要以更多 framework-oriented 样式增强<code>BeanFactory</code>功能，context 包还提供以下功能：</p>
<ul>
<li>通过<code>MessageSource</code>接口访问 i18n-style 中的消息。</li>
<li>通过<code>ResourceLoader</code>接口访问 URL 和 files 等资源。</li>
<li>Event 发布，即通过使用<code>ApplicationEventPublisher</code>接口实现<code>ApplicationListener</code>接口的 beans。</li>
<li>Loading 多个(分层)上下文，让每个上下文通过<code>HierarchicalBeanFactory</code>接口聚焦在一个特定层上，例如 application 的 web 层。</li>
</ul>
<h4 id="1-15-1-使用-MessageSource-进行国际化"><a href="#1-15-1-使用-MessageSource-进行国际化" class="headerlink" title="1.15.1. 使用 MessageSource 进行国际化"></a>1.15.1. 使用 MessageSource 进行国际化</h4><p><code>ApplicationContext</code>接口扩展了一个名为<code>MessageSource</code>的接口，因此提供了国际化(“i18n”)功能。 Spring 还提供<code>HierarchicalMessageSource</code>接口，可以分层次地解析消息。这些接口共同提供了 Spring 效果消息解析的基础。这些接口上定义的方法包括：</p>
<ul>
<li><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>：用于从<code>MessageSource</code>检索消息的基本方法。如果未找到指定 locale 的消息，则使用默认消息。传入的任何 arguments 都使用标准 library 提供的<code>MessageFormat</code>功能成为替换值。</li>
<li><code>String getMessage(String code, Object[] args, Locale loc)</code>：与前一个方法基本相同，但有一点不同：无法指定默认消息。如果找不到该消息，则抛出<code>NoSuchMessageException</code>。</li>
<li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：前面方法中使用的所有 properties 也包装在一个名为<code>MessageSourceResolvable</code>的 class 中，您可以使用此方法。</li>
</ul>
<p>加载<code>ApplicationContext</code>时，它会自动搜索 context 中定义的<code>MessageSource</code> bean。 bean 必须具有 name <code>messageSource</code>。如果找到这样的 bean，则将前面方法的所有 calls 委托给消息源。如果没有找到消息源，则<code>ApplicationContext</code>会尝试查找包含 bean 且具有相同 name 的 parent。如果是，则使用 bean 作为<code>MessageSource</code>。如果<code>ApplicationContext</code>找不到任何消息源，则在 order 中实例化一个空<code>DelegatingMessageSource</code>，以便能够接受 calls 到上面定义的方法。</p>
<p>Spring 提供两个<code>MessageSource</code> implementations，<code>ResourceBundleMessageSource</code>和<code>StaticMessageSource</code>。两者都在 order 中实现<code>HierarchicalMessageSource</code>来执行嵌套消息传递。 <code>StaticMessageSource</code>很少使用，但提供了以编程方式向源添加消息。以下 example 显示<code>ResourceBundleMessageSource</code>：</p>
<pre><code>&lt;beans&gt;
    &lt;bean id=&quot;messageSource&quot;
            class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt;
        &lt;property name=&quot;basenames&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;format&lt;/value&gt;
                &lt;value&gt;exceptions&lt;/value&gt;
                &lt;value&gt;windows&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>example 假定您在 classpath 中定义了三个名为<code>format</code>，<code>exceptions</code>和<code>windows</code>的资源包。任何解决消息的请求都以 JDK-standard 方式处理，通过<code>ResourceBundle</code> objects 解析消息。出于 example 的目的，假设上述两个资源包 files 的内容如下：</p>
<pre><code># in format.properties
message=Alligators rock!
</code></pre>
<pre><code># in exceptions.properties
argument.required=The &#123;0&#125; argument is required.
</code></pre>
<p>下一个 example 显示了一个执行<code>MessageSource</code>功能的程序。请记住，所有<code>ApplicationContext</code> __mplement 都是<code>MessageSource</code> __mplementation，因此可以强制转换为<code>MessageSource</code>接口。</p>
<pre><code>public static void main(String[] args) &#123;
    MessageSource resources = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    String message = resources.getMessage(&quot;message&quot;, null, &quot;Default&quot;, null);
    System.out.println(message);
&#125;
</code></pre>
<p>上述程序产生的结果如下：</p>
<pre><code>Alligators rock!
</code></pre>
<p>总而言之，<code>MessageSource</code>在名为<code>beans.xml</code>的文件中定义，该文件存在于 classpath 的根目录中。 <code>messageSource</code> bean 定义通过<code>basenames</code> property 引用了许多资源包。在列表中传递给<code>basenames</code> property 的三个 files 在 classpath 的根目录下作为 files 存在，分别称为<code>format.properties</code>，<code>exceptions.properties</code>和<code>windows.properties</code>。</p>
<p>下一个 example 显示传递给消息查找的 arguments。这些 arguments 转换为<code>String</code> objects 并插入到查找消息中的占位符中。</p>
<pre><code>&lt;beans&gt;

    &lt;!-- this MessageSource is being used in a web application --&gt;
    &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt;
        &lt;property name=&quot;basename&quot; value=&quot;exceptions&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- lets inject the above MessageSource into this POJO --&gt;
    &lt;bean id=&quot;example&quot; class=&quot;com.something.Example&quot;&gt;
        &lt;property name=&quot;messages&quot; ref=&quot;messageSource&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<pre><code>public class Example &#123;

    private MessageSource messages;

    public void setMessages(MessageSource messages) &#123;
        this.messages = messages;
    &#125;

    public void execute() &#123;
        String message = this.messages.getMessage(&quot;argument.required&quot;,
            new Object [] &#123;&quot;userDao&quot;&#125;, &quot;Required&quot;, null);
        System.out.println(message);
    &#125;
&#125;
</code></pre>
<p>调用<code>execute()</code>方法得到的结果如下：</p>
<pre><code>The userDao argument is required.
</code></pre>
<p>关于国际化(“i18n”)，Spring 的各种<code>MessageSource</code> __mplement 遵循与标准 JDK <code>ResourceBundle</code>相同的 locale 解决方案和回退规则。简而言之，继续前面定义的 example <code>messageSource</code>，如果要解析针对 British(<code>en-GB</code>)locale 的消息，您将分别创建名为<code>format_en_GB.properties</code>，<code>exceptions_en_GB.properties</code>和<code>windows_en_GB.properties</code>的 files。</p>
<p>通常，locale 解析由 application 的周围环境管理。在以下 example 中，手动指定解析(英国)消息的 locale：</p>
<pre><code># in exceptions_en_GB.properties
argument.required=Ebagum lad, the &#123;0&#125; argument is required, I say, required.
</code></pre>
<pre><code>public static void main(final String[] args) &#123;
    MessageSource resources = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    String message = resources.getMessage(&quot;argument.required&quot;,
        new Object [] &#123;&quot;userDao&quot;&#125;, &quot;Required&quot;, Locale.UK);
    System.out.println(message);
&#125;
</code></pre>
<p>上述程序 running 的结果输出如下：</p>
<pre><code>Ebagum lad, the &#39;userDao&#39; argument is required, I say, required.
</code></pre>
<p>您还可以使用<code>MessageSourceAware</code>接口获取已定义的任何<code>MessageSource</code>的 reference。实现<code>MessageSourceAware</code>接口的<code>ApplicationContext</code>中定义的任何 bean 在创建和配置 bean 时都会注入 application context 的<code>MessageSource</code>。</p>
<blockquote>
<p>作为<code>ResourceBundleMessageSource</code>的替代，Spring 提供<code>ReloadableResourceBundleMessageSource</code> class。此变体支持相同的包文件格式，但比基于标准 JDK 的<code>ResourceBundleMessageSource</code> implementation 更灵活。特别是，它允许从任何 Spring 资源位置(不仅来自 classpath)读取 files，并支持 bundle property files 的热重新加载(同时有效地在它们之间缓存它们)。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html">ReloadableResourceBundleMessageSource</a> javadoc。</p>
</blockquote>
<h4 id="1-15-2-标准和自定义事件"><a href="#1-15-2-标准和自定义事件" class="headerlink" title="1.15.2. 标准和自定义事件"></a>1.15.2. 标准和自定义事件</h4><p>通过<code>ApplicationEvent</code> class 和<code>ApplicationListener</code>接口提供<code>ApplicationContext</code>中的 Event 处理。如果实现<code>ApplicationListener</code>接口的 bean 被部署到 context 中，那么每 time被发布到<code>ApplicationContext</code>，bean 被通知。从本质上讲，这是标准的 Observer 设计 pattern。</p>
<blockquote>
<p>从 Spring 4.2 开始，event 基础结构得到了显着改进，并且提供了<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#context-functionality-events-annotation">annotation-based model</a>以及发布任意 event 的能力(即，不一定从<code>ApplicationEvent</code>延伸的 object)。当这样的 object 发布时，我们将它包装在 event 中。</p>
</blockquote>
<p>以下 table 描述了 Spring 提供的标准 events：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ContextRefreshedEvent</code></td>
<td>初始化或刷新<code>ApplicationContext</code>时发布(对于 example，通过<code>ConfigurableApplicationContext</code>接口使用<code>refresh()</code>方法)。这里，“初始化”意味着所有 beans 都被加载，post-processor beans 被检测并激活，单例是 pre-instantiated，<code>ApplicationContext</code>object 可以使用了。如果 context 尚未关闭_long，则可以多次触发刷新，前提是所选的<code>ApplicationContext</code>实际上支持这种“热”刷新。对于 example，<code>XmlWebApplicationContext</code>支持热刷新，但<code>GenericApplicationContext</code>不支持。</td>
</tr>
<tr>
<td><code>ContextStartedEvent</code></td>
<td>通过在<code>ConfigurableApplicationContext</code>接口上使用<code>start()</code>方法启动<code>ApplicationContext</code>时发布。这里，“已启动”意味着所有<code>Lifecycle</code> beans 都会收到明确的启动信号。通常，此信号用于在显式停止后重新启动 beans，但它也可用于启动尚未为自动启动配置的组件(对于 example，尚未在初始化时启动的组件)。</td>
</tr>
<tr>
<td><code>ContextStoppedEvent</code></td>
<td>通过在<code>ConfigurableApplicationContext</code>接口上使用<code>stop()</code>方法停止<code>ApplicationContext</code>时发布。这里，“停止”意味着所有<code>Lifecycle</code> beans 都会收到明确的停止信号。可以通过<code>start()</code>调用重新启动已停止的 context。</td>
</tr>
<tr>
<td><code>ContextClosedEvent</code></td>
<td>通过在<code>ConfigurableApplicationContext</code>接口上使用<code>close()</code>方法关闭<code>ApplicationContext</code>时发布。在这里，“关闭”意味着所有 singleton beans 都被销毁。封闭的 context 到达其生命的终点。它无法刷新或重新启动。</td>
</tr>
<tr>
<td><code>RequestHandledEvent</code></td>
<td>web-specific event 告诉所有 beans 已经为 HTTP 请求提供服务。请求完成后发布此 event。此 event 仅适用于使用 Spring 的<code>DispatcherServlet</code>的 web applications。</td>
</tr>
</tbody></table>
<p>您还可以创建和发布自己的自定义 events。以下 example 显示了一个简单的 class，它扩展了 Spring 的<code>ApplicationEvent</code> base class：</p>
<pre><code>public class BlackListEvent extends ApplicationEvent &#123;

    private final String address;
    private final String content;

    public BlackListEvent(Object source, String address, String content) &#123;
        super(source);
        this.address = address;
        this.content = content;
    &#125;

    // accessor and other methods...
&#125;
</code></pre>
<p>要发布自定义<code>ApplicationEvent</code>，请在<code>ApplicationEventPublisher</code>上调用<code>publishEvent()</code>方法。通常，这是通过 creating class 实现<code>ApplicationEventPublisherAware</code>并将其注册为 Spring bean 来完成的。以下 example 显示了这样一个 class：</p>
<pre><code>public class EmailService implements ApplicationEventPublisherAware &#123;

    private List&lt;String&gt; blackList;
    private ApplicationEventPublisher publisher;

    public void setBlackList(List&lt;String&gt; blackList) &#123;
        this.blackList = blackList;
    &#125;

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) &#123;
        this.publisher = publisher;
    &#125;

    public void sendEmail(String address, String content) &#123;
        if (blackList.contains(address)) &#123;
            publisher.publishEvent(new BlackListEvent(this, address, content));
            return;
        &#125;
        // send email...
    &#125;
&#125;
</code></pre>
<p>在 configuration time，Spring 容器检测<code>EmailService</code>实现<code>ApplicationEventPublisherAware</code>并自动 calls <code>setApplicationEventPublisher()</code>。实际上，传入的参数是 Spring 容器本身。您正在通过<code>ApplicationEventPublisher</code>接口与 application context 进行交互。</p>
<p>要接收自定义<code>ApplicationEvent</code>，您可以创建一个实现<code>ApplicationListener</code>的 class 并将其注册为 Spring bean。以下 example 显示了这样一个 class：</p>
<pre><code>public class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; &#123;

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) &#123;
        this.notificationAddress = notificationAddress;
    &#125;

    public void onApplicationEvent(BlackListEvent event) &#123;
        // notify appropriate parties via notificationAddress...
    &#125;
&#125;
</code></pre>
<p>请注意，<code>ApplicationListener</code>通常使用自定义 event 的类型进行参数化(前面的 example 中为<code>BlackListEvent</code>)。这意味着<code>onApplicationEvent()</code>方法可以保持 type-safe，从而避免任何向下转换的需要。您可以根据需要注册尽可能多的 event listeners，但请注意，默认情况下，event listeners 会同步接收 events。这意味着<code>publishEvent()</code>方法会阻塞，直到所有 listener 都已完成 event 的处理。这种同步和 single-threaded 方法的一个优点是，当 listener 接收到 event 时，如果 transaction context 可用，它将在发布者的 transaction context 内运行。如果需要另一个 event 发布策略，请参阅 Spring 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html">ApplicationEventMulticaster</a>接口的 javadoc。</p>
<p>以下 example 显示了用于注册和配置上述每个 classes 的 bean 定义：</p>
<pre><code>&lt;bean id=&quot;emailService&quot; class=&quot;example.EmailService&quot;&gt;
    &lt;property name=&quot;blackList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;blackListNotifier&quot; class=&quot;example.BlackListNotifier&quot;&gt;
    &lt;property name=&quot;notificationAddress&quot; value=&quot;[emailprotected]&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>总而言之，当调用<code>emailService</code> bean 的<code>sendEmail()</code>方法时，如果有任何应列入黑名单的电子邮件消息，则会发布类型为<code>BlackListEvent</code>的自定义 event。 <code>blackListNotifier</code> bean 注册为<code>ApplicationListener</code>并接收<code>BlackListEvent</code>，此时它可以通知相关方。</p>
<blockquote>
<p>Spring 的事件机制是为在同一 application context 中 Spring beans 之间的简单通信而设计的。但是，对于更复杂的企业集成需求，单独维护的<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-integration/">Spring Integration</a>项目为构建 well-known Spring 编程模型的 building 轻量级<a target="_blank" rel="noopener" href="http://www.enterpriseintegrationpatterns.com/">pattern-oriented</a>，event-driven 架构提供了完全支持。</p>
</blockquote>
<h5 id="Annotation-based-Event-Listeners"><a href="#Annotation-based-Event-Listeners" class="headerlink" title="Annotation-based Event Listeners"></a>Annotation-based Event Listeners</h5><p>从 Spring 4.2 开始，您可以使用<code>EventListener</code> annotation 在托管 bean 的任何公共方法上注册 event listener。 <code>BlackListNotifier</code>可以重写如下：</p>
<pre><code>public class BlackListNotifier &#123;

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) &#123;
        this.notificationAddress = notificationAddress;
    &#125;

    @EventListener
    public void processBlackListEvent(BlackListEvent event) &#123;
        // notify appropriate parties via notificationAddress...
    &#125;
&#125;
</code></pre>
<p>方法签名再次声明它侦听的 event 类型，但是，这个 time，具有灵活的 name 并且没有实现特定的 listener 接口。 event 类型也可以通过泛型缩小为 long，因为实际 event 类型在其 implementation 层次结构中解析了泛型参数。</p>
<p>如果您的方法应该监听多个 events，或者如果您想要根据任何参数来定义它，那么也可以在 annotation 本身上指定 event 类型。以下 example 显示了如何执行此操作：</p>
<pre><code>@EventListener(&#123;ContextStartedEvent.class, ContextRefreshedEvent.class&#125;)
public void handleContextStart() &#123;
    ...
&#125;
</code></pre>
<p>还可以通过使用定义<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions">SpEL 表达</a>的 annotation 的<code>condition</code>属性来添加额外的运行时过滤，应该 match 以实际调用特定 event 的方法。</p>
<p>以下 example 显示了只有 event 的<code>content</code>属性等于<code>my-event</code>时才能重写我们的通知程序才能被调用：</p>
<pre><code>@EventListener(condition = &quot;#blEvent.content == &#39;my-event&#39;&quot;)
public void processBlackListEvent(BlackListEvent blEvent) &#123;
    // notify appropriate parties via notificationAddress...
&#125;
</code></pre>
<p>每个<code>SpEL</code>表达式都针对专用的 context 进行求值。以下 table _llist _ltext 可用于 context 的项目，以便您可以将它们用于条件 event 处理：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>地点</th>
<th>描述</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td>事件</td>
<td>root object</td>
<td>实际<code>ApplicationEvent</code>。</td>
<td><code>#root.event</code></td>
</tr>
<tr>
<td>Arguments array</td>
<td>root object</td>
<td>arguments(as array)用于调用目标。</td>
<td><code>#root.args[0]</code></td>
</tr>
<tr>
<td>参数 name</td>
<td>evaluation context</td>
<td>任何方法 arguments 的 name。如果由于某种原因，名称不可用(对于 example，因为没有调试信息)，参数名称也可在<code>#a&lt;#arg&gt;</code>下使用，其中<code>#arg</code>代表参数索引(从 0 开始)。</td>
<td><code>#blEvent</code>或<code>#a0</code>(您也可以使用<code>#p0</code>或<code>#p&lt;#arg&gt;</code>表示法作为别名)</td>
</tr>
</tbody></table>
<p>请注意，即使您的方法签名实际引用了已发布的任意 object，<code>#root.event</code>也允许您访问底层 event。</p>
<p>如果您需要发布 event 作为处理另一个 event 的结果，您可以将方法签名更改为 return 应发布的 event，如下面的 example 所示：</p>
<pre><code>@EventListener
public ListUpdateEvent handleBlackListEvent(BlackListEvent event) &#123;
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
&#125;
</code></pre>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#context-functionality-events-async">异步 listeners</a>不支持此 feature。</p>
</blockquote>
<p>这个新方法为上面的方法处理的每个<code>BlackListEvent</code>发布一个新的<code>ListUpdateEvent</code>。如果需要发布多个 events，则可以_return <code>Collection</code> events。</p>
<h5 id="异步-Listeners"><a href="#异步-Listeners" class="headerlink" title="异步 Listeners"></a>异步 Listeners</h5><p>如果希望特定的 listener 异步 process events，则可以重用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#scheduling-annotation-support-async">定期 @Async 支持</a>。以下 example 显示了如何执行此操作：</p>
<pre><code>@EventListener
@Async
public void processBlackListEvent(BlackListEvent event) &#123;
    // BlackListEvent is processed in a separate thread
&#125;
</code></pre>
<p>使用异步 events 时请注意以下限制：</p>
<ul>
<li>如果 event listener 抛出<code>Exception</code>，则它不会传播给调用者有关详细信息，请参阅<code>AsyncUncaughtExceptionHandler</code>。</li>
<li>这样的 event listener 无法发送回复。如果您需要作为处理结果发送另一个 event，inject <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html">ApplicationEventPublisher</a>手动发送 event。</li>
</ul>
<h5 id="Ordering-Listeners"><a href="#Ordering-Listeners" class="headerlink" title="Ordering Listeners"></a>Ordering Listeners</h5><p>如果需要在另一个 listener 之前调用一个 listener，可以将<code>@Order</code> annotation 添加到方法声明中，如下面的 example 所示：</p>
<pre><code>@EventListener
@Order(42)
public void processBlackListEvent(BlackListEvent event) &#123;
    // notify appropriate parties via notificationAddress...
&#125;
</code></pre>
<h5 id="Generic-Events"><a href="#Generic-Events" class="headerlink" title="Generic Events"></a>Generic Events</h5><p>您还可以使用泛型来进一步定义 event 的结构。考虑使用<code>EntityCreatedEvent&lt;T&gt;</code>，其中<code>T</code>是创建的实际实体的类型。对于 example，您可以创建以下 listener 定义以仅接收<code>EntityCreatedEvent</code>的<code>EntityCreatedEvent</code>：</p>
<pre><code>@EventListener
public void onPersonCreated(EntityCreatedEvent&lt;Person&gt; event) &#123;
    ...
&#125;
</code></pre>
<p>由于类型擦除，仅当被触发的 event 解析 event listener 过滤器的通用参数(即<code>class PersonCreatedEvent extends EntityCreatedEvent&lt;Person&gt; &#123; … &#125;</code>之类的东西)时，此方法才有效。</p>
<p>在某些情况下，如果所有 events 遵循相同的结构(如前面的 example 中的 event 的情况)，这可能会变得相当繁琐。在这种情况下，您可以实现<code>ResolvableTypeProvider</code>来指导 framework 超出运行时环境提供的范围。以下 event 显示了如何执行此操作：</p>
<pre><code>public class EntityCreatedEvent&lt;T&gt; extends ApplicationEvent implements ResolvableTypeProvider &#123;

    public EntityCreatedEvent(T entity) &#123;
        super(entity);
    &#125;

    @Override
    public ResolvableType getResolvableType() &#123;
        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
    &#125;
&#125;
</code></pre>
<blockquote>
<p>这不仅适用于<code>ApplicationEvent</code>，而且适用于您作为 event 发送的任意 object。</p>
</blockquote>
<h4 id="1-15-3-方便地访问-Low-level-资源"><a href="#1-15-3-方便地访问-Low-level-资源" class="headerlink" title="1.15.3. 方便地访问 Low-level 资源"></a>1.15.3. 方便地访问 Low-level 资源</h4><p>为了最佳地使用和理解 application 上下文，你应该熟悉 Spring 的<code>Resource</code>抽象，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources">资源</a>中所述。</p>
<p>application context 是<code>ResourceLoader</code>，可用于加载<code>Resource</code> objects。 <code>Resource</code>本质上是 JDK <code>java.net.URL</code> class 的 feature 富 version。事实上，的_implement 包装了一个<code>java.net.URL</code>的实例，如果合适的话。 <code>Resource</code>可以透明的方式从几乎任何位置获取 low-level 资源，包括 classpath，文件系统位置，任何可用标准 URL 描述的位置，以及其他一些变体。如果资源位置 string 是一个没有任何特殊前缀的简单路径，那么这些资源来自特定且适合于实际的 application context 类型。</p>
<p>您可以配置部署到 application context 中的 bean 来实现特殊的回调接口<code>ResourceLoaderAware</code>，在初始化 time 时自动回调，application context 本身作为<code>ResourceLoader</code>传入。您还可以公开<code>Resource</code>类型的 properties，以用于访问静态资源。它们像任何其他 properties 一样被注入其中。您可以将<code>Resource</code> properties 指定为简单的<code>String</code> _path 并依赖特殊的 JavaBean <code>PropertyEditor</code>(由 context 自动注册)，以便在部署 bean 时将这些文本 strings 转换为实际的<code>Resource</code> object。</p>
<p>提供给<code>ApplicationContext</code>构造函数的位置路径或_path 实际上是资源 strings，并且以简单的形式根据特定的 context implementation 进行适当处理。对于 example <code>ClassPathXmlApplicationContext</code>，将一个简单的位置路径视为 classpath 位置。您还可以使用带有特殊前缀的 location paths(resource strings)来强制从 classpath 或 URL 中加载定义，而不管实际的 context 类型如何。</p>
<h4 id="1-15-4-方便的-ApplicationContext-Instantiation-for-Web-Applications"><a href="#1-15-4-方便的-ApplicationContext-Instantiation-for-Web-Applications" class="headerlink" title="1.15.4. 方便的 ApplicationContext Instantiation for Web Applications"></a>1.15.4. 方便的 ApplicationContext Instantiation for Web Applications</h4><p>您可以使用 for example 以声明方式创建<code>ApplicationContext</code>实例。当然，您也可以使用<code>ApplicationContext</code> implementations 之一以编程方式创建<code>ApplicationContext</code>实例。</p>
<p>您可以使用<code>ContextLoaderListener</code>注册<code>ApplicationContext</code>，如下面的 example 所示：</p>
<pre><code>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<p>listener 检查<code>contextConfigLocation</code>参数。如果参数不存在，则 listener 使用<code>/WEB-INF/applicationContext.xml</code>作为默认值。当参数确实存在时，listener 使用预定义的分隔符(逗号，分号和空格)分隔<code>String</code>，并将值用作搜索 application contexts 的位置。也支持 Ant-style 路径模式。示例是<code>/WEB-INF/*Context.xml</code>(对于名称以<code>Context.xml</code>结尾且位于<code>WEB-INF</code>目录中的所有 files)和<code>/WEB-INF/**/*Context.xml</code>(对于<code>WEB-INF</code>的任何子目录中的所有此类 files)。</p>
<h4 id="1-15-5-将-Spring-ApplicationContext-部署为-Java-EE-RAR-文件"><a href="#1-15-5-将-Spring-ApplicationContext-部署为-Java-EE-RAR-文件" class="headerlink" title="1.15.5. 将 Spring ApplicationContext 部署为 Java EE RAR 文件"></a>1.15.5. 将 Spring ApplicationContext 部署为 Java EE RAR 文件</h4><p>可以将 Spring <code>ApplicationContext</code>部署为 RAR 文件，将 context 及其所有必需的 bean classes 和 library JAR 封装在 Java EE RAR 部署单元中。这相当于能够访问 Java EE 服务器工具的 stand-alone <code>ApplicationContext</code>(仅托管在 Java EE 环境中)。 RAR 部署是部署无头 WAR 文件的一种更自然的替代方案 - 实际上是一个没有任何 HTTP 入口点的 WAR 文件，仅用于在 Java EE 环境中引导 Spring <code>ApplicationContext</code>。</p>
<p>RAR 部署非常适用于不需要 HTTP 入口点但仅包含消息 endpoints 和预定作业的 application 上下文。 Beans 在这样的 context 中可以使用 application 服务器资源，例如 JTA transaction manager 和 JNDI-bound JDBC <code>DataSource</code>实例以及 JMS <code>ConnectionFactory</code>实例，并且还可以通过 Spring 的标准 transaction management 以及 JNDI 和 JMX 支持工具向平台的 JMX 服务器注册。 Application 组件也可以通过 Spring 的<code>TaskExecutor</code>抽象与 application 服务器的 JCA <code>WorkManager</code>进行交互。</p>
<p>有关 RAR 部署中涉及的 configuration 详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html">SpringContextResourceAdapter</a> class 的 javadoc。</p>
<p>对于将 Spring ApplicationContext 简单部署为 Java EE RAR 文件：</p>
<ul>
<li>将所有 application classes 打包到一个 RAR 文件(这是一个具有不同文件扩展名的标准 JAR 文件)。 .Add 所有 Library JAR 都需要进入 RAR 档案的根目录。 .Add 一个<code>META-INF/ra.xml</code>部署描述符(如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html">SpringContextResourceAdapter 的 javadoc</a>所示)和相应的 Spring XML bean 定义 file(s)(通常为 META-INF/applicationContext.xml)。</li>
<li>将生成的 RAR 文件放入 application Server 的部署目录中。</li>
</ul>
<blockquote>
<p>此类 RAR 部署单元通常为 self-contained。它们不会将组件暴露给外部世界，甚至不会暴露给同一个应用程序的其他模块。与 RAR-based <code>ApplicationContext</code>的交互通常通过与其他模块共享的 JMS 目标进行。例如，RAR-based <code>ApplicationContext</code>也可以安排一些作业或对文件系统中的新文件作出反应(或类似)。如果它需要允许来自外部的同步访问，它可以(用于 example)export RMI endpoints，它可以被同一台机器上的其他 application 模块使用。</p>
</blockquote>
<h3 id="1-16-BeanFactory"><a href="#1-16-BeanFactory" class="headerlink" title="1.16. BeanFactory"></a>1.16. BeanFactory</h3><p><code>BeanFactory</code> API 为 Spring 的 IoC 功能提供了基础。它的特定 contracts 主要用于与 Spring 和相关 third-party 框架的其他部分进行整合，其<code>DefaultListableBeanFactory</code> implementation 是 higher-level <code>GenericApplicationContext</code>容器中的 key 委托。</p>
<p><code>BeanFactory</code>和相关接口(例如<code>BeanFactoryAware</code>，<code>InitializingBean</code>，<code>DisposableBean</code>)是其他 framework 组件的重要集成点。通过不需要任何注释或甚至反射，它们允许容器与其组件之间的非常有效的交互。 Application-level beans 可以使用相同的回调接口，但通常更喜欢声明性依赖注入，通过 annotations 或通过编程 configuration。</p>
<p>请注意，核心<code>BeanFactory</code> API level 及其<code>DefaultListableBeanFactory</code> implementation 不会对 configuration 格式或要使用的任何 component annotations 进行假设。所有这些风格都通过 extensions(例如<code>XmlBeanDefinitionReader</code>和<code>AutowiredAnnotationBeanPostProcessor</code>)进入，并作为核心元数据表示在共享<code>BeanDefinition</code> objects 上运行。这就是 Spring 容器如此灵活和可扩展的本质。</p>
<h4 id="1-16-1-BeanFactory-或-ApplicationContext？"><a href="#1-16-1-BeanFactory-或-ApplicationContext？" class="headerlink" title="1.16.1. BeanFactory 或 ApplicationContext？"></a>1.16.1. BeanFactory 或 ApplicationContext？</h4><p>本节介绍<code>BeanFactory</code>和<code>ApplicationContext</code>容器级别之间的差异以及对引导的影响。</p>
<p>您应该使用<code>ApplicationContext</code>，除非您有充分的理由不这样做，<code>GenericApplicationContext</code>及其子类<code>AnnotationConfigApplicationContext</code>作为自定义引导的 common implementations。这些是 Spring 核心容器的主要入口点，适用于所有 common 目的：_loading configuration files，触发 classpath 扫描，以编程方式注册 bean 定义和带注释的 classes，以及(截至 5.0)注册功能 bean 定义。</p>
<p>因为<code>ApplicationContext</code>包含<code>BeanFactory</code>的所有功能，所以通常建议使用<code>BeanFactory</code>，除了需要完全控制 bean 处理的场景。在<code>ApplicationContext</code>(例如<code>GenericApplicationContext</code> implementation)中，按惯例检测到几种 beans(即 bean name 或 bean 类型 - 特别是 post-processors)，而普通<code>DefaultListableBeanFactory</code>与任何特殊 beans 无关。</p>
<p>对于许多扩展容器 features，例如 annotation 处理和 AOP 代理，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension-bpp">BeanPostProcessor 扩展点</a>是必不可少的。如果仅使用普通<code>DefaultListableBeanFactory</code>，则默认情况下不会检测到并激活此类 post-processors。这种情况可能会令人困惑，因为 bean configuration 没有任何问题。相反，在这种情况下，容器需要通过额外的设置完全自举。</p>
<p>以下 table lists features 由<code>BeanFactory</code>和<code>ApplicationContext</code>接口和 implementations 提供。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th><code>BeanFactory</code></th>
<th><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody><tr>
<td>Bean instantiation/wiring</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>集成生命周期管理</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>自动<code>BeanPostProcessor</code>注册</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>自动<code>BeanFactoryPostProcessor</code>注册</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>方便的<code>MessageSource</code>访问(用于内化)</td>
<td>没有</td>
<td>是</td>
</tr>
<tr>
<td>Built-in <code>ApplicationEvent</code>出版机制</td>
<td>没有</td>
<td>是</td>
</tr>
</tbody></table>
<p>要使用<code>DefaultListableBeanFactory</code>显式注册 bean post-processor，您需要以编程方式调用<code>addBeanPostProcessor</code>，如下面的 example 所示：</p>
<pre><code>DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// now start using the factory
</code></pre>
<p>要将<code>BeanFactoryPostProcessor</code>应用于普通<code>DefaultListableBeanFactory</code>，您需要调用其<code>postProcessBeanFactory</code>方法，如下面的 example 所示：</p>
<pre><code>DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(new FileSystemResource(&quot;beans.xml&quot;));

// bring in some property values from a Properties file
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource(&quot;jdbc.properties&quot;));

// now actually do the replacement
cfg.postProcessBeanFactory(factory);
</code></pre>
<p>在这两种情况下，显式注册步骤都不方便，这就是为什么各种<code>ApplicationContext</code>变体比 Spring-backed applications 中的普通<code>DefaultListableBeanFactory</code>更受欢迎，尤其是在典型企业设置中依赖<code>BeanFactoryPostProcessor</code>和<code>BeanPostProcessor</code>实例来扩展容器功能时。</p>
<blockquote>
<p><code>AnnotationConfigApplicationContext</code>已经注册了所有 common annotation post-processors，并且可以通过 configuration annotations(例如<code>@EnableTransactionManagement</code>)引入其他处理器。在 Spring 的 annotation-based configuration model 的抽象 level 中， bean post-processors 的概念变成了仅仅是内部容器细节。</p>
</blockquote>
<h2 id="2-资源"><a href="#2-资源" class="headerlink" title="2.资源"></a>2.资源</h2><p>本章介绍 Spring 如何处理资源以及如何使用 Spring 中的资源。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-introduction">介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-resource">资源接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations">Built-in 资源 Implementations</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-resourceloader">ResourceLoader</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-resourceloaderaware">ResourceLoaderAware 接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-as-dependencies">资源作为依赖关系</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-app-ctx">Application Contexts 和 Resource Paths</a></li>
</ul>
<h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1. 介绍"></a>2.1. 介绍</h3><p>遗憾的是，Java 的标准<code>java.net.URL</code> class 和各种 URL 前缀的标准处理程序不足以完全访问 low-level 资源。对于 example，没有标准化的<code>URL</code> implementation 可用于访问需要从 classpath 或相对于<code>ServletContext</code>获取的资源。虽然可以为专用的<code>URL</code>前缀注册新的处理程序(类似于<code>http:</code>等前缀的现有处理程序)，但这通常非常复杂，并且<code>URL</code>接口仍然缺少一些理想的功能，例如检查是否存在的方法指向的资源。</p>
<h3 id="2-2-资源接口"><a href="#2-2-资源接口" class="headerlink" title="2.2. 资源接口"></a>2.2. 资源接口</h3><p>Spring 的<code>Resource</code>接口是一个更强大的接口，用于抽象对 low-level 资源的访问。以下清单显示了<code>Resource</code>接口定义：</p>
<pre><code>public interface Resource extends InputStreamSource &#123;

    boolean exists();

    boolean isOpen();

    URL getURL() throws IOException;

    File getFile() throws IOException;

    Resource createRelative(String relativePath) throws IOException;

    String getFilename();

    String getDescription();

&#125;
</code></pre>
<p>正如<code>Resource</code>接口的定义所示，它扩展了<code>InputStreamSource</code>接口。以下清单显示了<code>InputStreamSource</code>接口的定义：</p>
<pre><code>public interface InputStreamSource &#123;

    InputStream getInputStream() throws IOException;

&#125;
</code></pre>
<p><code>Resource</code>接口中一些最重要的方法是：</p>
<ul>
<li><code>getInputStream()</code>：找到并打开资源，返回<code>InputStream</code>以从资源中读取。预计每次调用都会返回一个新的<code>InputStream</code>。呼叫者有责任关闭流。</li>
<li><code>exists()</code>：返回<code>boolean</code>，指示此资源是否实际存在于物理形式中。</li>
<li><code>isOpen()</code>：返回<code>boolean</code>，指示此资源是否表示具有开放流的句柄。如果<code>true</code>，<code>InputStream</code>不能多次读取，必须只读一次然后关闭以避免资源泄漏。对于所有常用资源 implementations，返回<code>false</code>，的 exception。</li>
<li><code>getDescription()</code>：返回此资源的描述，用于处理资源时的错误输出。这通常是完全限定的文件 name 或资源的实际 URL。</li>
</ul>
<p>其他方法允许您获取表示资源的实际<code>URL</code>或<code>File</code> object(如果基础 implementation 兼容并支持该功能)。</p>
<p>当需要资源时，Spring 本身广泛使用<code>Resource</code>抽象，作为许多方法签名中的参数类型。某些 Spring API 中的其他方法(例如各种<code>ApplicationContext</code> __mplementations 的构造函数)采用<code>String</code>，其中使用简单的形式来创建适合于 context implementation 的<code>Resource</code>，或者通过<code>String</code>路径上的特殊前缀，让调用者指定必须创建和使用特定的<code>Resource</code> implementation。</p>
<p>虽然接口与 Spring 和 Spring 一起使用很多，但实际上非常有用的是在你自己的 code 中作为通用实用 class 使用，以便访问资源，即使你的 code 不知道或不关心任何其他的 Spring 的部分内容。虽然这会将你的 code 耦合到 Spring，但它实际上只将它耦合到这一小组实用程序 classes，它们可以作为<code>URL</code>的更强大的替代品，并且可以被认为等同于你将用于此目的的任何其他 library。</p>
<blockquote>
<p><code>Resource</code>抽象不会取代功能。它尽可能地包裹它。对于 example，<code>UrlResource</code>包装了一个 URL 并使用包装的<code>URL</code>来完成它的工作。</p>
</blockquote>
<h3 id="2-3-Built-in-资源-Implementations"><a href="#2-3-Built-in-资源-Implementations" class="headerlink" title="2.3. Built-in 资源 Implementations"></a>2.3. Built-in 资源 Implementations</h3><p>Spring 包括以下<code>Resource</code> implementations：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-urlresource">UrlResource 对象</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-classpathresource">使用 ClassPathResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-filesystemresource">FileSystemResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-servletcontextresource">ServletContextResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-inputstreamresource">InputStreamResource</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-implementations-bytearrayresource">使用 ByteArrayResource</a></li>
</ul>
<h4 id="2-3-1-UrlResource-对象"><a href="#2-3-1-UrlResource-对象" class="headerlink" title="2.3.1. UrlResource 对象"></a>2.3.1. UrlResource 对象</h4><p><code>UrlResource</code>包装<code>java.net.URL</code>，可用于访问通常可通过 URL 访问的任何 object，例如 files，HTTP 目标，FTP 目标等。所有 URL 都具有标准化的<code>String</code>表示，使得适当的标准化前缀用于指示来自另一个的一种 URL 类型。这包括<code>file:</code>用于访问文件系统_path，<code>http:</code>用于通过 HTTP 协议访问资源，<code>ftp:</code>用于通过 FTP 访问资源，以及其他。</p>
<p>是由 Java code 通过显式使用<code>UrlResource</code>构造函数创建的，但是当您调用一个带有<code>String</code>参数的 API 方法来表示路径时，通常会隐式创建<code>UrlResource</code>。对于后一种情况，JavaBeans <code>PropertyEditor</code>最终决定创建哪种类型的<code>Resource</code>。如果路径 string 包含 well-known(对它，那是)前缀(例如<code>classpath:</code>)，它会为该前缀创建一个适当的专用<code>Resource</code>。但是，如果它不识别前缀，则假定 string 是标准 URL string 并创建<code>UrlResource</code>。</p>
<h4 id="2-3-2-使用-ClassPathResource"><a href="#2-3-2-使用-ClassPathResource" class="headerlink" title="2.3.2. 使用 ClassPathResource"></a>2.3.2. 使用 ClassPathResource</h4><p>此 class 表示应从 classpath 获取的资源。它使用线程 context class 加载器，给定的 class 加载器或给定 class 来加载 loading 资源。</p>
<p>如果 class 路径资源驻留在文件系统中，而 classpath 资源驻留在 jar 中并且尚未(通过 servlet 引擎或任何环境)扩展到文件系统，则此<code>Resource</code> implementation 支持解析为<code>java.io.File</code>。为了解决这个问题，各种<code>Resource</code> implementations 总是支持解析为<code>java.net.URL</code>。</p>
<p>是由 Java code 通过显式使用<code>ClassPathResource</code>构造函数创建的，但是当您调用一个带有<code>String</code>参数的 API 方法来表示路径时，通常会隐式创建<code>ClassPathResource</code>。对于后一种情况，JavaBeans <code>PropertyEditor</code>在 string 路径上识别特殊前缀<code>classpath:</code>，并在这种情况下创建<code>ClassPathResource</code>。</p>
<h4 id="2-3-3-的-FileSystemResource"><a href="#2-3-3-的-FileSystemResource" class="headerlink" title="2.3.3. 的 FileSystemResource"></a>2.3.3. 的 FileSystemResource</h4><p>这是<code>java.io.File</code>和<code>java.nio.file.Path</code>句柄的<code>Resource</code> implementation。它支持分辨率为<code>File</code>和<code>URL</code>。</p>
<h4 id="2-3-4-ServletContextResource"><a href="#2-3-4-ServletContextResource" class="headerlink" title="2.3.4. ServletContextResource"></a>2.3.4. ServletContextResource</h4><p>这是<code>ServletContext</code> __mplemplementation for <code>ServletContext</code> resources，用于解释相关 web application 根目录中的相对_path。</p>
<p>它始终支持流访问和 URL 访问，但只有在扩展 web application 存档且资源实际位于文件系统上时才允许<code>java.io.File</code>访问。无论它是在文件系统上扩展还是直接从 JAR 或其他地方(如数据库)(可以想象)访问它实际上都依赖于 Servlet 容器。</p>
<h4 id="2-3-5-的-InputStreamResource"><a href="#2-3-5-的-InputStreamResource" class="headerlink" title="2.3.5. 的 InputStreamResource"></a>2.3.5. 的 InputStreamResource</h4><p><code>InputStreamResource</code>是给定<code>InputStream</code>的<code>Resource</code> implementation。只有在没有特定的<code>Resource</code> implementation 适用时才应该使用它。特别是，在可能的情况下，首选<code>ByteArrayResource</code>或任何 file-based <code>Resource</code> __mplement。</p>
<p>与其他<code>Resource</code> __mplementation 相比，这是 already-opened 资源的描述符。因此，它从<code>isOpen()</code>返回<code>true</code>。如果需要将资源描述符保留在某处或者需要多次读取流，请不要使用它。</p>
<h4 id="2-3-6-使用-ByteArrayResource"><a href="#2-3-6-使用-ByteArrayResource" class="headerlink" title="2.3.6. 使用 ByteArrayResource"></a>2.3.6. 使用 ByteArrayResource</h4><p>这是给定字节 array 的<code>Resource</code> implementation。它为给定的字节 array 创建<code>ByteArrayInputStream</code>。</p>
<p>它对于从任何给定的字节 array 中加载内容非常有用，而不必求助于 single-use <code>InputStreamResource</code>。</p>
<h3 id="2-4-ResourceLoader"><a href="#2-4-ResourceLoader" class="headerlink" title="2.4. ResourceLoader"></a>2.4. ResourceLoader</h3><p><code>ResourceLoader</code>接口应由 objects 实现，它可以 return(即加载)<code>Resource</code>实例。以下清单显示了<code>ResourceLoader</code>接口定义：</p>
<pre><code>public interface ResourceLoader &#123;

    Resource getResource(String location);

&#125;
</code></pre>
<p>所有 application 上下文都实现了<code>ResourceLoader</code>接口。因此，所有 application 上下文都可用于获取<code>Resource</code>实例。</p>
<p>当您在特定的 application context 上调用<code>getResource()</code>，并且指定的位置路径没有特定的前缀时，您将返回适合该特定 application context 的<code>Resource</code>类型。对于 example，假设对<code>ClassPathXmlApplicationContext</code>实例执行了以下 code 代码段：</p>
<pre><code>Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);
</code></pre>
<p>对于<code>ClassPathXmlApplicationContext</code>，code 返回<code>ClassPathResource</code>。如果针对<code>FileSystemXmlApplicationContext</code>实例执行了相同的方法，则会_ret 。对于<code>WebApplicationContext</code>，它会。它同样会为每个 context 返回适当的 objects。</p>
<p>因此，您可以以适合特定 application context 的方式加载资源。</p>
<p>另一方面，您可以通过指定特殊的<code>classpath:</code>前缀来强制使用<code>ClassPathResource</code>，而不管 application context 类型，如下面的 example 所示：</p>
<pre><code>Resource template = ctx.getResource(&quot;classpath:some/resource/path/myTemplate.txt&quot;);
</code></pre>
<p>同样，您可以通过指定任何标准<code>java.net.URL</code>前缀来强制使用<code>UrlResource</code>。以下对示例使用<code>file</code>和<code>http</code>前缀：</p>
<pre><code>Resource template = ctx.getResource(&quot;file:///some/resource/path/myTemplate.txt&quot;);
</code></pre>
<pre><code>Resource template = ctx.getResource(&quot;http://myhost.com/resource/path/myTemplate.txt&quot;);
</code></pre>
<p>以下 table 总结了将<code>String</code> objects 转换为<code>Resource</code> objects 的策略：</p>
<table>
<thead>
<tr>
<th>字首</th>
<th>例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>classpath：</td>
<td><code>classpath:com/myapp/config.xml</code></td>
<td>从 classpath 加载。</td>
</tr>
<tr>
<td>文件：</td>
<td><code>file:///data/config.xml</code></td>
<td>从文件系统加载为<code>URL</code>。另见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-filesystemresource-caveats">FileSystemResource 警告</a>。</td>
</tr>
<tr>
<td>HTTP：</td>
<td><code>http://myserver/logo.png</code></td>
<td>加载为<code>URL</code>。</td>
</tr>
<tr>
<td>(没有)</td>
<td><code>/data/config.xml</code></td>
<td>取决于潜在的<code>ApplicationContext</code>。</td>
</tr>
</tbody></table>
<h3 id="2-5-ResourceLoaderAware-接口"><a href="#2-5-ResourceLoaderAware-接口" class="headerlink" title="2.5. ResourceLoaderAware 接口"></a>2.5. ResourceLoaderAware 接口</h3><p><code>ResourceLoaderAware</code>接口是一个特殊的标记接口，用于标识期望提供<code>ResourceLoader</code> reference 的 objects。以下清单显示了<code>ResourceLoaderAware</code>接口的定义：</p>
<pre><code>public interface ResourceLoaderAware &#123;

    void setResourceLoader(ResourceLoader resourceLoader);
&#125;
</code></pre>
<p>当 class 实现<code>ResourceLoaderAware</code>并部署到 application context(作为 Spring-managed bean)时，application context 将其识别为<code>ResourceLoaderAware</code>。然后 application context 调用<code>setResourceLoader(ResourceLoader)</code>，将自身作为参数提供(请记住，Spring 中的所有 application 上下文都实现了<code>ResourceLoader</code>接口)。</p>
<p>由于<code>ApplicationContext</code>是<code>ResourceLoader</code>，因此 bean 也可以实现<code>ApplicationContextAware</code>接口并直接使用提供的 application context 来加载资源。但是，一般情况下，如果您需要，最好使用专门的<code>ResourceLoader</code>接口。 code 只能耦合到资源 loading 接口(可以被认为是实用程序接口)，而不能耦合到整个 Spring <code>ApplicationContext</code>接口。</p>
<p>从 Spring 2.5 开始，您可以依靠自动装配<code>ResourceLoader</code>作为实现<code>ResourceLoaderAware</code>接口的替代方法。 “传统的”<code>constructor</code>和<code>byType</code>自动装配模式(如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">自动化协作者</a>中所述)现在能够分别为构造函数参数或 setter 方法参数提供类型<code>ResourceLoader</code>的依赖性。为了获得更大的灵活性(包括自动装配字段和多参数方法的能力)，请考虑使用 annotation-based 自动装配 features。在这种情况下，<code>ResourceLoader</code>被自动装入一个字段，构造函数参数或方法参数，它们要求<code>ResourceLoader</code>类型为 long，因为有问题的字段，构造函数或方法带有<code>@Autowired</code> annotation。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-autowired-annotation">使用 @Autowired</a>。</p>
<h3 id="2-6-资源作为依赖关系"><a href="#2-6-资源作为依赖关系" class="headerlink" title="2.6. 资源作为依赖关系"></a>2.6. 资源作为依赖关系</h3><p>如果 bean 本身将通过某种动态 process 确定并提供资源路径，那么 bean 使用<code>ResourceLoader</code>接口加载资源可能是有意义的。对于 example，请考虑某种模板的 loading，其中所需的特定资源取决于用户的角色。如果资源是静态的，那么完全消除<code>ResourceLoader</code>接口的使用是有意义的，让 bean 暴露它需要的<code>Resource</code> properties，并期望它们被注入其中。</p>
<p>那么 inject 这些 properties 的重要性在于所有 application 上下文都注册并使用特殊的 JavaBeans <code>PropertyEditor</code>，它可以将<code>String</code> _path 转换为<code>Resource</code> objects。因此，如果<code>myBean</code>具有<code>Resource</code>类型的模板 property，则可以为该资源配置一个简单的 string，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;myBean&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;template&quot; value=&quot;some/resource/path/myTemplate.txt&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>请注意，资源路径没有前缀。因此，因为 application context 本身将用作<code>ResourceLoader</code>，所以资源本身通过<code>ClassPathResource</code>，<code>FileSystemResource</code>或<code>ServletContextResource</code>加载，具体取决于 context 的确切类型。</p>
<p>如果需要强制使用特定的<code>Resource</code>类型，则可以使用前缀。以下两个示例显示如何强制<code>ClassPathResource</code>和<code>UrlResource</code>(后者用于访问文件系统文件)：</p>
<pre><code>&lt;property name=&quot;template&quot; value=&quot;classpath:some/resource/path/myTemplate.txt&quot;&gt;
</code></pre>
<pre><code>&lt;property name=&quot;template&quot; value=&quot;file:///some/resource/path/myTemplate.txt&quot;/&gt;
</code></pre>
<h3 id="2-7-Application-Contexts-和-Resource-Paths"><a href="#2-7-Application-Contexts-和-Resource-Paths" class="headerlink" title="2.7. Application Contexts 和 Resource Paths"></a>2.7. Application Contexts 和 Resource Paths</h3><p>本节介绍如何使用资源创建 application 上下文，包括使用 XML 的快捷方式，如何使用通配符以及其他详细信息。</p>
<h4 id="2-7-1-构建-Application-上下文"><a href="#2-7-1-构建-Application-上下文" class="headerlink" title="2.7.1. 构建 Application 上下文"></a>2.7.1. 构建 Application 上下文</h4><p>application context 构造函数(对于特定的 application context 类型)通常使用 string 的 string 或 array 作为资源的位置_path，例如构成 context 定义的 XML files。</p>
<p>当这样的位置路径没有前缀时，从该路径构建并用于加载 bean 定义的特定<code>Resource</code>类型取决于并且适合于特定的 application context。对于 example，请考虑以下 example，它会创建<code>ClassPathXmlApplicationContext</code>：</p>
<pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;conf/appContext.xml&quot;);
</code></pre>
<p>bean 定义是从 classpath 加载的，因为使用了<code>ClassPathResource</code>。但是，请考虑以下 example，它会创建一个<code>FileSystemXmlApplicationContext</code>：</p>
<pre><code>ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;conf/appContext.xml&quot;);
</code></pre>
<p>现在 bean 定义从文件系统位置加载(在这种情况下，相对于当前工作目录)。</p>
<p>请注意，在位置路径上使用特殊 classpath 前缀或标准 URL 前缀会覆盖为加载定义而创建的默认类型<code>Resource</code>。考虑以下 example：</p>
<pre><code>ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;classpath:conf/appContext.xml&quot;);
</code></pre>
<p>使用<code>FileSystemXmlApplicationContext</code>从 classpath 加载 bean 定义。但是，它仍然是<code>FileSystemXmlApplicationContext</code>。如果它随后用作<code>ResourceLoader</code>，则任何未加前缀的_path 仍然被视为 filesystem paths。</p>
<h5 id="构造-ClassPathXmlApplicationContext-实例-快捷方式"><a href="#构造-ClassPathXmlApplicationContext-实例-快捷方式" class="headerlink" title="构造 ClassPathXmlApplicationContext 实例 - 快捷方式"></a>构造 ClassPathXmlApplicationContext 实例 - 快捷方式</h5><p><code>ClassPathXmlApplicationContext</code>公开了许多构造函数以实现方便的实例化。基本的 idea 是你只能提供 string array，它只包含 XML files 本身的文件名(没有前导路径信息)，并且还提供<code>Class</code>。然后<code>ClassPathXmlApplicationContext</code>从提供的 class 派生路径信息。</p>
<p>请考虑以下目录布局：</p>
<pre><code>com/
  foo/
    services.xml
    daos.xml
    MessengerService.class
</code></pre>
<p>以下 example 显示了如何实例化<code>ClassPathXmlApplicationContext</code>实例，该实例由 files 中定义的名为<code>services.xml</code>和<code>daos.xml</code>(位于 classpath 上)的 beans 组成：</p>
<pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] &#123;&quot;services.xml&quot;, &quot;daos.xml&quot;&#125;, MessengerService.class);
</code></pre>
<p>有关各种构造函数的详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html">ClassPathXmlApplicationContext</a> javadoc。</p>
<h4 id="2-7-2-Application-Context-构造函数资源-Paths-中的通配符"><a href="#2-7-2-Application-Context-构造函数资源-Paths-中的通配符" class="headerlink" title="2.7.2. Application Context 构造函数资源 Paths 中的通配符"></a>2.7.2. Application Context 构造函数资源 Paths 中的通配符</h4><p>application context 构造函数值中的资源 paths 可以是简单的 paths(如前所示)，每个都有 one-to-one 映射到目标<code>Resource</code>，或者，可以包含特殊的“classpath *：”前缀或内部 Ant-style 正则表达式(匹配)通过使用 Spring 的<code>PathMatcher</code>实用程序)。后者都是有效的通配符。</p>
<p>此机制的一个用途是当您需要执行 component-style application 程序集时。所有组件都可以将 context 定义片段“发布”到 well-known 位置路径，并且当使用前缀为<code>classpath*:</code>的相同路径创建最终 application context 时，将自动拾取所有 component 片段。</p>
<p>请注意，此通配符特定于 application context 构造函数中使用资源_path(或直接使用<code>PathMatcher</code>实用程序 class 层次结构时)，并在构造 time 时解析。它与<code>Resource</code>类型本身无关。您不能使用<code>classpath*:</code>前缀来构造实际的<code>Resource</code>，因为资源仅指向 time 上的一个资源。</p>
<h5 id="Ant-style-模式"><a href="#Ant-style-模式" class="headerlink" title="Ant-style 模式"></a>Ant-style 模式</h5><p>路径位置可以包含 Ant-style 模式，如下面的示例所示：</p>
<pre><code>/WEB-INF/*-context.xml
com/mycompany/**/applicationContext.xml
file:C:/some/path/*-context.xml
classpath:com/mycompany/**/applicationContext.xml
</code></pre>
<p>当路径位置包含 Ant-style pattern 时，解析程序遵循更复杂的过程来尝试解析通配符。它为直到最后 non-wildcard 段的路径生成<code>Resource</code>并从中获取 URL。如果此 URL 不是<code>jar:</code> URL 或 container-specific 变体(例如 WebLogic 中的<code>zip:</code>，WebSphere 中的<code>wsjar</code>等)，则从中获取<code>java.io.File</code>并用于通过遍历文件系统来解析通配符。对于 jar URL，解析器从中获取<code>java.net.JarURLConnection</code>或手动解析 jar URL，然后遍历 jar 文件的内容以解析通配符。</p>
<h6 id="对可移植性的影响"><a href="#对可移植性的影响" class="headerlink" title="对可移植性的影响"></a>对可移植性的影响</h6><p>如果指定的路径已经是文件 URL(隐式，因为基本<code>ResourceLoader</code>是文件系统或显式)，则可以保证通配符以完全可移植的方式工作。</p>
<p>如果指定的路径是 classpath 位置，则解析程序必须通过<code>Classloader.getResource()</code>调用获取最后的 non-wildcard 路径段 URL。由于这只是路径的一个节点(不是最后的文件)，实际上它是未定义的(在<code>ClassLoader</code> javadoc 中)，在这种情况下确切地返回了什么类型的 URL。实际上，它总是<code>java.io.File</code>表示目录(classpath 资源解析为文件系统位置)或某种 jar URL(classpath 资源解析为 jar 位置)。尽管如此，这项行动仍存在可移植性问题。</p>
<p>如果为最后一个 non-wildcard 段获取了 jar URL，则解析器必须能够从中获取<code>java.net.JarURLConnection</code>或手动解析 jar URL，以便能够遍历 jar 的内容并解析通配符。这在大多数环境中都有效，但在其他环境中无效，我们强烈建议您在依赖它之前，在特定环境中对来自 jars 的资源的通配符解析进行全面测试。</p>
<h5 id="classpath-：前缀"><a href="#classpath-：前缀" class="headerlink" title="classpath *：前缀"></a>classpath *：前缀</h5><p>构造 XML-based application context 时，位置 string 可以使用特殊的<code>classpath*:</code>前缀，如下面的 example 所示：</p>
<pre><code>ApplicationContext ctx =
    new ClassPathXmlApplicationContext(&quot;classpath*:conf/appContext.xml&quot;);
</code></pre>
<p>此特殊前缀指定必须获取 match 给定 name 的所有 classpath 资源(内部，这通常通过调用<code>ClassLoader.getResources(…)</code>)然后合并以形成最终的 application context 定义。</p>
<blockquote>
<p>通配符 classpath 依赖于底层类加载器的<code>getResources()</code>方法。由于现在大多数 application 服务器都提供了自己的类加载器 implementation，因此行为可能会有所不同，尤其是在处理 jar files 时。检查<code>classpath*</code>是否有效的简单测试是使用类加载器从 class 路径上的 jar 中加载文件：<code>getClass().getClassLoader().getResources(&quot;&lt;someFileInsideTheJar&gt;&quot;)</code>。尝试使用具有相同 name 但放在两个不同位置的 files 进行此测试。如果返回了不适当的结果，请检查 application 服务器文档以获取可能影响类加载器行为的设置。</p>
</blockquote>
<p>您还可以将<code>classpath*:</code>前缀与<code>PathMatcher</code> pattern 组合在位置路径的 rest 中(对于 example，<code>classpath*:META-INF/*-beans.xml</code>)。在这种情况下，解析策略非常简单：在最后一个 non-wildcard 路径段上使用<code>ClassLoader.getResources()</code>调用来获取 class 加载器层次结构中的所有匹配资源，然后，在每个资源之外，使用前面描述的相同的<code>PathMatcher</code>解析策略通配符子路径。</p>
<h5 id="与通配符有关的其他说明"><a href="#与通配符有关的其他说明" class="headerlink" title="与通配符有关的其他说明"></a>与通配符有关的其他说明</h5><p>请注意，<code>classpath*:</code>与 Ant-style 模式结合使用时，只能在 pattern 启动之前与至少一个根目录可靠地工作，除非实际目标 files 位于文件系统中。这意味着诸如<code>classpath*:*.xml</code>之类的 pattern 可能无法从 jar files 的根目录中检索 files，而只能从扩展目录的根目录中检索 files。</p>
<p>Spring 检索 classpath 条目的能力来自 JDK 的<code>ClassLoader.getResources()</code>方法，该方法仅返回空 string 的文件系统位置(指示搜索的潜在根)。 Spring 也会评估<code>URLClassLoader</code>运行时 configuration 和 jar files 中的<code>java.class.path</code>清单，但这不能保证导致可移植行为。</p>
<blockquote>
<p>扫描 classpath 包需要在 classpath 中存在相应的目录条目。使用 Ant build JAR 时，请不要激活 JAR 任务的 files-only 开关。此外，classpath 目录可能不会在某些环境中基于安全 policies 公开 - 例如，JDK 1.7.0_45 及更高版本上的 stand-alone applications(需要在清单中设置’Trusted-Library’.请参阅<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>)。</p>
</blockquote>
<p>在 JDK 9 的模块路径(Jigsaw)上，Spring 的 classpath 扫描通常按预期工作。此处强烈建议将资源放入专用目录，避免上述搜索 jar 文件根 level 时出现的可移植性问题。</p>
<p>如果要搜索的根包在多个 class 路径位置中可用，则不保证具有<code>classpath:</code>资源的 Ant-style 模式可以找到匹配的资源。考虑以下资源位置的示例：</p>
<pre><code>com/mycompany/package1/service-context.xml
</code></pre>
<p>现在考虑某人可能用来尝试查找该文件的 Ant-style 路径：</p>
<pre><code>classpath:com/mycompany/**/service-context.xml
</code></pre>
<p>这样的资源可能只在一个位置，但是当使用诸如前面的 example 之类的路径来尝试解析它时，解析器会处理<code>getResource(&quot;com/mycompany&quot;);</code>返回的(第一个)URL。如果此基本包节点存在于多个类加载器位置中，则实际的最终资源可能不存在。因此，在这种情况下，您应该更喜欢使用<code>classpath*:</code>和相同的 Ant-style pattern，它会搜索包含根软件包的所有 class 路径位置。</p>
<h4 id="2-7-3-FileSystemResource-警告"><a href="#2-7-3-FileSystemResource-警告" class="headerlink" title="2.7.3. FileSystemResource 警告"></a>2.7.3. FileSystemResource 警告</h4><p>没有附加到<code>FileSystemApplicationContext</code>的<code>FileSystemResource</code>(即，当<code>FileSystemApplicationContext</code>不是实际的<code>ResourceLoader</code>时)会像您期望的那样处理绝对和相对的_path。相对 paths 相对于当前工作目录，而绝对 paths 相对于文件系统的根目录。</p>
<p>但是，出于向后兼容性(历史)的原因，当<code>FileSystemApplicationContext</code>是<code>ResourceLoader</code>时，这会发生变化。 <code>FileSystemApplicationContext</code>强制所有附加的<code>FileSystemResource</code>实例将所有位置 paths 视为相对的，无论它们是否以前导斜杠开头。实际上，这意味着以下示例是等效的：</p>
<pre><code>ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;conf/context.xml&quot;);
</code></pre>
<pre><code>ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;/conf/context.xml&quot;);
</code></pre>
<p>以下示例也是等效的(即使它们有所不同，因为一个案例是相对的而另一个案例是绝对的)：</p>
<pre><code>FileSystemXmlApplicationContext ctx = ...;
ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);
</code></pre>
<pre><code>FileSystemXmlApplicationContext ctx = ...;
ctx.getResource(&quot;/some/resource/path/myTemplate.txt&quot;);
</code></pre>
<p>实际上，如果需要 true 绝对文件系统 paths，则应避免对<code>FileSystemResource</code>或<code>FileSystemXmlApplicationContext</code>使用绝对_path，并使用<code>file:</code> URL 前缀强制使用<code>UrlResource</code>。以下示例显示了如何执行此操作：</p>
<pre><code>// actual context type doesn&#39;t matter, the Resource will always be UrlResource
ctx.getResource(&quot;file:///some/resource/path/myTemplate.txt&quot;);
</code></pre>
<pre><code>// force this FileSystemXmlApplicationContext to load its definition via a UrlResource
ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;file:///conf/context.xml&quot;);
</code></pre>
<h2 id="3-验证，数据绑定和类型转换"><a href="#3-验证，数据绑定和类型转换" class="headerlink" title="3.验证，数据绑定和类型转换"></a>3.验证，数据绑定和类型转换</h2><p>将验证视为业务逻辑有利有弊，而 Spring 提供了一种验证(和数据绑定)设计，不排除其中任何一个。具体来说，验证不应该绑定到 web 层，并且应该易于本地化，并且应该可以插入任何可用的验证器。考虑到这些问题，Spring 已经提出了一个<code>Validator</code>接口，它在 application 的每一层都是基本的，非常有用。</p>
<p>数据 binding 对于让用户输入动态绑定到 application 的域 model(或用于 process 用户输入的任何 objects)非常有用。 Spring 提供恰当的名称<code>DataBinder</code>来做到这一点。 <code>Validator</code>和<code>DataBinder</code>组成<code>validation</code>包，主要用于但不限于 MVC framework。</p>
<p><code>BeanWrapper</code>是 Spring Framework 中的一个基本概念，并且在很多地方使用。但是，您可能不需要直接使用<code>BeanWrapper</code>。因为这是 reference 文档，但我们觉得有些解释可能是 order。我们在本章中解释了<code>BeanWrapper</code>，因为如果你要使用它，你很可能在尝试将数据绑定到 objects 时这样做。</p>
<p>Spring 的<code>DataBinder</code>和 lower-level <code>BeanWrapper</code>都使用<code>PropertyEditorSupport</code> implementations 来解析和格式化 property 值。 <code>PropertyEditor</code>和<code>PropertyEditorSupport</code>接口是 JavaBeans 规范的一部分，本章也对其进行了解释。 Spring 3 引入了一个<code>core.convert</code>包，它提供了一般的类型转换工具，以及一个用于格式化 UI 字段值的 higher-level“format”包。您可以使用这些包作为<code>PropertyEditorSupport</code> implementations 的更简单的替代方法。它们也在本章中讨论。</p>
<p>JSR-303/JSR-349 Bean 验证</p>
<p>从 version 4.0 开始，Spring Frameworks 支持 Bean Validation 1.0(JSR-303)和 Bean Validation 1.1(JSR-349)进行设置支持并使它们适应 Spring 的<code>Validator</code>接口。</p>
<p>_ application 可以选择全局启用 Bean Validation 一次，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#validation-beanvalidation">Spring 验证</a>中所述，并专门用于所有验证需求。</p>
<p>_ application 还可以为每个<code>DataBinder</code>实例注册其他 Spring <code>Validator</code>实例，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#validation-binder">配置 DataBinder</a>中所述。这可能对于在不使用 annotations 的情况下插入验证逻辑非常有用。</p>
<h3 id="3-1-使用-Spring-的验证器接口进行验证"><a href="#3-1-使用-Spring-的验证器接口进行验证" class="headerlink" title="3.1. 使用 Spring 的验证器接口进行验证"></a>3.1. 使用 Spring 的验证器接口进行验证</h3><p>Spring features 一个<code>Validator</code>接口，可用于验证 objects。 <code>Validator</code>接口使用<code>Errors</code> object 工作，以便在验证时，验证程序可以向<code>Errors</code> object 报告验证失败。</p>
<p>考虑以下一个小数据 object 的示例：</p>
<pre><code>public class Person &#123;

    private String name;
    private int age;

    // the usual getters and setters...
&#125;
</code></pre>
<p>下一个 example 通过实现<code>org.springframework.validation.Validator</code>接口的以下两个方法为<code>Person</code> class 提供验证行为：</p>
<ul>
<li><code>supports(Class)</code>：这可以<code>Validator</code>验证提供的<code>Class</code>的实例吗？</li>
<li><code>validate(Object, org.springframework.validation.Errors)</code>：验证给定的 object，并在验证错误的情况下，使用给定的<code>Errors</code> object 注册那些。</li>
</ul>
<p>实现<code>Validator</code>非常简单，尤其是当您知道 Spring Framework 也提供的<code>ValidationUtils</code>帮助 class 时。以下 example 为<code>Person</code>实例实现了<code>Validator</code>：</p>
<pre><code>public class PersonValidator implements Validator &#123;

    /**
     * This Validator validates *only* Person instances
     */
    public boolean supports(Class clazz) &#123;
        return Person.class.equals(clazz);
    &#125;

    public void validate(Object obj, Errors e) &#123;
        ValidationUtils.rejectIfEmpty(e, &quot;name&quot;, &quot;name.empty&quot;);
        Person p = (Person) obj;
        if (p.getAge() &lt; 0) &#123;
            e.rejectValue(&quot;age&quot;, &quot;negativevalue&quot;);
        &#125; else if (p.getAge() &gt; 110) &#123;
            e.rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p><code>ValidationUtils</code> class 上的<code>static</code> <code>rejectIfEmpty(..)</code>方法用于拒绝<code>name</code> property，如果它是<code>null</code>或空 string。看一下<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/validation/ValidationUtils.html">ValidationUtils 相关</a> javadoc，看看它提供的功能除了前面显示的 example 之外。</p>
<p>虽然可以实现单个<code>Validator</code> class 来验证富 object 中的每个嵌套 objects，但最好将 object 的每个嵌套 class 的验证逻辑封装在它自己的<code>Validator</code> implementation 中。 “富”object 的简单 example 将是<code>Customer</code>，它由两个<code>String</code> properties(第一个和第二个 name)和一个复杂的<code>Address</code> object 组成。 <code>Address</code> objects 可以独立于<code>Customer</code> objects 使用，因此已经实现了一个独特的<code>AddressValidator</code>。如果您希望<code>CustomerValidator</code>重用<code>AddressValidator</code> class 中包含的逻辑而不诉诸 copy-and-paste，您可以在<code>CustomerValidator</code>中 dependency-inject 或实例化<code>AddressValidator</code>，如下面的 example 所示：</p>
<pre><code>public class CustomerValidator implements Validator &#123;

    private final Validator addressValidator;

    public CustomerValidator(Validator addressValidator) &#123;
        if (addressValidator == null) &#123;
            throw new IllegalArgumentException(&quot;The supplied [Validator] is &quot; +
                &quot;required and must not be null.&quot;);
        &#125;
        if (!addressValidator.supports(Address.class)) &#123;
            throw new IllegalArgumentException(&quot;The supplied [Validator] must &quot; +
                &quot;support the validation of [Address] instances.&quot;);
        &#125;
        this.addressValidator = addressValidator;
    &#125;

    /**
     * This Validator validates Customer instances, and any subclasses of Customer too
     */
    public boolean supports(Class clazz) &#123;
        return Customer.class.isAssignableFrom(clazz);
    &#125;

    public void validate(Object target, Errors errors) &#123;
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;firstName&quot;, &quot;field.required&quot;);
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;surname&quot;, &quot;field.required&quot;);
        Customer customer = (Customer) target;
        try &#123;
            errors.pushNestedPath(&quot;address&quot;);
            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
        &#125; finally &#123;
            errors.popNestedPath();
        &#125;
    &#125;
&#125;
</code></pre>
<p>验证错误将报告给传递给验证程序的<code>Errors</code> object。对于 Spring Web MVC，您可以使用<code>&lt;spring:bind/&gt;</code>标记来检查错误消息，但您也可以自己检查<code>Errors</code> object。有关它提供的方法的更多信息可以在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframeworkvalidation/Errors.html">javadoc</a>中找到。</p>
<h3 id="3-2-将代码解析为错误消息"><a href="#3-2-将代码解析为错误消息" class="headerlink" title="3.2. 将代码解析为错误消息"></a>3.2. 将代码解析为错误消息</h3><p>我们介绍了数据绑定和验证。本节介绍输出与验证错误相对应的消息。在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#validator">前一节</a>中显示的 example 中，我们拒绝了<code>name</code>和<code>age</code>字段。如果我们想使用<code>MessageSource</code>输出错误消息，我们可以使用我们在拒绝字段时提供的错误 code(在这种情况下为’name’和’age’)。当你通过<code>Errors</code>接口直接或间接地调用(例如，<code>ValidationUtils</code> class)<code>rejectValue</code>或其他<code>reject</code>方法之一时，底层 implementation 不仅会记录你传入的 code，还会注册一些其他错误代码。 <code>MessageCodesResolver</code>确定<code>Errors</code>接口注册的错误代码。默认情况下，使用<code>DefaultMessageCodesResolver</code>，(对于 example)不仅使用您给出的 code 注册消息，还会注册包含您传递给 reject 方法的字段 name 的消息。因此，如果您使用<code>rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)</code>拒绝某个字段，除了<code>too.darn.old</code> code 之外，Spring 还会注册<code>too.darn.old.age</code>和<code>too.darn.old.age.int</code>(第一个包含字段 name，第二个包含字段的类型)。这样做是为了方便在定位错误消息时帮助开发人员。</p>
<p>有关<code>MessageCodesResolver</code>和默认策略的更多信息可以分别在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/validation/MessageCodesResolver.html">MessageCodesResolver 的信息</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html">DefaultMessageCodesResolver。回到</a>的 javadoc 中找到。</p>
<h3 id="3-3-Bean-操作和-BeanWrapper"><a href="#3-3-Bean-操作和-BeanWrapper" class="headerlink" title="3.3. Bean 操作和 BeanWrapper"></a>3.3. Bean 操作和 BeanWrapper</h3><p><code>org.springframework.beans</code>包遵循 JavaBeans 标准。 JavaBean 是一个具有默认 no-argument 构造函数的 class，它遵循命名约定，其中(对于 example)名为<code>bingoMadness</code>的 property 将具有 setter 方法<code>setBingoMadness(..)</code>和 getter 方法<code>getBingoMadness()</code>。有关 JavaBeans 和规范的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">JavaBeans</a>。</p>
<p>beans 包中一个非常重要的 class 是<code>BeanWrapper</code>接口及其相应的 implementation(<code>BeanWrapperImpl</code>)。从 javadoc 引用，<code>BeanWrapper</code>提供了设置和获取 property 值(单独或批量)，获取 property 描述符和查询 properties 以确定它们是可读还是可写的功能。此外，<code>BeanWrapper</code>提供对嵌套 properties 的支持，使 sub-properties 上的 properties 设置为无限深度。 <code>BeanWrapper</code>还支持添加标准 JavaBeans <code>PropertyChangeListeners</code>和<code>VetoableChangeListeners</code>的功能，而无需在目标 class 中支持 code。最后但并非最不重要的是，<code>BeanWrapper</code>提供了对设置索引 properties 的支持。 <code>BeanWrapper</code>通常不直接由 application code 使用，但由<code>DataBinder</code>和<code>BeanFactory</code>使用。</p>
<p><code>BeanWrapper</code>的工作方式部分由 name 表示：它包装 bean 以对该 bean 执行操作，例如设置和检索 properties。</p>
<h4 id="3-3-1-设置和获取基本和嵌套的-Properties"><a href="#3-3-1-设置和获取基本和嵌套的-Properties" class="headerlink" title="3.3.1. 设置和获取基本和嵌套的 Properties"></a>3.3.1. 设置和获取基本和嵌套的 Properties</h4><p>设置和获取 properties 是通过使用带有几个重载变体的<code>setPropertyValue</code>，<code>setPropertyValues</code>，<code>getPropertyValue</code>和<code>getPropertyValues</code>方法完成的。 Springs javadoc 更详细地描述了它们。 JavaBeans 规范具有用于指示 object 的 properties 的约定。以下 table 显示了这些约定的一些示例：</p>
<table>
<thead>
<tr>
<th>表达</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>表示 property <code>name</code>，对应于<code>getName()</code>或<code>isName()</code>和<code>setName(..)</code>方法。</td>
</tr>
<tr>
<td><code>account.name</code></td>
<td>指示 property <code>account</code>的嵌套 property <code>name</code>，它对应于(对于 example)<code>getAccount().setName()</code>或<code>getAccount().getName()</code>方法。</td>
</tr>
<tr>
<td><code>account[2]</code></td>
<td>表示索引 property <code>account</code>的第三个元素。索引的 properties 可以是<code>array</code>，<code>list</code>或其他自然排序的集合。</td>
</tr>
<tr>
<td><code>account[COMPANYNAME]</code></td>
<td>表示由<code>account</code> <code>Map</code> property 的<code>COMPANYNAME</code> key 索引的 map 条目的 value。</td>
</tr>
</tbody></table>
<p>(如果你不打算直接使用<code>BeanWrapper</code>，那么下一部分对你来说并不重要.如果你只使用<code>DataBinder</code>和<code>BeanFactory</code>以及它们的默认_i实现，你应该跳到<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beans-conversion">有关 PropertyEditors 的部分</a> .)</p>
<p>以下两个 example classes 使用<code>BeanWrapper</code>来获取和设置 properties：</p>
<pre><code>public class Company &#123;

    private String name;
    private Employee managingDirector;

    public String getName() &#123;
        return this.name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public Employee getManagingDirector() &#123;
        return this.managingDirector;
    &#125;

    public void setManagingDirector(Employee managingDirector) &#123;
        this.managingDirector = managingDirector;
    &#125;
&#125;
</code></pre>
<pre><code>public class Employee &#123;

    private String name;

    private float salary;

    public String getName() &#123;
        return this.name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public float getSalary() &#123;
        return salary;
    &#125;

    public void setSalary(float salary) &#123;
        this.salary = salary;
    &#125;
&#125;
</code></pre>
<p>以下 code 片段显示了一些如何检索和操作实例化的<code>Companies</code>和<code>Employees</code>的 properties 的示例：</p>
<pre><code>BeanWrapper company = new BeanWrapperImpl(new Company());
// setting the company name..
company.setPropertyValue(&quot;name&quot;, &quot;Some Company Inc.&quot;);
// ... can also be done like this:
PropertyValue value = new PropertyValue(&quot;name&quot;, &quot;Some Company Inc.&quot;);
company.setPropertyValue(value);

// ok, let&#39;s create the director and tie it to the company:
BeanWrapper jim = new BeanWrapperImpl(new Employee());
jim.setPropertyValue(&quot;name&quot;, &quot;Jim Stravinsky&quot;);
company.setPropertyValue(&quot;managingDirector&quot;, jim.getWrappedInstance());

// retrieving the salary of the managingDirector through the company
Float salary = (Float) company.getPropertyValue(&quot;managingDirector.salary&quot;);
</code></pre>
<h4 id="3-3-2-Built-in-PropertyEditor-Implementations"><a href="#3-3-2-Built-in-PropertyEditor-Implementations" class="headerlink" title="3.3.2. Built-in PropertyEditor Implementations"></a>3.3.2. Built-in PropertyEditor Implementations</h4><p>Spring 使用<code>PropertyEditor</code>的概念来实现<code>Object</code>和<code>String</code>之间的转换。以与 object 本身不同的方式表示 properties 是很方便的。例如，<code>Date</code>可以用人类可读的方式表示(如<code>String</code>：<code>&#39;2007-14-09&#39;</code>)，而我们仍然可以将人类可读的表单转换回原始 date(或者更好的是，转换以人类可读形式输入的任何 date 回到<code>Date</code> objects)。通过注册<code>java.beans.PropertyEditor</code>类型的自定义编辑器可以实现此行为。在<code>BeanWrapper</code>上注册自定义编辑器，或者在特定的 IoC 容器中注册(如上一章所述)，使其了解如何将 properties 转换为所需的类型。有关<code>PropertyEditor</code>的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">来自 Oracle 的 java.beans 包的 javadoc</a>。</p>
<p>在 Spring 中使用 property 编辑的几个示例：</p>
<ul>
<li>在 beans 上设置 properties 是通过使用<code>PropertyEditor</code> implementations 完成的。当您使用<code>java.lang.String</code>作为在 XML 文件中声明的某些 bean 的 property 的 value 时，Spring(如果相应 property 的 setter 具有<code>Class</code>参数)使用<code>ClassEditor</code>尝试将参数解析为<code>Class</code> object。</li>
<li>在 Spring 的 MVC framework 中解析 HTTP 请求参数是通过使用所有类型的<code>PropertyEditor</code> __mplement 来完成的，您可以在<code>CommandController</code>的所有子类中手动绑定。</li>
</ul>
<p>Spring 有许多 built-in <code>PropertyEditor</code> implementations 让生活变得轻松。它们都位于<code>org.springframework.beans.propertyeditors</code>包中。大多数(但不是全部，如下面的 table 所示)默认情况下由<code>BeanWrapperImpl</code>注册。如果 property 编辑器可以某种方式配置，您仍然可以注册自己的变体来覆盖默认变体。以下 table 描述了 Spring 提供的各种<code>PropertyEditor</code> __mplement：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ByteArrayPropertyEditor</code></td>
<td>字节数组的编辑器。将 strings 转换为其对应的字节表示形式。默认情况下由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>ClassEditor</code></td>
<td>解析 strings 表示 classes 到实际的 classes 和 vice-versa。如果找不到 class，则抛出<code>IllegalArgumentException</code>。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>CustomBooleanEditor</code></td>
<td><code>Boolean</code> properties 的可自定义 property 编辑器。默认情况下，由<code>BeanWrapperImpl</code>注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td><code>CustomCollectionEditor</code></td>
<td>Property 集合编辑器，将任何源<code>Collection</code>转换为给定目标<code>Collection</code>类型。</td>
</tr>
<tr>
<td><code>CustomDateEditor</code></td>
<td><code>java.util.Date</code>的可自定义 property 编辑器，支持自定义<code>DateFormat</code>。没有默认注册。必须是 user-registered，并根据需要使用适当的格式。</td>
</tr>
<tr>
<td><code>CustomNumberEditor</code></td>
<td>任何<code>Number</code>子类的可自定义 property 编辑器，例如<code>Integer</code>，<code>Long</code>，<code>Float</code>或<code>Double</code>。默认情况下，由<code>BeanWrapperImpl</code>注册，但可以通过将其自定义实例注册为自定义编辑器来覆盖。</td>
</tr>
<tr>
<td><code>FileEditor</code></td>
<td>将 strings 解析为<code>java.io.File</code> objects。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>InputStreamEditor</code></td>
<td>One-way property 编辑器，可以使用 string 并生成(通过中间<code>ResourceEditor</code>和<code>Resource</code>)<code>InputStream</code>，以便<code>InputStream</code> properties 可以直接设置为 strings。请注意，默认用法不会为您关闭<code>InputStream</code>。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>LocaleEditor</code></td>
<td>可以将 strings 解析为<code>Locale</code> objects 和 vice-versa(string 格式为<code>[country][variant]</code>，与<code>Locale</code>的<code>toString()</code>方法相同)。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>PatternEditor</code></td>
<td>可以将 strings 解析为<code>java.util.regex.Pattern</code> objects 和 vice-versa。</td>
</tr>
<tr>
<td><code>PropertiesEditor</code></td>
<td>可以将 strings(使用<code>java.util.Properties</code> class 的 javadoc 中定义的格式格式化)转换为<code>Properties</code> objects。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
<tr>
<td><code>StringTrimmerEditor</code></td>
<td>Property 编辑器修剪 strings。 (可选)允许将空 string 转换为<code>null</code> value。默认情况下未注册 - 必须为 user-registered。</td>
</tr>
<tr>
<td><code>URLEditor</code></td>
<td>可以将 URL 的 string 表示解析为实际的<code>URL</code> object。默认情况下，由<code>BeanWrapperImpl</code>注册。</td>
</tr>
</tbody></table>
<p>Spring 使用<code>java.beans.PropertyEditorManager</code>为可能需要的 property 编辑器设置搜索路径。搜索路径还包括<code>sun.bean.editors</code>，其中包括<code>PropertyEditor</code>，<code>Color</code>等类型的<code>PropertyEditor</code> __mplement，以及大多数基本类型。另请注意，标准 JavaBeans 基础结构会自动发现<code>PropertyEditor</code> classes(无需显式注册)，如果它们与它们处理的 class 在同一个包中，并且与 class 具有相同的 name，并附加<code>Editor</code>。对于 example，可以使用以下 class 和 package 结构，这足以使<code>SomethingEditor</code> class 被识别并用作<code>Something</code> <code>Something</code> -typed properties。</p>
<pre><code>com
  chank
    pop
      Something
      SomethingEditor // the PropertyEditor for the Something class
</code></pre>
<p>请注意，您也可以在此处使用标准<code>BeanInfo</code> JavaBeans 机制(在某种程度上描述<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html">这里</a>)。以下 example 使用<code>BeanInfo</code>机制使用关联的 class 的 properties 显式注册一个或多个<code>PropertyEditor</code>实例：</p>
<pre><code>com
  chank
    pop
      Something
      SomethingBeanInfo // the BeanInfo for the Something class
</code></pre>
<p>引用的<code>SomethingBeanInfo</code> class 的以下 Java source code 将<code>CustomNumberEditor</code>与<code>Something</code> class 的<code>age</code> property 相关联：</p>
<pre><code>public class SomethingBeanInfo extends SimpleBeanInfo &#123;

    public PropertyDescriptor[] getPropertyDescriptors() &#123;
        try &#123;
            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
            PropertyDescriptor ageDescriptor = new PropertyDescriptor(&quot;age&quot;, Something.class) &#123;
                public PropertyEditor createPropertyEditor(Object bean) &#123;
                    return numberPE;
                &#125;;
            &#125;;
            return new PropertyDescriptor[] &#123; ageDescriptor &#125;;
        &#125;
        catch (IntrospectionException ex) &#123;
            throw new Error(ex.toString());
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="注册其他自定义-PropertyEditor-Implementations"><a href="#注册其他自定义-PropertyEditor-Implementations" class="headerlink" title="注册其他自定义 PropertyEditor Implementations"></a>注册其他自定义 PropertyEditor Implementations</h5><p>将 bean properties 设置为 string 值时，Spring IoC 容器最终使用标准 JavaBeans <code>PropertyEditor</code> implementations 将这些 strings 转换为 property 的复杂类型。 Spring pre-registers 一些自定义的<code>PropertyEditor</code> __mplement(用于 example，将表示为 string 的 class name 转换为<code>Class</code> object)。此外，Java 的标准 JavaBeans <code>PropertyEditor</code>查找机制允许适当地命名 class 并放置在与它提供支持的 class 相同的包中，以便可以自动找到它。</p>
<p>如果需要注册其他自定义<code>PropertyEditors</code>，可以使用多种机制。假设您有一个<code>BeanFactory</code> reference，最通常不方便或不推荐的手动方法是使用<code>ConfigurableBeanFactory</code>接口的<code>registerCustomEditor()</code>方法。另一个(稍微方便一点)机制是使用一个名为<code>CustomEditorConfigurer</code>的特殊 bean 工厂 post-processor。虽然你可以使用 bean factory post-processors 和<code>BeanFactory</code> __mplement，但<code>CustomEditorConfigurer</code>有一个嵌套的 property 设置，所以我们强烈建议你将它与<code>ApplicationContext</code>一起使用，你可以用类似的方式将它部署到任何其他 bean，并且可以自动检测它并应用。</p>
<p>请注意，所有 bean 工厂和 application 上下文都会自动使用多个 built-in property 编辑器，通过使用<code>BeanWrapper</code>来处理 property 转换。 <code>BeanWrapper</code>寄存器列在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beans-conversion">上一节</a>中的标准 property 编辑器。此外，<code>ApplicationContexts</code>还会覆盖或添加其他编辑器，以适合特定 application context 类型的方式处理资源查找。</p>
<p>标准 JavaBeans <code>PropertyEditor</code>实例用于将表示为 strings 的 property 值转换为 property 的实际复杂类型。您可以使用，bean factory post-processor，方便地将其他<code>PropertyEditor</code>实例的支持添加到<code>ApplicationContext</code>。</p>
<p>考虑以下 example，它定义了一个名为<code>ExoticType</code>的用户 class 和另一个名为<code>DependsOnExoticType</code>的 class，它需要<code>ExoticType</code>设置为 property：</p>
<pre><code>package example;

public class ExoticType &#123;

    private String name;

    public ExoticType(String name) &#123;
        this.name = name;
    &#125;
&#125;

public class DependsOnExoticType &#123;

    private ExoticType type;

    public void setType(ExoticType type) &#123;
        this.type = type;
    &#125;
&#125;
</code></pre>
<p>正确设置后，我们希望能够将 property 类型指定为 string，<code>PropertyEditor</code>转换为实际的<code>ExoticType</code>实例。以下 bean 定义显示了如何设置此关系：</p>
<pre><code>&lt;bean id=&quot;sample&quot; class=&quot;example.DependsOnExoticType&quot;&gt;
    &lt;property name=&quot;type&quot; value=&quot;aNameForExoticType&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><code>PropertyEditor</code> implementation 看起来类似于以下内容：</p>
<pre><code>// converts string representation to ExoticType object
package example;

public class ExoticTypeEditor extends PropertyEditorSupport &#123;

    public void setAsText(String text) &#123;
        setValue(new ExoticType(text.toUpperCase()));
    &#125;
&#125;
</code></pre>
<p>最后，以下 example 显示了如何使用<code>CustomEditorConfigurer</code>向<code>ApplicationContext</code>注册新的<code>PropertyEditor</code>，然后可以根据需要使用它：</p>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;
    &lt;property name=&quot;customEditors&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;example.ExoticType&quot; value=&quot;example.ExoticTypeEditor&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h6 id="使用-PropertyEditorRegistrar"><a href="#使用-PropertyEditorRegistrar" class="headerlink" title="使用 PropertyEditorRegistrar"></a>使用 PropertyEditorRegistrar</h6><p>使用 Spring 容器注册 property 编辑器的另一种机制是创建和使用<code>PropertyEditorRegistrar</code>。当您需要在几种不同情况下使用同一组 property 编辑器时，此界面特别有用。您可以编写相应的注册商，并在每种情况下重复使用它。 <code>PropertyEditorRegistrar</code>实例与名为<code>PropertyEditorRegistry</code>的接口一起使用，该接口由 Spring <code>BeanWrapper</code>(和<code>DataBinder</code>)实现。当与<code>CustomEditorConfigurer</code>(描述为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beans-conversion-customeditor-registration">这里</a>)一起使用时，<code>PropertyEditorRegistrar</code>实例特别方便，它们公开了一个名为<code>setPropertyEditorRegistrars(..)</code>的 property。以这种方式添加到<code>CustomEditorConfigurer</code>的<code>PropertyEditorRegistrar</code>实例可以很容易地与<code>DataBinder</code>和 Spring MVC 控制器共享。此外，它避免了在自定义编辑器上进行同步的需要：<code>PropertyEditorRegistrar</code>应该为每个 bean 创建尝试创建新的<code>PropertyEditor</code>实例。</p>
<p>以下 example 显示了如何创建自己的<code>PropertyEditorRegistrar</code> implementation：</p>
<pre><code>package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar &#123;

    public void registerCustomEditors(PropertyEditorRegistry registry) &#123;

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

        // you could register as many custom property editors as are required here...
    &#125;
&#125;
</code></pre>
<p>另请参阅<code>org.springframework.beans.support.ResourceEditorRegistrar</code>以了解 example <code>PropertyEditorRegistrar</code> implementation。请注意，在<code>registerCustomEditors(..)</code>方法的 implementation 中，它会为每个 property 编辑器创建新实例。</p>
<p>下一个 example 显示了如何配置<code>CustomEditorConfigurer</code>和 inject 一个<code>CustomPropertyEditorRegistrar</code>的实例：</p>
<pre><code>&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;
    &lt;property name=&quot;propertyEditorRegistrars&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;customPropertyEditorRegistrar&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customPropertyEditorRegistrar&quot;
    class=&quot;com.foo.editors.spring.CustomPropertyEditorRegistrar&quot;/&gt;
</code></pre>
<p>最后(并且与本章的重点有所不同，对于那些使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc">Spring 的 MVC web framework</a>的人来说)，将<code>PropertyEditorRegistrars</code>与 data-binding <code>Controllers</code>(例如<code>SimpleFormController</code>)结合使用可以非常方便。以下 example 在<code>initBinder(..)</code>方法的 implementation 中使用<code>PropertyEditorRegistrar</code>：</p>
<pre><code>public final class RegisterUserController extends SimpleFormController &#123;

    private final PropertyEditorRegistrar customPropertyEditorRegistrar;

    public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) &#123;
        this.customPropertyEditorRegistrar = propertyEditorRegistrar;
    &#125;

    protected void initBinder(HttpServletRequest request,
            ServletRequestDataBinder binder) throws Exception &#123;
        this.customPropertyEditorRegistrar.registerCustomEditors(binder);
    &#125;

    // other methods to do with registering a User
&#125;
</code></pre>
<p>这种<code>PropertyEditor</code>注册方式可以导致简洁的 code(<code>initBinder(..)</code>的实现只有一个 line long)，让 common <code>PropertyEditor</code> registration code 封装在 class 中，然后根据需要在<code>Controllers</code>之间共享。</p>
<h3 id="3-4-Spring-类型转换"><a href="#3-4-Spring-类型转换" class="headerlink" title="3.4. Spring 类型转换"></a>3.4. Spring 类型转换</h3><p>Spring 3 引入了一个<code>core.convert</code>包，它提供了一般的类型转换系统。系统定义了一个用于实现类型转换逻辑的 SPI 和一个用于在运行时执行类型转换的 API。在 Spring 容器中，您可以使用此系统替代<code>PropertyEditor</code> implementations 将外部化的 bean property value strings 转换为所需的 property 类型。您还可以在需要进行类型转换的 application 中的任何位置使用公共 API。</p>
<h4 id="3-4-1-转换器-SPI"><a href="#3-4-1-转换器-SPI" class="headerlink" title="3.4.1. 转换器 SPI"></a>3.4.1. 转换器 SPI</h4><p>实现类型转换逻辑的 SPI 很简单且类型很强，如下面的接口定义所示：</p>
<pre><code>package org.springframework.core.convert.converter;

public interface Converter&lt;S, T&gt; &#123;

    T convert(S source);
&#125;
</code></pre>
<p>要创建自己的转换器，请实现<code>Converter</code>接口并参数化<code>S</code>作为要转换的类型，并将<code>T</code>作为要转换的类型。如果<code>S</code>的集合或 array 需要转换为_ar或<code>T</code>的集合，您也可以透明地应用这样的转换器，前提是已经注册了委托的 array 或集合转换器(默认情况下<code>DefaultConversionService</code>)。</p>
<p>对于每次调用<code>convert(S)</code>，源参数都保证不为 null。如果转换失败，您的<code>Converter</code>可能会抛出任何未经检查的 exception。具体来说，它应该抛出<code>IllegalArgumentException</code>来报告无效的源 value。注意确保<code>Converter</code> implementation 是 thread-safe。</p>
<p>为方便起见，<code>core.convert.support</code>包中提供了几个转换器 implementation。这些包括从 strings 到 numbers 和其他 common 类型的转换器。以下清单显示了<code>StringToInteger</code> class，这是一个典型的<code>Converter</code> implementation：</p>
<pre><code>package org.springframework.core.convert.support;

final class StringToInteger implements Converter&lt;String, Integer&gt; &#123;

    public Integer convert(String source) &#123;
        return Integer.valueOf(source);
    &#125;
&#125;
</code></pre>
<h4 id="3-4-2-使用-ConverterFactory"><a href="#3-4-2-使用-ConverterFactory" class="headerlink" title="3.4.2. 使用 ConverterFactory"></a>3.4.2. 使用 ConverterFactory</h4><p>当您需要集中整个 class 层次结构的转换逻辑时(对于 example，当从 String 转换为 java.lang.Enum objects 时)，您可以实现<code>ConverterFactory</code>，如下面的 example 所示：</p>
<pre><code>package org.springframework.core.convert.converter;

public interface ConverterFactory&lt;S, R&gt; &#123;

    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);
&#125;
</code></pre>
<p>参数化 S 为要转换的类型，R 为定义可转换为 classes 范围的基本类型。然后实现 getConverter(Class <T>)，其中 T 是 R 的子类。</p>
<p>将<code>StringToEnum</code> <code>ConverterFactory</code>视为 example：</p>
<pre><code>package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory&lt;String, Enum&gt; &#123;

    public &lt;T extends Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) &#123;
        return new StringToEnumConverter(targetType);
    &#125;

    private final class StringToEnumConverter&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; &#123;

        private Class&lt;T&gt; enumType;

        public StringToEnumConverter(Class&lt;T&gt; enumType) &#123;
            this.enumType = enumType;
        &#125;

        public T convert(String source) &#123;
            return (T) Enum.valueOf(this.enumType, source.trim());
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="3-4-3-使用-GenericConverter"><a href="#3-4-3-使用-GenericConverter" class="headerlink" title="3.4.3. 使用 GenericConverter"></a>3.4.3. 使用 GenericConverter</h4><p>当您需要复杂的<code>Converter</code> implementation 时，请考虑使用<code>GenericConverter</code>接口。使用比<code>Converter</code>更灵活但不太强类型的签名，<code>GenericConverter</code>支持在多个源类型和目标类型之间进行转换。此外，<code>GenericConverter</code>使您可以在实现转换逻辑时使用的源和目标字段 context。这样的 context 允许类型转换由字段 annotation 或在字段签名上声明的通用信息驱动。以下清单显示了<code>GenericConverter</code>的接口定义：</p>
<pre><code>package org.springframework.core.convert.converter;

public interface GenericConverter &#123;

    public Set&lt;ConvertiblePair&gt; getConvertibleTypes();

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
&#125;
</code></pre>
<p>要实现<code>GenericConverter</code>，请return 支持的源→目标类型对。然后实现<code>convert(Object, TypeDescriptor, TypeDescriptor)</code>以包含转换逻辑。源<code>TypeDescriptor</code>提供对保存正在转换的 value 的源字段的访问。目标<code>TypeDescriptor</code>提供对要设置转换后的 value 的目标字段的访问。</p>
<p>的一个好示例是在 Java array 和集合之间进行转换的转换器。这样的<code>ArrayToCollectionConverter</code>内省了声明目标集合类型的字段来解析集合的元素类型。这样，在目标字段上设置集合之前，可以将源 array 中的每个元素转换为集合元素类型。</p>
<blockquote>
<p>因为<code>GenericConverter</code>是一个更复杂的 SPI 接口，所以只有在需要时才能使用它。支持<code>Converter</code>或<code>ConverterFactory</code>以满足基本类型转换需求。</p>
</blockquote>
<h5 id="使用-ConditionalGenericConverter"><a href="#使用-ConditionalGenericConverter" class="headerlink" title="使用 ConditionalGenericConverter"></a>使用 ConditionalGenericConverter</h5><p>有时，只有在特定条件保持 true 时才需要<code>Converter</code> run。例如，您可能希望仅在目标字段上存在特定 annotation 时运行<code>Converter</code>，或者只有在目标 class 上定义了特定方法(例如<code>static valueOf</code>方法)时才可能 run <code>Converter</code>。 <code>ConditionalGenericConverter</code>是<code>GenericConverter</code>和<code>ConditionalConverter</code>接口的 union，它允许您定义这样的自定义匹配条件：</p>
<pre><code>public interface ConditionalConverter &#123;

    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
&#125;

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter &#123;
&#125;
</code></pre>
<p>的良好示例是<code>EntityConverter</code>，它在持久实体标识符和实体 reference 之间进行转换。只有当目标实体类型声明静态查找器方法(对于 example，<code>findAccount(Long)</code>)时，这样的<code>EntityConverter</code>才可能 match。您可以在<code>matches(TypeDescriptor, TypeDescriptor)</code>的 implementation 中执行这样的 finder 方法检查。</p>
<h4 id="3-4-4-ConversionService-API"><a href="#3-4-4-ConversionService-API" class="headerlink" title="3.4.4. ConversionService API"></a>3.4.4. ConversionService API</h4><p><code>ConversionService</code>定义了一个统一的 API，用于在运行时执行类型转换逻辑。转换器通常在以下 Facade 接口后面执行：</p>
<pre><code>package org.springframework.core.convert;

public interface ConversionService &#123;

    boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);

    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);

    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

&#125;
</code></pre>
<p>大多数<code>ConversionService</code> implementations 也实现了<code>ConverterRegistry</code>，它提供了一个用于注册转换器的 SPI。在内部，<code>ConversionService</code> implementation 委托其注册的转换器执行类型转换逻辑。</p>
<p><code>core.convert.support</code>包中提供了强大的<code>ConversionService</code> implementation。 <code>GenericConversionService</code>是适合在大多数环境中使用的 general-purpose implementation。 <code>ConversionServiceFactory</code>为 creating common <code>ConversionService</code>配置提供了一个方便的工厂。</p>
<h4 id="3-4-5-配置-ConversionService"><a href="#3-4-5-配置-ConversionService" class="headerlink" title="3.4.5. 配置 ConversionService"></a>3.4.5. 配置 ConversionService</h4><p><code>ConversionService</code>是一个 stateless object，设计用于在 application 启动时实例化，然后在多个线程之间共享。在 Spring application 中，通常为每个 Spring 容器(或<code>ApplicationContext</code>)配置<code>ConversionService</code>实例。 Spring 选择<code>ConversionService</code>并在 framework 需要执行类型转换时使用它。您也可以_将此<code>ConversionService</code>注入任何 beans 并直接调用它。</p>
<blockquote>
<p>如果 Spring 没有注册<code>ConversionService</code>，则使用原始的<code>PropertyEditor</code> -based 系统。</p>
</blockquote>
<p>要使用 Spring 注册默认<code>ConversionService</code>，请使用<code>id</code> <code>conversionService</code>添加以下 bean 定义：</p>
<pre><code>&lt;bean id=&quot;conversionService&quot;
    class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;/&gt;
</code></pre>
<p>默认<code>ConversionService</code>可以在 strings，numbers，enums，collections，maps 和其他 common 类型之间进行转换。要使用您自己的自定义转换器补充或覆盖默认转换器，请设置<code>converters</code> property。 Property 值可以实现<code>Converter</code>，<code>ConverterFactory</code>或<code>GenericConverter</code>接口中的任何一个。</p>
<pre><code>&lt;bean id=&quot;conversionService&quot;
        class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;converters&quot;&gt;
        &lt;set&gt;
            &lt;bean class=&quot;example.MyCustomConverter&quot;/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>在 Spring MVC application 中使用<code>ConversionService</code>也是常见的。请参阅 Spring MVC 章节中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-conversion">转换和格式化</a>。</p>
<p>在某些情况下，您可能希望在转换期间应用格式。有关使用<code>FormattingConversionServiceFactoryBean</code>的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#format-FormatterRegistry-SPI">FormatterRegistry SPI</a>。</p>
<h4 id="3-4-6-以编程方式使用-ConversionService"><a href="#3-4-6-以编程方式使用-ConversionService" class="headerlink" title="3.4.6. 以编程方式使用 ConversionService"></a>3.4.6. 以编程方式使用 ConversionService</h4><p>要以编程方式使用<code>ConversionService</code>实例，您可以像对待任何其他 bean 一样引用 reference。以下 example 显示了如何执行此操作：</p>
<pre><code>@Service
public class MyService &#123;

    @Autowired
    public MyService(ConversionService conversionService) &#123;
        this.conversionService = conversionService;
    &#125;

    public void doIt() &#123;
        this.conversionService.convert(...)
    &#125;
&#125;
</code></pre>
<p>对于大多数用例，您可以使用指定<code>targetType</code>的<code>convert</code>方法，但它不适用于更复杂的类型，例如参数化元素的集合。例如，如果要以编程方式将<code>List</code> <code>Integer</code>转换为<code>List</code> <code>String</code>，则需要提供源和目标类型的正式定义。</p>
<p>幸运的是，<code>TypeDescriptor</code>提供了各种选项，使得这么简单，如下面的示例所示：</p>
<pre><code>DefaultConversionService cs = new DefaultConversionService();

List&lt;Integer&gt; input = ....
cs.convert(input,
    TypeDescriptor.forObject(input), // List&lt;Integer&gt; type descriptor
    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));
</code></pre>
<p>请注意，<code>DefaultConversionService</code>会自动注册适合大多数环境的转换器。这包括收集转换器，标量转换器和基本的<code>Object</code> -to - <code>String</code>转换器。您可以使用<code>DefaultConversionService</code> class 上的静态<code>addDefaultConverters</code>方法向任何<code>ConverterRegistry</code>注册相同的转换器。</p>
<p>value 类型的转换器可以重用于数组和集合，因此无需创建特定的转换器即可将<code>Collection</code> <code>S</code>转换为<code>Collection</code> <code>T</code>，假设标准集合处理是合适的。</p>
<h3 id="3-5-Spring-字段格式"><a href="#3-5-Spring-字段格式" class="headerlink" title="3.5. Spring 字段格式"></a>3.5. Spring 字段格式</h3><p>如前一节所述，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#core-convert">core.convert</a>是 general-purpose 类型转换系统。它提供了统一的<code>ConversionService</code> API 以及强类型的<code>Converter</code> SPI，用于实现从一种类型到另一种类型的转换逻辑。 Spring 容器使用此系统绑定 bean property 值。此外，Spring 表达式语言(SpEL)和<code>DataBinder</code>都使用此系统来绑定字段值。例如，当 SpEL 需要强制<code>Short</code>到<code>Long</code>以完成<code>expression.setValue(Object bean, Object value)</code>尝试时，<code>core.convert</code>系统执行强制。</p>
<p>现在考虑典型 client 环境的类型转换要求，例如 web 或 desktop application。在这样的环境中，您通常从<code>String</code>转换为支持 client postback process，以及返回<code>String</code>以支持视图呈现 process。此外，您经常需要本地化<code>String</code>值。更通用的<code>core.convert</code> <code>Converter</code> SPI 不直接解决此类格式化要求。为了直接解决它们，Spring 3 引入了一个方便的<code>Formatter</code> SPI，为 client 环境提供了一个简单而强大的<code>PropertyEditor</code> __mplement 选择。</p>
<p>通常，当需要实现 general-purpose 类型转换逻辑时，可以使用<code>Converter</code> SPI - 对于 example，用于在<code>java.util.Date</code>和<code>java.lang.Long</code>之间进行转换。在 client 环境(例如 web application)中工作时，可以使用<code>Formatter</code> SPI，并且需要解析和打印本地化的字段值。 <code>ConversionService</code>为两个 SPI 提供统一的类型转换 API。</p>
<h4 id="3-5-1-Formatter-SPI"><a href="#3-5-1-Formatter-SPI" class="headerlink" title="3.5.1. Formatter SPI"></a>3.5.1. Formatter SPI</h4><p>用于实现字段格式化逻辑的<code>Formatter</code> SPI 简单且强类型化。以下清单显示了<code>Formatter</code>接口定义：</p>
<pre><code>package org.springframework.format;

public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; &#123;
&#125;
</code></pre>
<p><code>Formatter</code>从<code>Printer</code>和<code>Parser</code> building-block 接口扩展。以下清单显示了这两个接口的定义：</p>
<pre><code>public interface Printer&lt;T&gt; &#123;

    String print(T fieldValue, Locale locale);
&#125;
</code></pre>
<pre><code>import java.text.ParseException;

public interface Parser&lt;T&gt; &#123;

    T parse(String clientValue, Locale locale) throws ParseException;
&#125;
</code></pre>
<p>要创建自己的<code>Formatter</code>，请实现前面显示的<code>Formatter</code>接口。将<code>T</code>参数化为要格式化的 object 的类型 - 对于 example，<code>java.util.Date</code>。实现<code>print()</code>操作以打印<code>T</code>的实例以在 client locale 中显示。实现<code>parse()</code>操作以从 client locale 返回的格式化表示中解析<code>T</code>的实例。如果解析尝试失败，您的<code>Formatter</code>应该抛出<code>ParseException</code>或<code>IllegalArgumentException</code>。注意确保<code>Formatter</code> implementation 是 thread-safe。</p>
<p>为方便起见，<code>format</code>子包提供了几个<code>Formatter</code> __mplement。 <code>number</code>包提供<code>NumberStyleFormatter</code>，<code>CurrencyStyleFormatter</code>和<code>PercentStyleFormatter</code>来格式化使用<code>java.text.NumberFormat</code>的<code>java.lang.Number</code> objects。 <code>datetime</code>包提供<code>DateFormatter</code>格式<code>java.util.Date</code> objects <code>java.text.DateFormat</code>。 <code>datetime.joda</code>包基于<a target="_blank" rel="noopener" href="http://joda-time.sourceforge.net/">Joda-Time library</a>提供全面的 datetime 格式支持。</p>
<p>以下<code>DateFormatter</code>是 example <code>Formatter</code> implementation：</p>
<pre><code>package org.springframework.format.datetime;

public final class DateFormatter implements Formatter&lt;Date&gt; &#123;

    private String pattern;

    public DateFormatter(String pattern) &#123;
        this.pattern = pattern;
    &#125;

    public String print(Date date, Locale locale) &#123;
        if (date == null) &#123;
            return &quot;&quot;;
        &#125;
        return getDateFormat(locale).format(date);
    &#125;

    public Date parse(String formatted, Locale locale) throws ParseException &#123;
        if (formatted.length() == 0) &#123;
            return null;
        &#125;
        return getDateFormat(locale).parse(formatted);
    &#125;

    protected DateFormat getDateFormat(Locale locale) &#123;
        DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
        dateFormat.setLenient(false);
        return dateFormat;
    &#125;
&#125;
</code></pre>
<p>Spring 团队欢迎 community-driven <code>Formatter</code>贡献见<a target="_blank" rel="noopener" href="https://jira.spring.io/browse/SPR">jira.spring.io</a>贡献。</p>
<h4 id="3-5-2-Annotation-driven-格式化"><a href="#3-5-2-Annotation-driven-格式化" class="headerlink" title="3.5.2. Annotation-driven 格式化"></a>3.5.2. Annotation-driven 格式化</h4><p>可以按字段类型或 annotation 配置字段格式。要将注释绑定到<code>Formatter</code>，请实现<code>AnnotationFormatterFactory</code>。以下清单显示了<code>AnnotationFormatterFactory</code>接口的定义：</p>
<pre><code>package org.springframework.format;

public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; &#123;

    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();

    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);

    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);
&#125;
</code></pre>
<p>创建 implementation :.将 A 参数化为要与格式逻辑关联的字段<code>annotationType</code> - 用于 example <code>org.springframework.format.annotation.DateTimeFormat</code>。 。 <code>getFieldTypes()</code> return 可以使用 annotation 的字段类型。 。 <code>getPrinter()</code> return <code>Printer</code>打印带注释字段的 value。 。 <code>getParser()</code> return <code>Parser</code>来解析带注释字段的<code>clientValue</code>。</p>
<p>以下 example <code>AnnotationFormatterFactory</code> implementation 将<code>@NumberFormat</code> annotation 绑定到格式化程序，以指定数字样式或 pattern：</p>
<pre><code>public final class NumberFormatAnnotationFormatterFactory
        implements AnnotationFormatterFactory&lt;NumberFormat&gt; &#123;

    public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() &#123;
        return new HashSet&lt;Class&lt;?&gt;&gt;(asList(new Class&lt;?&gt;[] &#123;
            Short.class, Integer.class, Long.class, Float.class,
            Double.class, BigDecimal.class, BigInteger.class &#125;));
    &#125;

    public Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) &#123;
        return configureFormatterFrom(annotation, fieldType);
    &#125;

    public Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) &#123;
        return configureFormatterFrom(annotation, fieldType);
    &#125;

    private Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation, Class&lt;?&gt; fieldType) &#123;
        if (!annotation.pattern().isEmpty()) &#123;
            return new NumberStyleFormatter(annotation.pattern());
        &#125; else &#123;
            Style style = annotation.style();
            if (style == Style.PERCENT) &#123;
                return new PercentStyleFormatter();
            &#125; else if (style == Style.CURRENCY) &#123;
                return new CurrencyStyleFormatter();
            &#125; else &#123;
                return new NumberStyleFormatter();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>要触发格式化，可以使用@NumberFormat 注释字段，如下面的 example 所示：</p>
<pre><code>public class MyModel &#123;

    @NumberFormat(style=Style.CURRENCY)
    private BigDecimal decimal;
&#125;
</code></pre>
<h5 id="格式-Annotation-API"><a href="#格式-Annotation-API" class="headerlink" title="格式 Annotation API"></a>格式 Annotation API</h5><p><code>org.springframework.format.annotation</code>包中存在可移植格式 annotation API。您可以使用<code>@NumberFormat</code>格式化 java.lang.Number 字段，使用<code>@DateTimeFormat</code>格式化<code>java.util.Date</code>，<code>java.util.Calendar</code>，<code>java.util.Long</code>或 Joda-Time 字段。</p>
<p>以下 example 使用<code>@DateTimeFormat</code>将<code>java.util.Date</code>格式化为 ISO Date(yyyy-MM-dd)：</p>
<pre><code>public class MyModel &#123;

    @DateTimeFormat(iso=ISO.DATE)
    private Date date;
&#125;
</code></pre>
<h4 id="3-5-3-FormatterRegistry-SPI"><a href="#3-5-3-FormatterRegistry-SPI" class="headerlink" title="3.5.3. FormatterRegistry SPI"></a>3.5.3. FormatterRegistry SPI</h4><p><code>FormatterRegistry</code>是用于注册格式化器和转换器的 SPI。 <code>FormattingConversionService</code>是适用于大多数环境的<code>FormatterRegistry</code>的 implementation。您可以使用<code>FormattingConversionServiceFactoryBean</code>以编程方式或声明性地将此 implementation 配置为 Spring bean。因为此 implementation 还实现<code>ConversionService</code>，所以您可以直接将其配置为与 Spring 的<code>DataBinder</code>和 Spring 表达式语言(SpEL)一起使用。</p>
<p>以下清单显示了<code>FormatterRegistry</code> SPI：</p>
<pre><code>package org.springframework.format;

public interface FormatterRegistry extends ConverterRegistry &#123;

    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);

    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);

    void addFormatterForFieldType(Formatter&lt;?&gt; formatter);

    void addFormatterForAnnotation(AnnotationFormatterFactory&lt;?, ?&gt; factory);
&#125;
</code></pre>
<p>如上面的清单所示，您可以按字段类型或 annotation 注册格式化程序。</p>
<p><code>FormatterRegistry</code> SPI 允许您集中配置格式规则，而不是在控制器之间复制此类配置。例如，您可能希望强制所有 date 字段以某种方式格式化，或者具有特定 annotation 的字段以某种方式格式化。使用共享<code>FormatterRegistry</code>，您可以定义一次这些规则，并且只要需要格式化，就会应用它们。</p>
<h4 id="3-5-4-FormatterRegistrar-SPI"><a href="#3-5-4-FormatterRegistrar-SPI" class="headerlink" title="3.5.4. FormatterRegistrar SPI"></a>3.5.4. FormatterRegistrar SPI</h4><p><code>FormatterRegistrar</code>是一个 SPI，用于通过 FormatterRegistry 注册格式化程序和转换器。以下清单显示了其接口定义：</p>
<pre><code>package org.springframework.format;

public interface FormatterRegistrar &#123;

    void registerFormatters(FormatterRegistry registry);
&#125;
</code></pre>
<p>在为给定格式类别注册多个相关转换器和格式化程序时，非常有用，例如 date 格式。它在声明性注册不足的情况下也很有用 - 例如，当格式化程序需要在与其自己的<code>&lt;T&gt;</code>不同的特定字段类型下编入索引时，或者在注册<code>Printer</code>/<code>Parser</code>对时。下一节提供有关转换器和格式化程序注册的更多信息。</p>
<h4 id="3-5-5-在-Spring-MVC-中配置格式"><a href="#3-5-5-在-Spring-MVC-中配置格式" class="headerlink" title="3.5.5. 在 Spring MVC 中配置格式"></a>3.5.5. 在 Spring MVC 中配置格式</h4><p>请参阅 Spring MVC 章节中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-conversion">转换和格式化</a>。</p>
<h3 id="3-6-配置-Global-Date-和-Time-格式"><a href="#3-6-配置-Global-Date-和-Time-格式" class="headerlink" title="3.6. 配置 Global Date 和 Time 格式"></a>3.6. 配置 Global Date 和 Time 格式</h3><p>默认情况下，使用<code>DateFormat.SHORT</code>样式从 strings 转换未使用<code>@DateTimeFormat</code>注释的 date 和 time 字段。如果您愿意，可以通过定义自己的 global 格式来更改此设置。</p>
<p>为此，您需要确保 Spring 不会注册默认格式化程序。相反，您应该手动注册所有格式化程序。使用<code>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code>或<code>org.springframework.format.datetime.DateFormatterRegistrar</code> class，具体取决于您是否使用 Joda-Time library。</p>
<p>例如，以下 Java configuration 注册 global <code>yyyyMMdd</code>格式(此 example 不依赖于 Joda-Time library)：</p>
<pre><code>@Configuration
public class AppConfig &#123;

    @Bean
    public FormattingConversionService conversionService() &#123;

        // Use the DefaultFormattingConversionService but do not register defaults
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

        // Ensure @NumberFormat is still supported
        conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

        // Register date conversion with a specific global format
        DateFormatterRegistrar registrar = new DateFormatterRegistrar();
        registrar.setFormatter(new DateFormatter(&quot;yyyyMMdd&quot;));
        registrar.registerFormatters(conversionService);

        return conversionService;
    &#125;
&#125;
</code></pre>
<p>如果您更喜欢 XML-based configuration，则可以使用<code>FormattingConversionServiceFactoryBean</code>。以下 example 显示了如何执行此操作(此 time 使用 Joda Time)：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&gt;

    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
        &lt;property name=&quot;registerDefaultFormatters&quot; value=&quot;false&quot; /&gt;
        &lt;property name=&quot;formatters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;org.springframework.format.number.NumberFormatAnnotationFormatterFactory&quot; /&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name=&quot;formatterRegistrars&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar&quot;&gt;
                    &lt;property name=&quot;dateFormatter&quot;&gt;
                        &lt;bean class=&quot;org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean&quot;&gt;
                            &lt;property name=&quot;pattern&quot; value=&quot;yyyyMMdd&quot;/&gt;
                        &lt;/bean&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<blockquote>
<p>Joda-Time 提供单独的不同类型来表示<code>date</code>，<code>time</code>和<code>date-time</code>值。应使用<code>JodaTimeFormatterRegistrar</code>的<code>dateFormatter</code>，<code>timeFormatter</code>和<code>dateTimeFormatter</code> properties 为每种类型配置不同的格式。 <code>DateTimeFormatterFactoryBean</code>提供了一种创建格式化程序的便捷方法。</p>
</blockquote>
<blockquote>
<p>如果您使用 Spring MVC，请记住明确配置使用的转换服务。对于 Java-based <code>@Configuration</code>，这意味着扩展<code>WebMvcConfigurationSupport</code> class 并覆盖<code>mvcConversionService()</code>方法。对于 XML，您应该使用<code>mvc:annotation-driven</code>元素的<code>conversion-service</code>属性。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-conversion">转换和格式化</a>。</p>
</blockquote>
<h3 id="3-7-Spring-验证"><a href="#3-7-Spring-验证" class="headerlink" title="3.7. Spring 验证"></a>3.7. Spring 验证</h3><p>Spring 3 为其验证支持引入了几项增强功能。首先，完全支持 JSR-303 Bean Validation API。其次，当以编程方式使用时，Spring 的<code>DataBinder</code>可以验证 objects 以及绑定它们。第三，Spring MVC 支持声明性地验证<code>@Controller</code>输入。</p>
<h4 id="3-7-1-JSR-303-Bean-Validation-API-概述"><a href="#3-7-1-JSR-303-Bean-Validation-API-概述" class="headerlink" title="3.7.1. JSR-303 Bean Validation API 概述"></a>3.7.1. JSR-303 Bean Validation API 概述</h4><p>JSR-303 标准化 Java 平台的验证约束声明和元数据。通过使用此 API，您可以使用声明性验证约束来注释域 model properties，并且运行时会强制执行它们。您可以使用多个 built-in 约束。您还可以定义自己的自定义约束。</p>
<p>考虑以下 example，它显示了一个带有两个 properties 的简单<code>PersonForm</code> model：</p>
<pre><code>public class PersonForm &#123;
    private String name;
    private int age;
&#125;
</code></pre>
<p>JSR-303 允许您为这些 properties 定义声明性验证约束，如下面的 example 所示：</p>
<pre><code>public class PersonForm &#123;

    @NotNull
    @Size(max=64)
    private String name;

    @Min(0)
    private int age;
&#125;
</code></pre>
<p>当 JSR-303 Validator 验证此 class 的实例时，将强制执行这些约束。</p>
<p>有关 JSR-303 和 JSR-349 的一般信息，请参阅<a target="_blank" rel="noopener" href="http://beanvalidation.org/">Bean 验证网站</a>。有关默认 reference implementation 的特定功能的信息，请参阅<a target="_blank" rel="noopener" href="https://www.hibernate.org/412.html">Hibernate Validator</a>文档。要了解如何将 bean 验证提供程序设置为 Spring bean，请继续阅读。</p>
<h4 id="3-7-2-配置-Bean-验证提供程序"><a href="#3-7-2-配置-Bean-验证提供程序" class="headerlink" title="3.7.2. 配置 Bean 验证提供程序"></a>3.7.2. 配置 Bean 验证提供程序</h4><p>Spring 完全支持 Bean Validation API。这包括方便地支持将 JSR-303 或 JSR-349 Bean 验证提供程序作为 Spring bean 引导。这使您可以在 application 中需要验证的地方注入<code>javax.validation.ValidatorFactory</code>或<code>javax.validation.Validator</code>。</p>
<p>您可以使用<code>LocalValidatorFactoryBean</code>将默认 Validator 配置为 Spring bean，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;validator&quot;
    class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;/&gt;
</code></pre>
<p>前面的 example 中的基本 configuration 通过使用其默认引导机制触发 bean 验证进行初始化。 或 JSR-349 提供程序(例如 Hibernate Validator)应该出现在 classpath 中并自动检测。</p>
<h5 id="注入验证器"><a href="#注入验证器" class="headerlink" title="注入验证器"></a>注入验证器</h5><p><code>LocalValidatorFactoryBean</code>同时实现<code>javax.validation.ValidatorFactory</code>和<code>javax.validation.Validator</code>，以及 Spring 的<code>org.springframework.validation.Validator</code>。您可以将这些接口中的任何一个 reference 注入到需要调用验证逻辑的 beans 中。</p>
<p>如果您希望直接使用 Bean Validation API，则可以_ _ject 引用<code>javax.validation.Validator</code>，如下面的 example 所示：</p>
<pre><code>import javax.validation.Validator;

@Service
public class MyService &#123;

    @Autowired
    private Validator validator;
</code></pre>
<p>如果您的 bean 需要 Spring Validation API，则可以 inject 引用<code>org.springframework.validation.Validator</code>，如下面的 example 所示：</p>
<pre><code>import org.springframework.validation.Validator;

@Service
public class MyService &#123;

    @Autowired
    private Validator validator;
&#125;
</code></pre>
<h5 id="配置自定义约束"><a href="#配置自定义约束" class="headerlink" title="配置自定义约束"></a>配置自定义约束</h5><p>每个 bean 验证约束由两部分组成：*声明约束的annotation 及其可配置的 properties。 *实现约束行为的<code>javax.validation.ConstraintValidator</code>接口的 implementation。</p>
<p>要将声明与 implementation 相关联，每个<code>@Constraint</code> annotation references 会引用相应的<code>ConstraintValidator</code> implementation class。在运行时，<code>ConstraintValidatorFactory</code>在域 model 中遇到约束 annotation 时实例化引用的 implementation。</p>
<p>默认情况下，<code>LocalValidatorFactoryBean</code>配置使用 Spring 创建<code>ConstraintValidator</code>实例的<code>SpringConstraintValidatorFactory</code>。这使得自定义<code>ConstraintValidators</code>从依赖注入中受益，就像任何其他 Spring bean 一样。</p>
<p>以下 example 显示了一个自定义<code>@Constraint</code>声明，后跟一个使用 Spring 进行依赖注入的关联<code>ConstraintValidator</code> implementation：</p>
<pre><code>@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class)
public @interface MyConstraint &#123;
&#125;
</code></pre>
<pre><code>import javax.validation.ConstraintValidator;

public class MyConstraintValidator implements ConstraintValidator &#123;

    @Autowired;
    private Foo aDependency;

    ...
&#125;
</code></pre>
<p>如前面的 example 所示，<code>ConstraintValidator</code> implementation 可以将其依赖项<code>@Autowired</code>与任何其他 Spring bean 一样。</p>
<h5 id="Spring-driven-方法验证"><a href="#Spring-driven-方法验证" class="headerlink" title="Spring-driven 方法验证"></a>Spring-driven 方法验证</h5><p>您可以通过<code>MethodValidationPostProcessor</code> bean 定义将 Bean Validation 1.1 支持的方法验证 feature(以及作为自定义扩展，也可以通过 Hibernate Validator 4.3)集成到 Spring context 中，如下所示：</p>
<pre><code>&lt;bean class=&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;/&gt;
</code></pre>
<p>要符合 Spring-driven 方法验证的条件，所有目标 classes 都需要使用 Spring 的<code>@Validated</code> annotation 进行注释。 (或者，您也可以将验证组声明为 use.)使用 Hibernate Validator 和 Bean Validation 1.1 提供程序查看<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.html">MethodValidationPostProcessor</a> javadoc 以获取设置详细信息。</p>
<h5 id="其他-Configuration-选项"><a href="#其他-Configuration-选项" class="headerlink" title="其他 Configuration 选项"></a>其他 Configuration 选项</h5><p>对于大多数情况，默认的<code>LocalValidatorFactoryBean</code> configuration 足够了。从消息插值到遍历解析，各种 Bean 验证结构有许多 configuration 选项。有关这些选项的更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html">LocalValidatorFactoryBean</a> javadoc。</p>
<h4 id="3-7-3-配置-DataBinder"><a href="#3-7-3-配置-DataBinder" class="headerlink" title="3.7.3. 配置 DataBinder"></a>3.7.3. 配置 DataBinder</h4><p>从 Spring 3 开始，您可以使用<code>Validator</code>配置<code>DataBinder</code>实例。配置完成后，您可以通过调用<code>binder.validate()</code>来调用<code>Validator</code>。任何验证<code>Errors</code>都会自动添加到 binder 的<code>BindingResult</code>中。</p>
<p>以下 example 显示了如何在 binding 到目标 object 之后以编程方式使用<code>DataBinder</code>来调用验证逻辑：</p>
<pre><code>Foo target = new Foo();
DataBinder binder = new DataBinder(target);
binder.setValidator(new FooValidator());

// bind to the target object
binder.bind(propertyValues);

// validate the target object
binder.validate();

// get BindingResult that includes any validation errors
BindingResult results = binder.getBindingResult();
</code></pre>
<p>您还可以通过<code>dataBinder.addValidators</code>和<code>dataBinder.replaceValidators</code>配置具有多个<code>Validator</code>实例的<code>DataBinder</code>。将全局配置的 bean 验证与在 DataBinder 实例上本地配置的 Spring <code>Validator</code>组合时，这非常有用。见[<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#validation-mvc-configuring">validation-mvc-configuring]</a>。</p>
<h4 id="3-7-4-Spring-MVC-3-验证"><a href="#3-7-4-Spring-MVC-3-验证" class="headerlink" title="3.7.4. Spring MVC 3 验证"></a>3.7.4. Spring MVC 3 验证</h4><p>请参阅 Spring MVC 章节中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-validation">验证</a>。</p>
<h2 id="4-Spring-表达语言-SpEL"><a href="#4-Spring-表达语言-SpEL" class="headerlink" title="4. Spring 表达语言(SpEL)"></a>4. Spring 表达语言(SpEL)</h2><p>Spring 表达式语言(简称“SpEL”)是一种强大的表达式语言，支持在运行时查询和操作 object 图。语言语法类似于 Unified EL，但提供了额外的 features，最值得注意的是方法调用和基本的 string 模板功能。</p>
<p>虽然有几种其他 Java 表达式语言可供选择–OGNL，MVEL 和 JBoss EL，但只有少数几个 - 创建了 Spring 表达式语言，以便为 Spring 社区提供一种支持良好的表达式语言，可以在所有产品中使用。 Spring 组合。其语言 features 由 Spring 产品组合中的项目要求驱动，包括 Eclipse-based Spring 工具套件中 code 完成支持的工具要求。也就是说，SpEL 基于一个 technology-agnostic API，可以在需要时集成其他表达式语言 implementation。</p>
<p>虽然 SpEL 是 Spring 组合中表达式 evaluation 的基础，但它并不直接与 Spring 绑定，可以单独使用。要自包含，本章中的许多示例都使用 SpEL，就像它是一种独立的表达式语言一样。这需要创建一些引导基础结构 classes，例如解析器。大多数 Spring 用户不需要处理这种基础结构，而只能为 evaluation 创建表达式 strings。这种典型用法的一个例子是将_Spel 整合到创建 XML 或 annotation-based bean 定义中，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-beandef">表达式支持定义 bean 定义</a>所示。</p>
<p>本章介绍表达式语言的 features，其 API 及其语言语法。在几个地方，<code>Inventor</code>和<code>Society</code> classes 用作表达式 evaluation 的目标 objects。这些 class 声明和用于填充它们的数据列在本章末尾。</p>
<p>表达式语言支持以下功能：</p>
<ul>
<li>文字表达</li>
<li>Boolean 和关系 operators</li>
<li>常用表达</li>
<li>Class 表达式</li>
<li>访问 properties，数组，lists 和 maps</li>
<li>方法调用</li>
<li>关系运算符</li>
<li>分配</li>
<li>调用构造函数</li>
<li>Bean references</li>
<li>Array 建设</li>
<li>内联列表</li>
<li>内联 maps</li>
<li>三元运营商</li>
<li>变量</li>
<li>User-defined 功能</li>
<li>收集投影</li>
<li>收藏品选择</li>
<li>模板化的表达</li>
</ul>
<h3 id="4-1-Evaluation"><a href="#4-1-Evaluation" class="headerlink" title="4.1. Evaluation"></a>4.1. Evaluation</h3><p>本节介绍 SpEL 接口及其表达式语言的简单使用。完整的语言 reference 可以在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-language-ref">语言参考</a>中找到。</p>
<p>以下 code 引入了 SpEL API 来评估文字 string 表达式<code>Hello World</code>。</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;&#39;Hello World&#39;&quot;); (1)
String message = (String) exp.getValue();
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>消息变量的 value 是<code>&#39;Hello World&#39;</code>。</td>
</tr>
</tbody></table>
<p>您最有可能使用的 SpEL classes 和接口位于<code>org.springframework.expression</code>包及其 sub-packages 中，例如<code>spel.support</code>。</p>
<p><code>ExpressionParser</code>接口负责解析表达式 string。在前面的 example 中，表达式 string 是由周围的单引号表示的 string 文字。 <code>Expression</code>接口负责评估先前定义的表达式 string。分别调用<code>parser.parseExpression</code>和<code>exp.getValue</code>时，可以抛出两个 exceptions，<code>ParseException</code>和<code>EvaluationException</code>。</p>
<p>SpEL 支持各种 features，例如调用方法，访问 properties 和调用构造函数。</p>
<p>在下面的方法调用示例中，我们在 string 文字上调用<code>concat</code>方法：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;&#39;Hello World&#39;.concat(&#39;!&#39;)&quot;); (1)
String message = (String) exp.getValue();
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>message</code>的值现在是’Hello World！’。</td>
</tr>
</tbody></table>
<p>以下_示例调用 JavaBean property calls <code>String</code> property <code>Bytes</code>：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();

// invokes &#39;getBytes()&#39;
Expression exp = parser.parseExpression(&quot;&#39;Hello World&#39;.bytes&quot;); (1)
byte[] bytes = (byte[]) exp.getValue();
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>此 line 将文字转换为字节 array。</td>
</tr>
</tbody></table>
<p>SpEL 还通过使用标准点表示法(例如<code>prop1.prop2.prop3</code>)和 property 值的设置来支持嵌套的 properties。也可以访问公共字段。以下 example 显示了如何使用点表示法来获取文字的长度：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();

// invokes &#39;getBytes().length&#39;
Expression exp = parser.parseExpression(&quot;&#39;Hello World&#39;.bytes.length&quot;); (1)
int length = (Integer) exp.getValue();
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>&#39;Hello World&#39;.bytes.length</code>给出了文字的长度。</td>
</tr>
</tbody></table>
<p>可以调用 String 的构造函数而不是使用 string 文字，如下面的 example 所示：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;new String(&#39;hello world&#39;).toUpperCase()&quot;); (1)
String message = exp.getValue(String.class);
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>从文字构造一个新的<code>String</code>并使其成为大写。</td>
</tr>
</tbody></table>
<p>请注意泛型方法的使用：<code>public &lt;T&gt; T getValue(Class&lt;T&gt; desiredResultType)</code>。使用此方法无需将表达式的 value 强制转换为所需的结果类型。如果无法将 value 强制转换为<code>T</code>类型或使用已注册的类型转换器进行转换，则抛出<code>EvaluationException</code>。</p>
<p>SpEL 的更常见用法是提供一个表达式 string，该表达式是针对特定的 object 实例(称为 root object)进行评估的。以下 example 显示了如何从<code>Inventor</code> class 的实例检索<code>name</code> property 或创建 boolean 条件：</p>
<pre><code>// Create and set a calendar
GregorianCalendar c = new GregorianCalendar();
c.set(1856, 7, 9);

// The constructor arguments are name, birthday, and nationality.
Inventor tesla = new Inventor(&quot;Nikola Tesla&quot;, c.getTime(), &quot;Serbian&quot;);

ExpressionParser parser = new SpelExpressionParser();

Expression exp = parser.parseExpression(&quot;name&quot;); (1)
String name = (String) exp.getValue(tesla);
// name == &quot;Nikola Tesla&quot;

exp = parser.parseExpression(&quot;name == &#39;Nikola Tesla&#39;&quot;);
boolean result = exp.getValue(tesla, Boolean.class);
// result == true
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>将<code>name</code>解析为表达式。</td>
</tr>
</tbody></table>
<h4 id="4-1-1-了解-EvaluationContext"><a href="#4-1-1-了解-EvaluationContext" class="headerlink" title="4.1.1. 了解 EvaluationContext"></a>4.1.1. 了解 EvaluationContext</h4><p>在评估表达式以解析 properties，方法或字段以及帮助执行类型转换时，将使用<code>EvaluationContext</code>接口。 Spring 提供了两个 implementations。</p>
<ul>
<li><code>SimpleEvaluationContext</code>：为不需要 SpEL 语言语法的完整范围的表达式类别公开必要的 SpEL 语言 features 和 configuration 选项的子集，并且应该有意义地限制它们。示例包括但不限于数据 binding 表达式和 property-based 过滤器。</li>
<li><code>StandardEvaluationContext</code>：公开全套 SpEL 语言 features 和 configuration 选项。您可以使用它来指定默认的根 object 并配置每个可用的 evaluation-related 策略。</li>
</ul>
<p><code>SimpleEvaluationContext</code>旨在仅支持 SpEL 语言语法的子集。它排除了 Java 类型 references，构造函数和 bean references。它还要求您明确选择表达式中 properties 和方法的 level 支持。默认情况下，<code>create()</code>静态工厂方法仅启用对 properties 的读访问权限。您还可以获取构建器以配置所需支持的确切 level，并针对以下一项或多项组合：</p>
<ul>
<li>仅自定义<code>PropertyAccessor</code>(无反射)</li>
<li>read-only 访问的数据 binding properties</li>
<li>数据 binding properties 用于读写</li>
</ul>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>默认情况下，SpEL 使用 Spring 核心(<code>org.springframework.core.convert.ConversionService</code>)中提供的转换服务。此转换服务附带了许多用于 common 转换的 built-in 转换器，但也是完全可扩展的，因此您可以在类型之间添加自定义转换。另外，它是 generics-aware。这意味着，当您在表达式中使用泛型类型时，SpEL 会尝试转换以维护它遇到的任何 objects 的类型正确性。</p>
<p>这在实践中意味着什么？假设使用<code>setValue()</code>的赋值用于设置<code>List</code> property。 property 的类型实际上是<code>List&lt;Boolean&gt;</code>。 SpEL 识别出列表中的元素在放入之前需要转换为<code>Boolean</code>。以下 example 显示了如何执行此操作：</p>
<pre><code>class Simple &#123;
    public List&lt;Boolean&gt; booleanList = new ArrayList&lt;Boolean&gt;();
&#125;

Simple simple = new Simple();
simple.booleanList.add(true);

EvaluationContext context = SimpleEvaluationContext().forReadOnlyDataBinding().build();

// false is passed in here as a string. SpEL and the conversion service
// correctly recognize that it needs to be a Boolean and convert it
parser.parseExpression(&quot;booleanList[0]&quot;).setValue(context, simple, &quot;false&quot;);

// b is false
Boolean b = simple.booleanList.get(0);
</code></pre>
<h4 id="4-1-2-解析器-Configuration"><a href="#4-1-2-解析器-Configuration" class="headerlink" title="4.1.2. 解析器 Configuration"></a>4.1.2. 解析器 Configuration</h4><p>可以使用解析器 configuration object(<code>org.springframework.expression.spel.SpelParserConfiguration</code>)配置 SpEL 表达式解析器。 configuration object 控制某些表达式组件的行为。对于 example，如果索引到 array 或集合并且指定索引处的元素是<code>null</code>，则可以自动创建该元素。当使用由 property references 链组成的表达式时，这很有用。如果索引到 array 或列表并指定超出 array 或列表当前大小末尾的索引，则可以自动增大 array 或 list 以适应该索引。以下 example 演示了如何自动增长列表：</p>
<pre><code>class Demo &#123;
    public List&lt;String&gt; list;
&#125;

// Turn on:
// - auto null reference initialization
// - auto collection growing
SpelParserConfiguration config = new SpelParserConfiguration(true,true);

ExpressionParser parser = new SpelExpressionParser(config);

Expression expression = parser.parseExpression(&quot;list[3]&quot;);

Demo demo = new Demo();

Object o = expression.getValue(demo);

// demo.list will now be a real collection of 4 entries
// Each entry is a new empty String
</code></pre>
<h4 id="4-1-3-SpEL-编译"><a href="#4-1-3-SpEL-编译" class="headerlink" title="4.1.3. SpEL 编译"></a>4.1.3. SpEL 编译</h4><p>Spring Framework 4.1 包含一个基本的表达式编译器。表达式通常被解释，在 evaluation 期间提供了很多动态灵活性，但是没有提供最佳的 performance。对于偶尔的表达式使用，这很好，但是，当其他组件(如 Spring Integration)使用时，performance 非常重要，并且不需要动态。</p>
<p>SpEL 编译器旨在满足此需求。在 evaluation 期间，编译器生成一个真正的 Java class，它体现了表达式行为，并使用它来实现更快的表达式 evaluation。由于缺少表达式的 typing，编译器使用在执行编译时对表达式的解释评估期间收集的信息。对于 example，它不完全从表达式中知道 property reference 的类型，但是，在第一次解释 evaluation 期间，它会发现它是什么。当然，如果各种表达式元素的类型在 time 内发生变化，那么基于此信息的编译可能会导致以后出现问题。因此，编译最适合于类型信息在重复评估时不会改变的表达式。</p>
<p>请考虑以下基本表达式：</p>
<pre><code>someArray[0].someProperty.someOtherProperty &lt; 0.1
</code></pre>
<p>因为前面的表达式涉及 array 访问，一些 property de-referencing 和数值运算，所以 performance 增益非常明显。在一个 50000 次迭代的 example 微基准运行中，使用 interpreter 进行评估需要 75ms，使用表达式的编译 version 只需要 3ms。</p>
<h5 id="编译器-Configuration"><a href="#编译器-Configuration" class="headerlink" title="编译器 Configuration"></a>编译器 Configuration</h5><p>默认情况下，编译器未打开，但您可以通过两种不同的方式打开它。您可以使用解析器 configuration process(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-parser-configuration">之前讨论过</a>)或在将 SpEL 用法嵌入到另一个 component 中时使用系统 property 来打开它。本节讨论这两个选项。</p>
<p>编译器可以以三种模式之一运行，这些模式在<code>org.springframework.expression.spel.SpelCompilerMode</code> enum 中捕获。模式如下：</p>
<ul>
<li><code>OFF</code>(默认值)：编译器已关闭。</li>
<li><code>IMMEDIATE</code>：在立即模式下，表达式会尽快编译。这通常是在第一次解释 evaluation 之后。如果编译的表达式失败(通常是由于类型更改，如前所述)，则表达式 evaluation 的调用者会收到 exception。</li>
<li><code>MIXED</code>：在混合模式下，表达式在 time 上以静默方式在解释和编译模式之间切换。经过一定数量的解释运行后，它们会切换到编译形式，如果编译后的表单出现问题(如类型更改，如前所述)，表达式会自动再次切换回解释形式。稍后，它可能会生成另一个编译的表单并切换到它。基本上，用户在<code>IMMEDIATE</code>模式下获得的 exception 是在内部处理的。</li>
</ul>
<p>存在<code>IMMEDIATE</code>模式，因为<code>MIXED</code>模式可能会导致具有副作用的表达式出现问题。如果编译后的表达式在部分成功后爆炸，则可能已经完成了影响系统 state 的事情。如果发生这种情况，调用者可能不希望它在解释模式下静默 re-run，因为表达式的一部分可能会运行两次。</p>
<p>选择模式后，使用<code>SpelParserConfiguration</code>配置解析器。以下 example 显示了如何执行此操作：</p>
<pre><code>SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
    this.getClass().getClassLoader());

SpelExpressionParser parser = new SpelExpressionParser(config);

Expression expr = parser.parseExpression(&quot;payload&quot;);

MyMessage message = new MyMessage();

Object payload = expr.getValue(message);
</code></pre>
<p>指定编译器模式时，还可以指定类加载器(允许传递 null)。编译表达式在提供的任何提供的 child 类加载器中定义。重要的是要确保，如果指定了类加载器，它可以看到表达式 evaluation process 中涉及的所有类型。如果未指定类加载器，则使用默认的类加载器(通常是在表达式 evaluation 期间 running 的线程的 context 类加载器)。</p>
<p>配置编译器的第二种方法是在 SpEL 嵌入到某个其他 component 中时使用，并且可能无法通过 configuration object 对其进行配置。在这些情况下，可以使用 system property。您可以将<code>spring.expression.compiler.mode</code> property 设置为<code>SpelCompilerMode</code> enum 值之一(<code>off</code>，<code>immediate</code>或<code>mixed</code>)。</p>
<h5 id="编译器限制"><a href="#编译器限制" class="headerlink" title="编译器限制"></a>编译器限制</h5><p>自 Spring Framework 4.1 以来，基本的编译 framework 就位。但是，framework 还不支持编译每种表达式。最初的重点是可能在 performance-critical 上下文中使用的 common 表达式。无法在 moment 中编译以下类型的表达式：</p>
<ul>
<li>涉及转让的表达</li>
<li>表达式依赖于转换服务</li>
<li>表达式使用自定义解析器或访问器</li>
<li>使用选择或投影的表达式</li>
</ul>
<p>将来可以编写更多类型的表达式。</p>
<h3 id="4-2-Bean-定义中的表达式"><a href="#4-2-Bean-定义中的表达式" class="headerlink" title="4.2. Bean 定义中的表达式"></a>4.2. Bean 定义中的表达式</h3><p>您可以将带有 XML-based 或 annotation-based configuration 元数据的 SpEL 表达式用于定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法都是<code>#&#123; &lt;expression string&gt; &#125;</code>形式。</p>
<h4 id="4-2-1-XML-Configuration"><a href="#4-2-1-XML-Configuration" class="headerlink" title="4.2.1. XML Configuration"></a>4.2.1. XML Configuration</h4><p>可以使用表达式设置 property 或构造函数参数 value，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;numberGuess&quot; class=&quot;org.spring.samples.NumberGuess&quot;&gt;
    &lt;property name=&quot;randomNumber&quot; value=&quot;#&#123; T(java.lang.Math).random() * 100.0 &#125;&quot;/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;
</code></pre>
<p><code>systemProperties</code>变量是预定义的，因此您可以在表达式中使用它，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;taxCalculator&quot; class=&quot;org.spring.samples.TaxCalculator&quot;&gt;
    &lt;property name=&quot;defaultLocale&quot; value=&quot;#&#123; systemProperties[&#39;user.region&#39;] &#125;&quot;/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;
</code></pre>
<p>请注意，您不必在此 context 中使用<code>#</code>符号为预定义变量添加前缀。</p>
<p>您还可以通过 name 引用其他 bean properties，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;numberGuess&quot; class=&quot;org.spring.samples.NumberGuess&quot;&gt;
    &lt;property name=&quot;randomNumber&quot; value=&quot;#&#123; T(java.lang.Math).random() * 100.0 &#125;&quot;/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;

&lt;bean id=&quot;shapeGuess&quot; class=&quot;org.spring.samples.ShapeGuess&quot;&gt;
    &lt;property name=&quot;initialShapeSeed&quot; value=&quot;#&#123; numberGuess.randomNumber &#125;&quot;/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="4-2-2-Annotation-Configuration"><a href="#4-2-2-Annotation-Configuration" class="headerlink" title="4.2.2. Annotation Configuration"></a>4.2.2. Annotation Configuration</h4><p>要指定默认 value，可以将<code>@Value</code> annotation 放在字段，方法和方法或构造函数参数上。</p>
<p>以下 example _set 字段变量的默认 value：</p>
<pre><code>public static class FieldValueTestBean

    @Value(&quot;#&#123; systemProperties[&#39;user.region&#39;] &#125;&quot;)
    private String defaultLocale;

    public void setDefaultLocale(String defaultLocale) &#123;
        this.defaultLocale = defaultLocale;
    &#125;

    public String getDefaultLocale() &#123;
        return this.defaultLocale;
    &#125;

&#125;
</code></pre>
<p>以下 example 显示了等效但在 property setter 方法上：</p>
<pre><code>public static class PropertyValueTestBean

    private String defaultLocale;

    @Value(&quot;#&#123; systemProperties[&#39;user.region&#39;] &#125;&quot;)
    public void setDefaultLocale(String defaultLocale) &#123;
        this.defaultLocale = defaultLocale;
    &#125;

    public String getDefaultLocale() &#123;
        return this.defaultLocale;
    &#125;

&#125;
</code></pre>
<p>自动化方法和构造函数也可以使用<code>@Value</code> annotation，如以下示例所示：</p>
<pre><code>public class SimpleMovieLister &#123;

    private MovieFinder movieFinder;
    private String defaultLocale;

    @Autowired
    public void configure(MovieFinder movieFinder,
            @Value(&quot;#&#123; systemProperties[&#39;user.region&#39;] &#125;&quot;) String defaultLocale) &#123;
        this.movieFinder = movieFinder;
        this.defaultLocale = defaultLocale;
    &#125;

    // ...
&#125;
</code></pre>
<pre><code>public class MovieRecommender &#123;

    private String defaultLocale;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao,
            @Value(&quot;#&#123;systemProperties[&#39;user.country&#39;]&#125;&quot;) String defaultLocale) &#123;
        this.customerPreferenceDao = customerPreferenceDao;
        this.defaultLocale = defaultLocale;
    &#125;

    // ...
&#125;
</code></pre>
<h3 id="4-3-语言参考"><a href="#4-3-语言参考" class="headerlink" title="4.3. 语言参考"></a>4.3. 语言参考</h3><p>本节介绍 Spring 表达式语言的工作原理。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-ref-literal">文字表达</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-properties-arrays">Properties，Arrays，Lists，Maps 和 Indexers</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-inline-lists">内联列表</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-inline-maps">内联 Maps</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-array-construction">Array Construction</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-methods">方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators">Operators</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-types">类型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-constructors">构造函数</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-ref-variables">变量</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-ref-functions">功能</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-bean-references">Bean References</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operator-ternary">三元操作员(If-Then-Else)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operator-elvis">Elvis Operator</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operator-safe-navigation">安全导航操作员</a></li>
</ul>
<h4 id="4-3-1-文字表达"><a href="#4-3-1-文字表达" class="headerlink" title="4.3.1. 文字表达"></a>4.3.1. 文字表达</h4><p>支持的文字表达式的类型是 strings，数值(int，real，hex)， boolean 和 null。 Strings 由单引号分隔。要在 string 中放置单引号，请使用两个单引号字符。</p>
<p>以下清单显示了 literals 的简单用法。通常，它们不是像这样单独使用，而是作为更复杂表达式的一部分使用 - 例如，在逻辑比较 operator 的一侧使用文字。</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();

// evals to &quot;Hello World&quot;
String helloWorld = (String) parser.parseExpression(&quot;&#39;Hello World&#39;&quot;).getValue();

double avogadrosNumber = (Double) parser.parseExpression(&quot;6.0221415E+23&quot;).getValue();

// evals to 2147483647
int maxValue = (Integer) parser.parseExpression(&quot;0x7FFFFFFF&quot;).getValue();

boolean trueValue = (Boolean) parser.parseExpression(&quot;true&quot;).getValue();

Object nullValue = parser.parseExpression(&quot;null&quot;).getValue();
</code></pre>
<p>Numbers 支持使用负号，指数表示法和 decimal 点。默认情况下，使用 Double.parseDouble()解析实 numbers。</p>
<h4 id="4-3-2-Properties，Arrays，Lists，Maps-和-Indexers"><a href="#4-3-2-Properties，Arrays，Lists，Maps-和-Indexers" class="headerlink" title="4.3.2. Properties，Arrays，Lists，Maps 和 Indexers"></a>4.3.2. Properties，Arrays，Lists，Maps 和 Indexers</h4><p>使用 property references 进行导航很容易。为此，请使用句点指示嵌套的 property value。 <code>Inventor</code> class，<code>pupin</code>和<code>tesla</code>的实例填充了<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-example-classes">示例中使用的类</a>部分中列出的数据。为了“向下”导航并获得特斯拉的出生年份和普平的出生城市，我们使用以下表达式：</p>
<pre><code>// evals to 1856
int year = (Integer) parser.parseExpression(&quot;Birthdate.Year + 1900&quot;).getValue(context);

String city = (String) parser.parseExpression(&quot;placeOfBirth.City&quot;).getValue(context);
</code></pre>
<p>property 名称的第一个字母允许不区分大小写。数组和 lists 的内容是使用方括号表示法获得的，如下例所示：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// Inventions Array

// evaluates to &quot;Induction motor&quot;
String invention = parser.parseExpression(&quot;inventions[3]&quot;).getValue(
        context, tesla, String.class);

// Members List

// evaluates to &quot;Nikola Tesla&quot;
String name = parser.parseExpression(&quot;Members[0].Name&quot;).getValue(
        context, ieee, String.class);

// List and Array navigation
// evaluates to &quot;Wireless communication&quot;
String invention = parser.parseExpression(&quot;Members[0].Inventions[6]&quot;).getValue(
        context, ieee, String.class);
</code></pre>
<p>maps 的内容是通过在括号内指定文字 key value 获得的。在下面的 example 中，因为<code>Officers</code> map 的键是 strings，我们可以指定 string literals：</p>
<pre><code>// Officer&#39;s Dictionary

Inventor pupin = parser.parseExpression(&quot;Officers[&#39;president&#39;]&quot;).getValue(
        societyContext, Inventor.class);

// evaluates to &quot;Idvor&quot;
String city = parser.parseExpression(&quot;Officers[&#39;president&#39;].PlaceOfBirth.City&quot;).getValue(
        societyContext, String.class);

// setting values
parser.parseExpression(&quot;Officers[&#39;advisors&#39;][0].PlaceOfBirth.Country&quot;).setValue(
        societyContext, &quot;Croatia&quot;);
</code></pre>
<h4 id="4-3-3-内联列表"><a href="#4-3-3-内联列表" class="headerlink" title="4.3.3. 内联列表"></a>4.3.3. 内联列表</h4><p>您可以使用<code>&#123;&#125;</code>表示法直接在表达式中表达 lists。</p>
<pre><code>// evaluates to a Java list containing the four numbers
List numbers = (List) parser.parseExpression(&quot;&#123;1,2,3,4&#125;&quot;).getValue(context);

List listOfLists = (List) parser.parseExpression(&quot;&#123;&#123;'a','b'&#125;,&#123;'x','y'&#125;&#125;&quot;).getValue(context);
</code></pre>
<p><code>&#123;&#125;</code>本身表示空列表。出于性能原因，如果列表本身完全由固定的_literal 组成，则会创建一个常量列表来表示表达式(而不是在每个 evaluation 上构建一个新列表)。</p>
<h4 id="4-3-4-内联-Maps"><a href="#4-3-4-内联-Maps" class="headerlink" title="4.3.4. 内联 Maps"></a>4.3.4. 内联 Maps</h4><p>您还可以使用<code>&#123;key:value&#125;</code>表示法直接在表达式中表达 maps。以下 example 显示了如何执行此操作：</p>
<pre><code>// evaluates to a Java map containing the two entries
Map inventorInfo = (Map) parser.parseExpression(&quot;&#123;name:&#39;Nikola&#39;,dob:&#39;10-July-1856&#39;&#125;&quot;).getValue(context);

Map mapOfMaps = (Map) parser.parseExpression(&quot;&#123;name:&#123;first:&#39;Nikola&#39;,last:&#39;Tesla&#39;&#125;,dob:&#123;day:10,month:&#39;July&#39;,year:1856&#125;&#125;&quot;).getValue(context);
</code></pre>
<p><code>&#123;:&#125;</code>本身表示空 map。出于性能原因，如果 map 本身由固定的_lite 或其他嵌套的常量结构(lists 或 maps)组成，则会创建一个常量 map 来表示表达式(而不是在每个 evaluation 上构建一个新的 map)。引用 map 键是可选的。上面的示例不使用带引号的键。</p>
<h4 id="4-3-5-Array-Construction"><a href="#4-3-5-Array-Construction" class="headerlink" title="4.3.5. Array Construction"></a>4.3.5. Array Construction</h4><p>您可以使用熟悉的 Java 语法 build 数组，可选地提供初始化程序以在构造 time 填充 array。以下 example 显示了如何执行此操作：</p>
<pre><code>int[] numbers1 = (int[]) parser.parseExpression(&quot;new int[4]&quot;).getValue(context);

// Array with initializer
int[] numbers2 = (int[]) parser.parseExpression(&quot;new int[]&#123;1,2,3&#125;&quot;).getValue(context);

// Multi dimensional array
int[][] numbers3 = (int[][]) parser.parseExpression(&quot;new int[4][5]&quot;).getValue(context);
</code></pre>
<p>在构造 multi-dimensional array 时，当前无法提供初始化程序。</p>
<h4 id="4-3-6-方法"><a href="#4-3-6-方法" class="headerlink" title="4.3.6. 方法"></a>4.3.6. 方法</h4><p>您可以使用典型的 Java 编程语法调用方法。您还可以在 literals 上调用方法。还支持变量 arguments。以下示例显示了如何调用方法：</p>
<pre><code>// string literal, evaluates to &quot;bc&quot;
String bc = parser.parseExpression(&quot;&#39;abc&#39;.substring(1, 3)&quot;).getValue(String.class);

// evaluates to true
boolean isMember = parser.parseExpression(&quot;isMember(&#39;Mihajlo Pupin&#39;)&quot;).getValue(
        societyContext, Boolean.class);
</code></pre>
<h4 id="4-3-7-Operators"><a href="#4-3-7-Operators" class="headerlink" title="4.3.7. Operators"></a>4.3.7. Operators</h4><p>Spring 表达式语言支持以下类型的 operators：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators-relational">关系运算符</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators-logical">逻辑运算符</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators-mathematical">数学运算符</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-assignment">作业操作员</a></li>
</ul>
<h5 id="Relational-Operators"><a href="#Relational-Operators" class="headerlink" title="Relational Operators"></a>Relational Operators</h5><p>使用标准 operator 表示法支持关系 operators(等于，不等于，小于，小于或等于，大于，大于或等于)。以下列表显示了一些 operators 的示例：</p>
<pre><code>// evaluates to true
boolean trueValue = parser.parseExpression(&quot;2 == 2&quot;).getValue(Boolean.class);

// evaluates to false
boolean falseValue = parser.parseExpression(&quot;2 &lt; -5.0&quot;).getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression(&quot;&#39;black&#39; &lt; &#39;block&#39;&quot;).getValue(Boolean.class);
</code></pre>
<blockquote>
<p>和 less-than 与<code>null</code>的比较遵循一个简单的规则：<code>null</code>被视为空(不是零)。因此，任何其他 value 总是大于<code>null</code>(<code>X &gt; null</code>总是<code>true</code>)，并且没有其他 value 小于零(<code>X &lt; null</code>总是<code>false</code>)。</p>
</blockquote>
<p>如果您更喜欢数字比较，请避免 number-based <code>null</code>比较，以支持与零进行比较(对于 example，<code>X &gt; 0</code>或<code>X &lt; 0</code>)。</p>
<p>除了标准的关系 operators 之外，SpEL 还支持<code>instanceof</code>和常规 expression-based <code>matches</code> operator。以下列表显示了两者的示例：</p>
<pre><code>// evaluates to false
boolean falseValue = parser.parseExpression(
        &quot;&#39;xyz&#39; instanceof T(Integer)&quot;).getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression(
        &quot;&#39;5.00&#39; matches &#39;^-?\\d+(\\.\\d&#123;2&#125;)?$&#39;&quot;).getValue(Boolean.class);

//evaluates to false
boolean falseValue = parser.parseExpression(
        &quot;&#39;5.0067&#39; matches &#39;^-?\\d+(\\.\\d&#123;2&#125;)?$&#39;&quot;).getValue(Boolean.class);
</code></pre>
<blockquote>
<p>小心原始类型，因为它们立即被装箱到 wrapper 类型，所以<code>1 instanceof T(int)</code>计算为<code>false</code>而<code>1 instanceof T(Integer)</code>计算为<code>true</code>，如预期的那样。</p>
</blockquote>
<p>每个符号 operator 也可以指定为纯字母等价物。这避免了所使用的符号对于嵌入表达式的文档类型具有特殊含义的问题(例如在 XML 文档中)。文本等价物是：</p>
<ul>
<li><code>lt</code> ( <code>&lt;</code> )</li>
<li><code>gt</code> ( <code>&gt;</code> )</li>
<li><code>le</code> ( <code>&lt;=</code> )</li>
<li><code>ge</code> ( <code>&gt;=</code> )</li>
<li><code>eq</code> ( <code>==</code> )</li>
<li><code>ne</code> ( <code>!=</code> )</li>
<li><code>div</code> ( <code>/</code> )</li>
<li><code>mod</code> ( <code>%</code> )</li>
<li><code>not</code> ( <code>!</code> ).</li>
</ul>
<p>所有文本 operators 都是 case-insensitive。</p>
<h5 id="逻辑操作员"><a href="#逻辑操作员" class="headerlink" title="逻辑操作员"></a>逻辑操作员</h5><p>SpEL 支持以下逻辑 operators：</p>
<ul>
<li><code>and</code></li>
<li><code>or</code></li>
<li><code>not</code></li>
</ul>
<p>以下 example 显示了如何使用逻辑 operators</p>
<pre><code>// -- AND --

// evaluates to false
boolean falseValue = parser.parseExpression(&quot;true and false&quot;).getValue(Boolean.class);

// evaluates to true
String expression = &quot;isMember(&#39;Nikola Tesla&#39;) and isMember(&#39;Mihajlo Pupin&#39;)&quot;;
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- OR --

// evaluates to true
boolean trueValue = parser.parseExpression(&quot;true or false&quot;).getValue(Boolean.class);

// evaluates to true
String expression = &quot;isMember(&#39;Nikola Tesla&#39;) or isMember(&#39;Albert Einstein&#39;)&quot;;
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- NOT --

// evaluates to false
boolean falseValue = parser.parseExpression(&quot;!true&quot;).getValue(Boolean.class);

// -- AND and NOT --
String expression = &quot;isMember(&#39;Nikola Tesla&#39;) and !isMember(&#39;Mihajlo Pupin&#39;)&quot;;
boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);
</code></pre>
<h5 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h5><p>您可以在 numbers 和 strings 上使用 addition operator。您只能在 numbers 上使用减法，乘法和除法运算符。您还可以使用模数(％)和指数幂(^)运算符。标准 operator 优先级被强制执行。以下 example 显示了正在使用的数学 operators：</p>
<pre><code>// Addition
int two = parser.parseExpression(&quot;1 + 1&quot;).getValue(Integer.class);  // 2

String testString = parser.parseExpression(
        &quot;&#39;test&#39; + &#39; &#39; + &#39;string&#39;&quot;).getValue(String.class);  // &#39;test string&#39;

// Subtraction
int four = parser.parseExpression(&quot;1 - -3&quot;).getValue(Integer.class);  // 4

double d = parser.parseExpression(&quot;1000.00 - 1e4&quot;).getValue(Double.class);  // -9000

// Multiplication
int six = parser.parseExpression(&quot;-2 * -3&quot;).getValue(Integer.class);  // 6

double twentyFour = parser.parseExpression(&quot;2.0 * 3e0 * 4&quot;).getValue(Double.class);  // 24.0

// Division
int minusTwo = parser.parseExpression(&quot;6 / -3&quot;).getValue(Integer.class);  // -2

double one = parser.parseExpression(&quot;8.0 / 4e0 / 2&quot;).getValue(Double.class);  // 1.0

// Modulus
int three = parser.parseExpression(&quot;7 % 4&quot;).getValue(Integer.class);  // 3

int one = parser.parseExpression(&quot;8 / 5 % 2&quot;).getValue(Integer.class);  // 1

// Operator precedence
int minusTwentyOne = parser.parseExpression(&quot;1+2-3*8&quot;).getValue(Integer.class);  // -21
</code></pre>
<h5 id="作业操作员"><a href="#作业操作员" class="headerlink" title="作业操作员"></a>作业操作员</h5><p>要设置 property，请使用赋值 operator(<code>=</code>)。这通常在对<code>setValue</code>的调用中完成，但也可以在对<code>getValue</code>的调用内完成。以下清单显示了使用赋值 operator 的两种方法：</p>
<pre><code>Inventor inventor = new Inventor();
EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();

parser.parseExpression(&quot;Name&quot;).setValue(context, inventor, &quot;Aleksandar Seovic&quot;);

// alternatively
String aleks = parser.parseExpression(
        &quot;Name = &#39;Aleksandar Seovic&#39;&quot;).getValue(context, inventor, String.class);
</code></pre>
<h4 id="4-3-8-类型"><a href="#4-3-8-类型" class="headerlink" title="4.3.8. 类型"></a>4.3.8. 类型</h4><p>您可以使用特殊<code>T</code> operator 指定<code>java.lang.Class</code>(类型)的实例。使用此 operator 也可以调用静态方法。 <code>StandardEvaluationContext</code>使用<code>TypeLocator</code>查找类型，<code>StandardTypeLocator</code>(可以替换)是在了解<code>java.lang</code>包的情况下构建的。这意味着对<code>java.lang</code>中的类型的<code>T()</code> references 不需要完全限定，但所有其他类型的 references 必须是。以下 example 显示了如何使用<code>T</code> operator：</p>
<pre><code>Class dateClass = parser.parseExpression(&quot;T(java.util.Date)&quot;).getValue(Class.class);

Class stringClass = parser.parseExpression(&quot;T(String)&quot;).getValue(Class.class);

boolean trueValue = parser.parseExpression(
        &quot;T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR&quot;)
        .getValue(Boolean.class);
</code></pre>
<h4 id="4-3-9-构造函数"><a href="#4-3-9-构造函数" class="headerlink" title="4.3.9. 构造函数"></a>4.3.9. 构造函数</h4><p>您可以使用<code>new</code> operator 调用构造函数。除了基本类型(<code>int</code>，<code>float</code>等)和 String 之外，您应该使用完全限定的 class name。以下 example 显示了如何使用<code>new</code> operator 来调用构造函数：</p>
<pre><code>Inventor einstein = p.parseExpression(
        &quot;new org.spring.samples.spel.inventor.Inventor(&#39;Albert Einstein&#39;, &#39;German&#39;)&quot;)
        .getValue(Inventor.class);

//create new inventor instance within add method of List
p.parseExpression(
        &quot;Members.add(new org.spring.samples.spel.inventor.Inventor(
            &#39;Albert Einstein&#39;, &#39;German&#39;))&quot;).getValue(societyContext);
</code></pre>
<h4 id="4-3-10-变量"><a href="#4-3-10-变量" class="headerlink" title="4.3.10. 变量"></a>4.3.10. 变量</h4><p>您可以使用<code>#variableName</code>语法在表达式中引用变量。通过在<code>EvaluationContext</code> implementations 上使用<code>setVariable</code>方法设置变量。以下 example 显示了如何使用变量：</p>
<pre><code>Inventor tesla = new Inventor(&quot;Nikola Tesla&quot;, &quot;Serbian&quot;);

EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
context.setVariable(&quot;newName&quot;, &quot;Mike Tesla&quot;);

parser.parseExpression(&quot;Name = #newName&quot;).getValue(context, tesla);
System.out.println(tesla.getName())  // &quot;Mike Tesla&quot;
</code></pre>
<h5 id="this-和-root-变量"><a href="#this-和-root-变量" class="headerlink" title="#this 和#root 变量"></a>#this 和#root 变量</h5><p>始终定义<code>#this</code>变量并引用当前 evaluation object(解析非限定 references 的对象)。始终定义<code>#root</code>变量并引用根 context object。虽然<code>#this</code>可能会随着表达式的组件的计算而变化，但<code>#root</code>总是指根。以下示例显示如何使用<code>#this</code>和<code>#root</code>变量：</p>
<pre><code>// create an array of integers
List&lt;Integer&gt; primes = new ArrayList&lt;Integer&gt;();
primes.addAll(Arrays.asList(2,3,5,7,11,13,17));

// create parser and set variable &#39;primes&#39; as the array of integers
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataAccess();
context.setVariable(&quot;primes&quot;, primes);

// all prime numbers &gt; 10 from the list (using selection ?&#123;...&#125;)
// evaluates to [11, 13, 17]
List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression(
        &quot;#primes.?[#this&gt;10]&quot;).getValue(context);
</code></pre>
<h4 id="4-3-11-功能"><a href="#4-3-11-功能" class="headerlink" title="4.3.11. 功能"></a>4.3.11. 功能</h4><p>您可以通过注册可在表达式 string 中调用的 user-defined 函数来扩展 SpEL。 function 通过<code>EvaluationContext</code>注册。以下 example 显示了如何注册 user-defined function：</p>
<pre><code>Method method = ...;

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable(&quot;myFunction&quot;, method);
</code></pre>
<p>对于 example，请考虑以下实用方法来反转 string：</p>
<pre><code>public abstract class StringUtils &#123;

    public static String reverseString(String input) &#123;
        StringBuilder backwards = new StringBuilder(input.length());
        for (int i = 0; i &lt; input.length(); i++)
            backwards.append(input.charAt(input.length() - 1 - i));
        &#125;
        return backwards.toString();
    &#125;
&#125;
</code></pre>
<p>然后，您可以注册并使用上述方法，如下面的示例所示：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable(&quot;reverseString&quot;,
        StringUtils.class.getDeclaredMethod(&quot;reverseString&quot;, String.class));

String helloWorldReversed = parser.parseExpression(
        &quot;#reverseString(&#39;hello&#39;)&quot;).getValue(context, String.class);
</code></pre>
<h4 id="4-3-12-Bean-References"><a href="#4-3-12-Bean-References" class="headerlink" title="4.3.12. Bean References"></a>4.3.12. Bean References</h4><p>如果 evaluation context 配置了 bean 解析程序，则可以使用<code>@</code>符号从表达式中查找 beans。以下 example 显示了如何执行此操作：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,&quot;something&quot;) on MyBeanResolver during evaluation
Object bean = parser.parseExpression(&quot;@something&quot;).getValue(context);
</code></pre>
<p>要访问工厂 bean 本身，您应该在 bean name 前面加上<code>&amp;</code>符号。以下 example 显示了如何执行此操作：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,&quot;&amp;foo&quot;) on MyBeanResolver during evaluation
Object bean = parser.parseExpression(&quot;&amp;foo&quot;).getValue(context);
</code></pre>
<h4 id="4-3-13-三元操作员-If-Then-Else"><a href="#4-3-13-三元操作员-If-Then-Else" class="headerlink" title="4.3.13. 三元操作员(If-Then-Else)"></a>4.3.13. 三元操作员(If-Then-Else)</h4><p>您可以使用三元 operator 在表达式中执行 if-then-else 条件逻辑。以下清单显示了一个最小的 example：</p>
<pre><code>String falseString = parser.parseExpression(
        &quot;false ? &#39;trueExp&#39; : &#39;falseExp&#39;&quot;).getValue(String.class);
</code></pre>
<p>在这种情况下，boolean <code>false</code>会返回 string value <code>&#39;falseExp&#39;</code>。一个更现实的例子如下：</p>
<pre><code>parser.parseExpression(&quot;Name&quot;).setValue(societyContext, &quot;IEEE&quot;);
societyContext.setVariable(&quot;queryName&quot;, &quot;Nikola Tesla&quot;);

expression = &quot;isMember(#queryName)? #queryName + &#39; is a member of the &#39; &quot; +
        &quot;+ Name + &#39; Society&#39; : #queryName + &#39; is not a member of the &#39; + Name + &#39; Society&#39;&quot;;

String queryResultString = parser.parseExpression(expression)
        .getValue(societyContext, String.class);
// queryResultString = &quot;Nikola Tesla is a member of the IEEE Society&quot;
</code></pre>
<p>有关三元 operator 的更短语法，请参阅 Elvis operator 的下一节。</p>
<h4 id="4-3-14-Elvis-Operator"><a href="#4-3-14-Elvis-Operator" class="headerlink" title="4.3.14. Elvis Operator"></a>4.3.14. Elvis Operator</h4><p>Elvis operator 是三元 operator 语法的缩写，用于<a target="_blank" rel="noopener" href="http://www.groovy-lang.org/operators.html#_elvis_operator">Groovy</a>语言。使用三元 operator 语法，您通常必须重复两次变量，如下面的 example 所示：</p>
<pre><code>String name = &quot;Elvis Presley&quot;;
String displayName = (name != null ? name : &quot;Unknown&quot;);
</code></pre>
<p>相反，您可以使用 Elvis operator(以 Elvis’发型的相似性命名)。以下 example 显示了如何使用 Elvis operator：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();

String name = parser.parseExpression(&quot;name?:&#39;Unknown&#39;&quot;).getValue(String.class);
System.out.println(name);  // &#39;Unknown&#39;
</code></pre>
<p>以下列表显示了一个更复杂的 example：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

Inventor tesla = new Inventor(&quot;Nikola Tesla&quot;, &quot;Serbian&quot;);
String name = parser.parseExpression(&quot;Name?:&#39;Elvis Presley&#39;&quot;).getValue(context, tesla, String.class);
System.out.println(name);  // Nikola Tesla

tesla.setName(null);
name = parser.parseExpression(&quot;Name?:&#39;Elvis Presley&#39;&quot;).getValue(context, tesla, String.class);
System.out.println(name);  // Elvis Presley
</code></pre>
<blockquote>
<p>您可以使用 Elvis operator 在表达式中应用默认值。 folloiwng example 显示了如何在<code>@Value</code>表达式中使用 Elvis operator：</p>
</blockquote>
<pre><code>@Value(&quot;#&#123;systemProperties[&#39;pop3.port&#39;] ?: 25&#125;&quot;)
</code></pre>
<p>这将 inject 一个系统 property <code>pop3.port</code>如果它被定义，或者如果没有，则为 25。</p>
<h4 id="4-3-15-安全导航操作员"><a href="#4-3-15-安全导航操作员" class="headerlink" title="4.3.15. 安全导航操作员"></a>4.3.15. 安全导航操作员</h4><p>安全导航 operator 用于避免<code>NullPointerException</code>并来自<a target="_blank" rel="noopener" href="http://www.groovy-lang.org/operators.html#_safe_navigation_operator">Groovy</a>语言。通常，当您对 object 具有 reference 时，您可能需要在访问 object 的方法或 properties 之前验证它是否为 null。为避免这种情况，安全导航 operator 返回 null 而不是抛出 exception。以下 example 显示了如何使用安全导航 operator：</p>
<pre><code>ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

Inventor tesla = new Inventor(&quot;Nikola Tesla&quot;, &quot;Serbian&quot;);
tesla.setPlaceOfBirth(new PlaceOfBirth(&quot;Smiljan&quot;));

String city = parser.parseExpression(&quot;PlaceOfBirth?.City&quot;).getValue(context, tesla, String.class);
System.out.println(city);  // Smiljan

tesla.setPlaceOfBirth(null);
city = parser.parseExpression(&quot;PlaceOfBirth?.City&quot;).getValue(context, tesla, String.class);
System.out.println(city);  // null - does not throw NullPointerException!!!
</code></pre>
<h4 id="4-3-16-收藏选择"><a href="#4-3-16-收藏选择" class="headerlink" title="4.3.16. 收藏选择"></a>4.3.16. 收藏选择</h4><p>Selection 是一种功能强大的表达式语言 feature，它允许您通过从其条目中进行选择将源集合转换为另一个集合。</p>
<p>Selection 使用<code>.?[selectionExpression]</code>的语法。它过滤集合并返回包含原始元素子集的新集合。例如，选择让我们可以轻松获得塞尔维亚发明家的列表，如下例所示：</p>
<pre><code>List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser.parseExpression(
        &quot;Members.?[Nationality == &#39;Serbian&#39;]&quot;).getValue(societyContext);
</code></pre>
<p>可以在 lists 和 maps 上进行选择。对于列表，将针对每个单独的列表元素评估选择标准。对于 map，将针对每个 map 条目(Java 类型<code>Map.Entry</code>的 objects)评估选择条件。每个 map 条目的 key 和 value 都可以作为 properties 访问，以便在选择中使用。</p>
<p>下面的表达式返回一个新的 map，它由原始 map 的那些元素组成，其中条目 value 小于 27：</p>
<pre><code>Map newMap = parser.parseExpression(&quot;map.?[value&lt;27]&quot;).getValue();
</code></pre>
<p>除了返回所有选定元素外，您还可以只检索第一个或最后一个 value。要获得与选择匹配的第一个条目，语法为<code>.^[selectionExpression]</code>。要获取最后一个匹配选择，语法为<code>.$[selectionExpression]</code>。</p>
<h4 id="4-3-17-收集投影"><a href="#4-3-17-收集投影" class="headerlink" title="4.3.17. 收集投影"></a>4.3.17. 收集投影</h4><p>Projection 允许集合驱动 sub-expression 的 evaluation，结果是一个新的集合。投影的语法是<code>.![projectionExpression]</code>。例如，假设我们有一个发明者列表，但想要他们出生的城市列表。实际上，我们想要为发明人列表中的每个条目评估“placeOfBirth.city”。以下 example 使用投影来执行此操作：</p>
<pre><code>// returns [&#39;Smiljan&#39;, &#39;Idvor&#39; ]
List placesOfBirth = (List)parser.parseExpression(&quot;Members.![placeOfBirth.city]&quot;);
</code></pre>
<p>您还可以使用 map 来驱动投影，在这种情况下，将根据 map 中的每个条目(表示为 Java <code>Map.Entry</code>)来计算投影表达式。跨 map 的投影结果是一个列表，其中包含针对每个 map 条目的投影表达式的 evaluation。</p>
<h4 id="4-3-18-表达模板"><a href="#4-3-18-表达模板" class="headerlink" title="4.3.18. 表达模板"></a>4.3.18. 表达模板</h4><p>表达式模板允许将文本文本与一个或多个 evaluation 块混合。每个 evaluation 块都使用您可以定义的前缀和后缀字符分隔。 common 的选择是使用<code>#&#123; &#125;</code>作为分隔符，如下面的 example 所示：</p>
<pre><code>String randomPhrase = parser.parseExpression(
        &quot;random number is #&#123;T(java.lang.Math).random()&#125;&quot;,
        new TemplateParserContext()).getValue(String.class);

// evaluates to &quot;random number is 0.7038186818312008&quot;
</code></pre>
<p>string 是通过将文本文本<code>&#39;random number is &#39;</code>与评估<code>#&#123; &#125;</code>分隔符内表达式的结果(在这种情况下，调用<code>random()</code>方法的结果)连接来计算的。 <code>parseExpression()</code>方法的第二个参数是<code>ParserContext</code>类型。 <code>ParserContext</code>接口用于影响在 order 中解析表达式的方式，以支持表达式模板功能。 <code>TemplateParserContext</code>的定义如下：</p>
<pre><code>public class TemplateParserContext implements ParserContext &#123;

    public String getExpressionPrefix() &#123;
        return &quot;#&#123;&quot;;
    &#125;

    public String getExpressionSuffix() &#123;
        return &quot;&#125;&quot;;
    &#125;

    public boolean isTemplate() &#123;
        return true;
    &#125;
&#125;
</code></pre>
<h3 id="4-4-Classes-在示例中使用"><a href="#4-4-Classes-在示例中使用" class="headerlink" title="4.4. Classes 在示例中使用"></a>4.4. Classes 在示例中使用</h3><p>本节列出了本章中示例中使用的 classes。</p>
<p>示例 1. Inventor.java</p>
<pre><code>package org.spring.samples.spel.inventor;

import java.util.Date;
import java.util.GregorianCalendar;

public class Inventor &#123;

    private String name;
    private String nationality;
    private String[] inventions;
    private Date birthdate;
    private PlaceOfBirth placeOfBirth;

    public Inventor(String name, String nationality) &#123;
        GregorianCalendar c= new GregorianCalendar();
        this.name = name;
        this.nationality = nationality;
        this.birthdate = c.getTime();
    &#125;

    public Inventor(String name, Date birthdate, String nationality) &#123;
        this.name = name;
        this.nationality = nationality;
        this.birthdate = birthdate;
    &#125;

    public Inventor() &#123;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getNationality() &#123;
        return nationality;
    &#125;

    public void setNationality(String nationality) &#123;
        this.nationality = nationality;
    &#125;

    public Date getBirthdate() &#123;
        return birthdate;
    &#125;

    public void setBirthdate(Date birthdate) &#123;
        this.birthdate = birthdate;
    &#125;

    public PlaceOfBirth getPlaceOfBirth() &#123;
        return placeOfBirth;
    &#125;

    public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) &#123;
        this.placeOfBirth = placeOfBirth;
    &#125;

    public void setInventions(String[] inventions) &#123;
        this.inventions = inventions;
    &#125;

    public String[] getInventions() &#123;
        return inventions;
    &#125;
&#125;
</code></pre>
<p>示例 2. PlaceOfBirth.java</p>
<pre><code>package org.spring.samples.spel.inventor;

public class PlaceOfBirth &#123;

    private String city;
    private String country;

    public PlaceOfBirth(String city) &#123;
        this.city=city;
    &#125;

    public PlaceOfBirth(String city, String country) &#123;
        this(city);
        this.country = country;
    &#125;

    public String getCity() &#123;
        return city;
    &#125;

    public void setCity(String s) &#123;
        this.city = s;
    &#125;

    public String getCountry() &#123;
        return country;
    &#125;

    public void setCountry(String country) &#123;
        this.country = country;
    &#125;

&#125;
</code></pre>
<p>示例 3. Society.java</p>
<pre><code>package org.spring.samples.spel.inventor;

import java.util.*;

public class Society &#123;

    private String name;

    public static String Advisors = &quot;advisors&quot;;
    public static String President = &quot;president&quot;;

    private List&lt;Inventor&gt; members = new ArrayList&lt;Inventor&gt;();
    private Map officers = new HashMap();

    public List getMembers() &#123;
        return members;
    &#125;

    public Map getOfficers() &#123;
        return officers;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public boolean isMember(String name) &#123;
        for (Inventor inventor : members) &#123;
            if (inventor.getName().equals(name)) &#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;

&#125;
</code></pre>
<h2 id="5-使用-Spring-进行面向对象编程"><a href="#5-使用-Spring-进行面向对象编程" class="headerlink" title="5.使用 Spring 进行面向对象编程"></a>5.使用 Spring 进行面向对象编程</h2><p>Aspect-oriented 编程(AOP)通过提供另一种思考程序结构的方式来补充 Object-oriented 编程(OOP)。 OOP 中的 key 模块化单元是 class，而在 AOP 中，模块化单元是 aspect。方面可以实现跨越多种类型和对象的关注点(例如 transaction management)的模块化。 (这种担忧在 AOP 中通常被称为“横切”问题 literature.)</p>
<p>Spring 的 key 组件之一是 AOP framework。虽然 Spring IoC 容器不依赖于 AOP(意味着如果您不想使用 AOP，则不需要使用 AOP)，AOP 补充了 Spring IoC 以提供非常强大的中间件解决方案。</p>
<p>Spring 2.0 AOP</p>
<p>Spring 2.0 引入了一种更简单，更强大的方法，通过使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-schema">schema-based 接近</a>或<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj">@AspectJ 注释风格</a>来编写自定义方面。这两种样式都提供完全类型的建议和使用 AspectJ 切入点语言，同时仍然使用 Spring AOP 进行编织。</p>
<p>本章讨论 Spring 2.0 schema-和@AspectJ-based AOP 支持。 A支持，如 Spring 1.2 applications 中常见的那样，在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api">以下章节</a>中讨论。</p>
<p>AOP 在 Spring Framework 中用于：</p>
<ul>
<li>提供声明性企业服务，尤其是作为 EJB 声明性服务的替代品。最重要的服务是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#transaction-declarative">声明性 transaction management</a>。</li>
<li>让用户实现自定义方面，补充他们使用 AOP 的 OOP。</li>
</ul>
<blockquote>
<p>如果您只对通用声明性服务或其他 pre-packaged 声明性中间件服务(如池)感兴趣，则无需直接使用 Spring AOP，并且可以跳过本章的大部分内容。</p>
</blockquote>
<h3 id="5-1-AOP-概念"><a href="#5-1-AOP-概念" class="headerlink" title="5.1. AOP 概念"></a>5.1. AOP 概念</h3><p>让我们首先定义一些中心 AOP 概念和术语。这些条款不是 Spring-specific。不幸的是，AOP 术语不是特别直观。但是，如果 Spring 使用自己的术语，那将更加令人困惑。</p>
<ul>
<li>Aspect：跨越多个 classes 的关注点的模块化。 Transaction management 是企业 Java applications 中横切关注点的一个很好的例子。在 Spring AOP 中，方面是使用常规 classes(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-schema">schema-based 接近</a>)或使用<code>@Aspect</code> annotation(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj">@AspectJ 风格</a>)注释的常规 classes 实现的。</li>
<li>连接点：程序执行期间的一个点，例如方法的执行或 exception 的处理。在 Spring AOP 中，连接点始终表示方法执行。</li>
<li>建议：aspect 在特定连接点采取的操作。不同类型的建议包括“周围”，“之前”和“之后”建议。 (建议类型被讨论 later.)许多 AOP 框架，包括 Spring，model 作为拦截器的建议，并在连接点周围维护一系列拦截器。</li>
<li>切入点：匹配连接点的谓词。建议与切入点表达式相关联，并在切入点匹配的任何连接点处运行(对于 example，执行具有特定 name 的方法)。由切入点表达式匹配的连接点的概念是 AOP 的核心，而 Spring 默认使用 AspectJ 切入点表达式语言。</li>
<li>简介：代表类型声明其他方法或字段。 Spring AOP 允许您向任何建议的 object 引入新接口(以及相应的 implementation)。对于 example，您可以使用简介使 bean 实现<code>IsModified</code>接口，以简化缓存。 (引言在 AspectJ 中被称为 inter-type 声明 community.)</li>
<li>目标 object：由一个或多个方面建议的 object。也称为“建议对象”。由于 Spring AOP 是使用运行时代理实现的，因此 object 始终是代理 object。</li>
<li>AOP 代理：由 order 中的 AOP framework 创建的 object，用于实现 aspect contracts(建议方法执行等)。在 Spring Framework 中，AOP 代理是 JDK 动态代理或 CGLIB 代理。</li>
<li>编织：将方面与其他 application 类型或 objects 链接以创建一个建议的 object。这可以在 compile time(使用 AspectJ 编译器，example)，load time 或运行时完成。与其他纯 Java AOP 框架一样，Spring AOP 在运行时执行编织。</li>
</ul>
<p>Spring AOP 包括以下类型的建议：</p>
<ul>
<li>建议之前：在连接点之前运行但无法阻止执行流程进入连接点的建议(除非它抛出 exception)。</li>
<li>返回建议后：在连接点正常完成后建议为 run(对于 example，如果方法返回而不抛出 exception)。</li>
<li>抛出建议后：如果方法通过抛出 exception 退出，则执行建议。</li>
<li>在(最终)建议之后：无论连接点退出的方式(正常或异常 return)，都要执行建议。</li>
<li>围绕建议：围绕连接点的建议，例如方法调用。这是最有力的建议。 around 通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的 return value 或抛出 exception 来快速建议的方法执行。</li>
</ul>
<p>围绕建议是最普遍的建议。由于 Spring AOP(如 AspectJ)提供了全方位的建议类型，因此我们建议您使用可以实现所需行为的最不强大的建议类型。例如，如果您只需要使用方法的 return value 更新缓存，那么最好实现返回后的建议，而不是周围的建议，尽管周围的建议可以完成同样的事情。使用最具体的建议类型可以提供更简单的编程模型，减少错误的可能性。对于 example，您不需要在用于 around 建议的<code>JoinPoint</code>上调用<code>proceed()</code>方法，因此，您无法调用它。</p>
<p>在 Spring 2.0 中，所有通知参数都是静态类型的，因此您可以使用相应类型的通知参数(来自 example 的方法执行的 return value 的类型)而不是<code>Object</code>数组。</p>
<p>由切入点匹配的连接点的概念是 AOP 的 key，它将其与仅提供拦截的旧技术区分开来。切入点使得建议可以独立于 object-oriented 层次结构进行定向。例如，您可以将一个提供声明性 transaction management 的建议应用于 span 多个 objects(例如服务层中的所有业务操作)的一组方法。</p>
<h3 id="5-2-Spring-AOP-能力和目标"><a href="#5-2-Spring-AOP-能力和目标" class="headerlink" title="5.2. Spring AOP 能力和目标"></a>5.2. Spring AOP 能力和目标</h3><p>Spring AOP 是用纯 Java 实现的。不需要特殊的编译 process。 Spring AOP 不需要控制 class 加载器层次结构，因此适合在 servlet 容器或 application 服务器中使用。</p>
<p>Spring AOP 目前仅支持方法执行连接点(建议在 Spring beans 上执行方法)。虽然可以在不破坏核心 Spring AOP API 的情况下添加对字段拦截的支持，但未实现字段拦截。如果您需要建议字段访问和更新连接点，请考虑使用 AspectJ 等语言。</p>
<p>Spring AOP 的 AOP 方法与大多数其他 AOP 框架的方法不同。目的不是提供最完整的 AOP implementation(尽管 Spring AOP 非常强大)。相反，目的是在 AOP implementation 和 Spring IoC 之间提供紧密的整合，以帮助解决企业应用中的 common 问题。</p>
<p>因此，例如，Spring Framework 的 AOP 功能通常与 Spring IoC 容器一起使用。通过使用普通 bean 定义语法来配置方面(尽管这允许强大的“auto-proxying”功能)。这是与其他 AOP implementations 的重要区别。使用 Spring AOP 无法轻松或有效地完成某些操作，例如建议非常 fine-grained objects(通常是域 objects)。在这种情况下，AspectJ 是最佳选择。但是，我们的经验是 Spring AOP 为适合 AOP 的企业 Java 应用程序中的大多数问题提供了出色的解决方案。</p>
<p>Spring AOP 从未努力与 AspectJ 竞争，以提供全面的 AOP 解决方案。我们认为，像 Spring AOP 这样的 proxy-based 框架和像 AspectJ 这样的 full-blown 框架都是有价值的，它们是互补的，而不是竞争。 Spring 将 Spring AOP 和 IoC 与 AspectJ 无缝集成，以在一致的 Spring-based application architecture 中实现 AOP 的所有使用。此 integration 不会影响 Spring AOP API 或 AOP Alliance API。 Spring AOP 仍为 backward-compatible。有关 Spring AOP API 的讨论，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api">以下章节</a>。</p>
<blockquote>
<p>Spring Framework 的核心原则之一是 non-invasiveness。这是 idea，您不应该被迫将 framework-specific classes 和接口引入您的业务或域 model。但是，在某些地方，Spring Framework 确实为您提供了将 Spring Framework-specific 依赖项引入代码库的选项。为您提供此类选项的基本原理是，在某些情况下，以这种方式读取或编码某些特定功能可能更容易。但是，Spring Framework(几乎)始终为您提供选择：您可以自由决定哪种选项最适合您的特定用例或场景。</p>
</blockquote>
<p>与本章相关的一个选择是选择哪种 AOP framework(以及哪种 AOP 样式)。您可以选择 AspectJ，Spring AOP 或两者。您还可以选择 @AspectJ annotation-style 方法或 Spring XML configuration-style 方法。本章选择首先介绍@AspectJ-style 方法的事实不应被视为 Spring 团队倾向于 @AspectJ annotation-style 方法而不是 Spring XML configuration-style。</p>
<p>有关每种样式的“为什么和为何如此”的更完整的讨论，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-choosing">选择要使用的 AOP 声明样式</a>。</p>
<h3 id="5-3-AOP-代理"><a href="#5-3-AOP-代理" class="headerlink" title="5.3. AOP 代理"></a>5.3. AOP 代理</h3><p>Spring AOP 默认使用 AOP 代理的标准 JDK 动态代理。这使得任何接口(或接口集)都可以被代理。</p>
<p>Spring AOP 也可以使用 CGLIB 代理。这对代理 classes 而不是接口是必要的。默认情况下，如果 business object 没有实现接口，则使用 CGLIB。由于编程接口而不是 classes 是一种好的做法，因此业务 classes 通常会实现一个或多个业务接口。在那些(希望很少见的)情况下，你需要建议一个未在接口上声明的方法，或者你需要将一个代理的 object 作为一个具体类型传递给一个方法，这可能是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-proxying">强制使用 CGLIB</a>。</p>
<p>掌握 Spring AOP 是 proxy-based 的事实很重要。请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-understanding-aop-proxies">了解 AOP 代理</a>以详细了解此 implementation 详细信息的实际含义。</p>
<h3 id="5-4-AspectJ-支持"><a href="#5-4-AspectJ-支持" class="headerlink" title="5.4. @AspectJ 支持"></a>5.4. @AspectJ 支持</h3><p>@AspectJ 指的是将方面声明为使用 annotations 注释的常规 Java classes 的样式。作为 AspectJ 5 版本的一部分，<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj">AspectJ 项目</a>引入了 @AspectJ 样式。 Spring 使用 AspectJ 提供的 library 解释与 AspectJ 5 相同的注释，用于切入点解析和匹配。但是，AOP 运行时仍然是纯粹的 Spring AOP，并且不依赖于 AspectJ 编译器或编织器。</p>
<blockquote>
<p>使用 AspectJ 编译器和 weaver 可以使用完整的 AspectJ 语言，并在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-using-aspectj">将 AspectJ 与 Spring Applications 一起使用</a>中讨论。</p>
</blockquote>
<h4 id="5-4-1-启用-AspectJ-支持"><a href="#5-4-1-启用-AspectJ-支持" class="headerlink" title="5.4.1. 启用 @AspectJ 支持"></a>5.4.1. 启用 @AspectJ 支持</h4><p>要在 Spring configuration 中使用 @AspectJ 方面，您需要启用 Spring 支持，以根据 @AspectJ 方面配置 Spring AOP，并根据这些方面是否建议 auto-proxying beans。通过 auto-proxying，我们的意思是，如果 Spring 确定 bean 被一个或多个方面建议，它会自动为该 bean 生成一个代理来拦截方法调用，并确保根据需要执行建议。</p>
<p>可以使用 XML-或 Java-style configuration 启用 @AspectJ 支持。在任何一种情况下，您还需要确保 AspectJ 的<code>aspectjweaver.jar</code> library 位于 application 的 classpath(version 1.8 或更高版本)。这个 library 可以在 AspectJ 发行版的<code>lib</code>目录中找到，也可以从 Maven Central repository 中找到。</p>
<h5 id="使用-Java-Configuration-启用-AspectJ-支持"><a href="#使用-Java-Configuration-启用-AspectJ-支持" class="headerlink" title="使用 Java Configuration 启用 @AspectJ 支持"></a>使用 Java Configuration 启用 @AspectJ 支持</h5><p>要使用 Java <code>@Configuration</code>启用 @AspectJ 支持，请添加<code>@EnableAspectJAutoProxy</code> annotation，如下面的 example 所示：</p>
<pre><code>@Configuration
@EnableAspectJAutoProxy
public class AppConfig &#123;

&#125;
</code></pre>
<h5 id="使用-XML-Configuration-启用-AspectJ-支持"><a href="#使用-XML-Configuration-启用-AspectJ-支持" class="headerlink" title="使用 XML Configuration 启用 @AspectJ 支持"></a>使用 XML Configuration 启用 @AspectJ 支持</h5><p>要使用 XML-based configuration 启用 @AspectJ 支持，请使用<code>aop:aspectj-autoproxy</code>元素，如下面的 example 所示：</p>
<pre><code>&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<p>这假定您使用_s中描述的 schema 支持。有关如何 import <code>aop</code>命名空间中的标记，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas">AOP schema</a>。</p>
<h4 id="5-4-2-声明-Aspect"><a href="#5-4-2-声明-Aspect" class="headerlink" title="5.4.2. 声明 Aspect"></a>5.4.2. 声明 Aspect</h4><p>启用 @AspectJ 支持后，_appring context 中定义的任何带有 class @AspectJ aspect(具有<code>@Aspect</code> annotation)的 bean 将由 Spring 自动检测并用于配置 Spring AOP。接下来的两个示例显示了 not-very-useful aspect 所需的最小定义。</p>
<p>两个 example 中的第一个在 application context 中显示了一个常规的 bean 定义，该定义指向具有<code>@Aspect</code> annotation 的 bean class：</p>
<pre><code>&lt;bean id=&quot;myAspect&quot; class=&quot;org.xyz.NotVeryUsefulAspect&quot;&gt;
    &lt;!-- configure properties of the aspect here --&gt;
&lt;/bean&gt;
</code></pre>
<p>这两个示例中的第二个显示了<code>NotVeryUsefulAspect</code> class 定义，该定义使用<code>org.aspectj.lang.annotation.Aspect</code> annotation 注释;</p>
<pre><code>package org.xyz;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class NotVeryUsefulAspect &#123;

&#125;
</code></pre>
<p>方面(class 用<code>@Aspect</code>注释)可以有方法和字段，与任何其他 class 相同。它们还可以包含切入点，建议和简介(inter-type)声明。</p>
<blockquote>
<p>通过 component 扫描自动检测方面<br>您可以在 Spring XML configuration 中将 aspect classes 注册为常规 beans，或者通过 classpath 扫描自动检测它们 - 与任何其他 Spring-managed bean 相同。但是，请注意<code>@Aspect</code> annotation 不足以在 classpath 中自动检测。为此，您需要添加一个单独的<code>@Component</code> annotation(或者，根据 Spring 的 component 扫描器的规则，可以定义符合条件的自定义构造型 annotation)。</p>
</blockquote>
<blockquote>
<p>与其他方面的方面建议？<br>在 Spring AOP 中，方面本身不能成为其他方面建议的目标。 class 上的<code>@Aspect</code> annotation 将其标记为 aspect，因此将其从 auto-proxying 中排除。</p>
</blockquote>
<h4 id="5-4-3-声明切入点"><a href="#5-4-3-声明切入点" class="headerlink" title="5.4.3. 声明切入点"></a>5.4.3. 声明切入点</h4><p>切入点确定感兴趣的连接点，从而使我们能够控制建议何时执行。 Spring AOP 仅支持 Spring beans 的方法执行连接点，因此您可以将切入点视为匹配 Spring beans 上方法的执行。切入点声明有两个部分：一个包含 name 的签名和任何参数以及一个精确确定我们感兴趣的方法执行的切入点表达式。在 AOP 的 @AspectJ annotation-style 中，切入点签名由常规方法定义提供，并且通过使用<code>@Pointcut</code> annotation 指示切入点表达式(用作切入点签名的方法必须具有<code>void</code> return 类型)。</p>
<p>__ample 可以帮助区分切入点签名和切入点表达式。以下 example 定义名为<code>anyOldTransfer</code>的切入点，该切入点与名为<code>transfer</code>的任何方法的执行相匹配：</p>
<pre><code>@Pointcut(&quot;execution(* transfer(..))&quot;)// the pointcut expression
private void anyOldTransfer() &#123;&#125;// the pointcut signature
</code></pre>
<p>形成<code>@Pointcut</code> annotation 的 value 的切入点表达式是常规的 AspectJ 5 切入点表达式。有关 AspectJ 的切入点语言的完整讨论，请参阅<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ 编程指南</a>(和，对于 extensions，<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">AspectJ 5 开发人员的笔记本</a>)或 AspectJ 上的一本书(例如，Colyer 等人的 Eclipse AspectJ，或者 Ramnivas Laddad 的 AspectJ in Action) 。</p>
<h5 id="支持的切入点指示符"><a href="#支持的切入点指示符" class="headerlink" title="支持的切入点指示符"></a>支持的切入点指示符</h5><p>Spring AOP 支持以下 AspectJ 切入点指示符(PCD)用于切入点表达式：</p>
<ul>
<li><code>execution</code>：用于匹配方法执行连接点。这是使用 Spring AOP 时使用的主要切入点指示符。</li>
<li><code>within</code>：限制匹配某些类型中的连接点(使用 Spring AOP 时执行在匹配类型中声明的方法)。</li>
<li><code>this</code>：限制与连接点的匹配(使用 Spring AOP 时执行方法)，其中 bean reference(Spring AOP 代理)是给定类型的实例。</li>
<li><code>target</code>：限制与连接点的匹配(使用 Spring AOP 时执行方法)，其中目标 object(application object 被代理)是给定类型的实例。</li>
<li><code>args</code>：限制匹配连接点(使用 Spring AOP 时执行方法)，其中 arguments 是给定类型的实例。</li>
<li><code>@target</code>：限制与连接点的匹配(使用 Spring AOP 时执行方法)，其中执行 object 的 class 具有给定类型的 annotation。</li>
<li><code>@args</code>：限制与连接点的匹配(使用 Spring AOP 时执行方法)，其中传递的实际 arguments 的运行时类型具有给定类型的注释。</li>
<li><code>@within</code>：限制匹配到具有给定 annotation 的类型中的连接点(使用 Spring AOP 时执行在具有给定 annotation 的类型中声明的方法)。</li>
<li><code>@annotation</code>：限制连接点的匹配，其中连接点的主题(在 Spring AOP 中执行的方法)具有给定的 annotation。</li>
</ul>
<p>其他切入点类型</p>
<p>完整的 AspectJ 切入点语言支持 Spring 中不支持的其他切入点指示符：<code>call</code>，<code>get</code>，<code>set</code>，<code>preinitialization</code>，<code>staticinitialization</code>，<code>initialization</code>，<code>handler</code>，<code>adviceexecution</code>，<code>withincode</code>，<code>cflow</code>，<code>cflowbelow</code>，<code>if</code>，<code>@this</code>和<code>@withincode</code>。在 Spring AOP 解释的切入点表达式中使用这些切入点指示符会导致抛出<code>IllegalArgumentException</code>。</p>
<p>Spring AOP 支持的切入点指示符集可以在将来的版本中进行扩展，以支持更多的 AspectJ 切入点指示符。</p>
<p>因为 Spring AOP 限制仅与方法执行连接点匹配，所以前面对切入点指示符的讨论给出了比在 AspectJ 编程指南中找到的更窄的定义。此外，AspectJ 本身具有 type-based 语义，并且在执行连接点，<code>this</code>和<code>target</code>都引用相同的 object：object 执行该方法。 Spring AOP 是一个 proxy-based 系统，它区分代理 object 本身(绑定到<code>this</code>)和代理后面的目标 object(绑定到<code>target</code>)。</p>
<blockquote>
<p>由于 Spring 的 AOP framework 的 proxy-based 性质，根据定义，目标 object 中的 calls 不会被截获。对于 JDK 代理，只能拦截代理上的公共接口方法 calls。使用 CGLIB，代理上的公共和受保护方法 calls 被截获(如果需要，甚至是 package-visible 方法)。但是，通过代理的 common 交互应始终通过公共签名进行设计。</p>
</blockquote>
<p>请注意，切入点定义通常与任何截获的方法匹配。如果切入点严格意味着 public-only，即使在通过代理进行潜在 non-public 交互的 CGLIB 代理方案中，也需要相应地进行定义。</p>
<p>如果您的拦截需要在目标 class 中包含方法 calls 甚至构造函数，请考虑使用 Spring-driven <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas-aop">原生 AspectJ 编织</a>而不是 Spring 的 proxy-based AOP framework。这构成了具有不同特征的不同 AOP 使用模式，因此在做出决定之前一定要熟悉编织。</p>
<p>Spring AOP 还支持另一个名为<code>bean</code>的 PCD。此 PCD 允许您将连接点的匹配限制为特定的名为 Spring bean 或一组名为 Spring beans(使用通配符时)。 <code>bean</code> PCD 具有以下形式：</p>
<pre><code>bean(idOrNameOfBean)
</code></pre>
<p><code>idOrNameOfBean</code>标记可以是任何 Spring bean 的 name。提供了使用<code>*</code>字符的有限通配符支持，因此，如果为 Spring beans 建立了一些命名约定，则可以编写<code>bean</code> PCD 表达式来选择它们。与其他切入点指示符的情况一样，<code>bean</code> PCD 也可以与<code>&amp;&amp;</code>(和)，<code>||</code>(或)和<code>!</code>(否定)运算符一起使用。</p>
<blockquote>
<p><code>bean</code> PCD 仅在 Spring AOP 中受支持，而不在原生 AspectJ 编织中受支持。它是 AspectJ 定义的标准 PCD 的 Spring-specific 扩展，因此不适用于<code>@Aspect</code> model 中声明的方面。</p>
</blockquote>
<p><code>bean</code> PCD 在 level 实例(Spring bean name 概念上的 building)上运行，而不是仅在 level 类型上运行(weaving-based AOP 受限)。 Instance-based 切入点指示符是 Spring 的 proxy-based AOP framework 的特殊功能，它与 Spring bean 工厂紧密结合，在 name 中识别特定 beans 是自然而直接的。</p>
<h5 id="组合切入点表达式"><a href="#组合切入点表达式" class="headerlink" title="组合切入点表达式"></a>组合切入点表达式</h5><p>您可以使用<code>&amp;&amp;,</code> <code>||</code>和<code>!</code>组合切入点表达式。您还可以通过 name 引用切入点表达式。以下 example 显示了三个切入点表达式：</p>
<pre><code>@Pointcut(&quot;execution(public * *(..))&quot;)
private void anyPublicOperation() &#123;&#125; (1)

@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)
private void inTrading() &#123;&#125; (2)

@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)
private void tradingOperation() &#123;&#125; (3)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>如果方法执行连接点表示任何公共方法的执行，则<code>anyPublicOperation</code>匹配。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>如果方法执行在交易模块中，<code>inTrading</code>匹配。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>如果方法执行表示交易模块中的任何公共方法，则<code>tradingOperation</code>匹配。</td>
</tr>
</tbody></table>
<p>如前所示，最好的做法是从较小的命名组件中构建更复杂的切入点表达式。当通过 name 引用切入点时，将应用常规 Java 可见性规则(您可以看到相同类型的私有切入点，层次结构中的受保护切入点，任何位置的公共切入点等)。可见性不会影响切入点匹配。</p>
<h5 id="共享-Common-切入点定义"><a href="#共享-Common-切入点定义" class="headerlink" title="共享 Common 切入点定义"></a>共享 Common 切入点定义</h5><p>在使用 enterprise applications 时，开发人员通常希望从几个方面引用 application 的模块和特定的操作集。我们建议定义一个“SystemArchitecture”aspect，为此目的捕获 common 切入点表达式。这样的 aspect 通常类似于以下 example：</p>
<pre><code>package com.xyz.someapp;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class SystemArchitecture &#123;

    /**
     * A join point is in the web layer if the method is defined
     * in a type in the com.xyz.someapp.web package or any sub-package
     * under that.
     */
    @Pointcut(&quot;within(com.xyz.someapp.web..*)&quot;)
    public void inWebLayer() &#123;&#125;

    /**
     * A join point is in the service layer if the method is defined
     * in a type in the com.xyz.someapp.service package or any sub-package
     * under that.
     */
    @Pointcut(&quot;within(com.xyz.someapp.service..*)&quot;)
    public void inServiceLayer() &#123;&#125;

    /**
     * A join point is in the data access layer if the method is defined
     * in a type in the com.xyz.someapp.dao package or any sub-package
     * under that.
     */
    @Pointcut(&quot;within(com.xyz.someapp.dao..*)&quot;)
    public void inDataAccessLayer() &#123;&#125;

    /**
     * A business service is the execution of any method defined on a service
     * interface. This definition assumes that interfaces are placed in the
     * &quot;service&quot; package, and that implementation types are in sub-packages.
     *
     * If you group service interfaces by functional area (for example,
     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
     * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;
     * could be used instead.
     *
     * Alternatively, you can write the expression using the &#39;bean&#39;
     * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have
     * named your Spring service beans in a consistent fashion.)
     */
    @Pointcut(&quot;execution(* com.xyz.someapp..service.*.*(..))&quot;)
    public void businessService() &#123;&#125;

    /**
     * A data access operation is the execution of any method defined on a
     * dao interface. This definition assumes that interfaces are placed in the
     * &quot;dao&quot; package, and that implementation types are in sub-packages.
     */
    @Pointcut(&quot;execution(* com.xyz.someapp.dao.*.*(..))&quot;)
    public void dataAccessOperation() &#123;&#125;

&#125;
</code></pre>
<p>您可以在需要切入点表达式的任何位置引用此类 aspect 中定义的切入点。对于 example，要使服务层 transactional，您可以编写以下内容：</p>
<pre><code>&lt;aop:config&gt;
    &lt;aop:advisor
        pointcut=&quot;com.xyz.someapp.SystemArchitecture.businessService()&quot;
        advice-ref=&quot;tx-advice&quot;/&gt;
&lt;/aop:config&gt;

&lt;tx:advice id=&quot;tx-advice&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<p><code>&lt;aop:config&gt;</code>和<code>&lt;aop:advisor&gt;</code>元素在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">Schema-based AOP 支持</a>中讨论。 transaction 元素在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#aop-schema">Transaction Management</a>中讨论。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>Spring AOP 用户可能最常使用<code>execution</code>切入点指示符。执行表达式的格式如下：</p>
<pre><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
            throws-pattern?)
</code></pre>
<p>除返回类型 pattern(前面的代码片段中的<code>ret-type-pattern</code>)， name pattern 和参数 pattern 之外的所有部分都是可选的。返回类型 pattern 确定方法的 return 类型必须在 order 中才能匹配连接点。 <code>*</code>最常用作返回类型 pattern。它匹配任何 return 类型。仅当方法返回给定类型时，fully-qualified 类型 name 才匹配。 name pattern 与方法 name 匹配。您可以使用<code>*</code>通配符作为 name pattern 的全部或部分。如果指定声明类型 pattern，请包含尾随<code>.</code>以将其连接到 name pattern component。参数 pattern 稍微复杂一些：<code>()</code>匹配不带参数的方法，而<code>(..)</code>匹配任何数量(零个或多个)参数。 <code>(*)</code> pattern 匹配一个接受任何类型的一个参数的方法。 <code>(*,String)</code>匹配一个带两个参数的方法。第一个可以是任何类型，而第二个必须是<code>String</code>。有关更多信息，请参阅 AspectJ 编程指南的<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">语言语义学</a>部分。</p>
<p>以下示例显示了一些 common 切入点表达式：</p>
<ul>
<li>执行任何公共方法：</li>
</ul>
<pre><code>execution(public * *(..))
</code></pre>
<ul>
<li>执行 name 以<code>set</code>开头的任何方法：</li>
</ul>
<pre><code>execution(* set*(..))
</code></pre>
<ul>
<li>执行<code>AccountService</code>接口定义的任何方法：</li>
</ul>
<pre><code>execution(* com.xyz.service.AccountService.*(..))
</code></pre>
<ul>
<li>执行<code>service</code>包中定义的任何方法：</li>
</ul>
<pre><code>execution(* com.xyz.service.*.*(..))
</code></pre>
<ul>
<li>执行服务包中定义的任何方法或其中一个 sub-packages：</li>
</ul>
<pre><code>execution(* com.xyz.service..*.*(..))
</code></pre>
<ul>
<li>服务包中的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<pre><code>within(com.xyz.service.*)
</code></pre>
<ul>
<li>服务包中的任何连接点(仅在 Spring AOP 中执行方法)或其中一个 sub-packages：</li>
</ul>
<pre><code>within(com.xyz.service..*)
</code></pre>
<ul>
<li>代理实现<code>AccountService</code>接口的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<pre><code>this(com.xyz.service.AccountService)
</code></pre>
<blockquote>
<p>‘this’更常用于 binding 形式。有关如何在建议正文中提供代理 object 的信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#transaction">宣布建议</a>部分。</p>
</blockquote>
<ul>
<li>目标 object 实现<code>AccountService</code>接口的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<pre><code>target(com.xyz.service.AccountService)
</code></pre>
<blockquote>
<p>‘target’更常用于 binding 形式。请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-advice">宣布建议</a>部分，了解如何在建议体中提供目标 object。</p>
</blockquote>
<ul>
<li>采用单个参数的任何连接点(仅在 Spring AOP 中执行方法)以及在运行时传递的参数为<code>Serializable</code>：</li>
</ul>
<pre><code>args(java.io.Serializable)
</code></pre>
<blockquote>
<p>‘args’更常用于 binding 形式。请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-advice">宣布建议</a>部分，了解如何在建议体中提供方法 arguments。</p>
</blockquote>
<p>请注意，此 example 中给出的切入点与<code>execution(* *(java.io.Serializable))</code>不同。如果在运行时传递的参数是<code>Serializable</code>，则 args version 匹配，如果方法签名声明了<code>Serializable</code>类型的单个参数，则执行 version 匹配。</p>
<ul>
<li>目标 object 具有<code>@Transactional</code> annotation 的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<pre><code>@target(org.springframework.transaction.annotation.Transactional)
</code></pre>
<blockquote>
<p>您还可以在 binding 表单中使用“@target”。请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-advice">宣布建议</a>部分，了解如何在建议体中提供 annotation object。</p>
</blockquote>
<ul>
<li>任何连接点(仅在 Spring AOP 中执行方法)，其中目标 object 的声明类型具有<code>@Transactional</code> annotation：</li>
</ul>
<pre><code>@within(org.springframework.transaction.annotation.Transactional)
</code></pre>
<blockquote>
<p>您还可以在 binding 表单中使用“@within”。请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-advice">宣布建议</a>部分，了解如何在建议体中提供 annotation object。</p>
</blockquote>
<ul>
<li>任何连接点(仅在 Spring AOP 中执行方法)，其中执行方法具有<code>@Transactional</code> annotation：</li>
</ul>
<pre><code>@annotation(org.springframework.transaction.annotation.Transactional)
</code></pre>
<blockquote>
<p>您还可以在 binding 表单中使用“@annotation”。请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-advice">宣布建议</a>部分，了解如何在建议体中提供 annotation object。</p>
</blockquote>
<ul>
<li>任何连接点(仅在 Spring AOP 中执行方法)，它接受一个参数，并且传递的参数的运行时类型具有<code>@Classified</code> annotation：</li>
</ul>
<pre><code>@args(com.xyz.security.Classified)
</code></pre>
<blockquote>
<p>您还可以在 binding 表单中使用“@args”。请参阅建议正文中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-advice">宣布建议</a>部分如何使 annotation object(s 可用。</p>
</blockquote>
<ul>
<li>名为<code>tradeService</code>的 Spring bean 上的任何连接点(仅在 Spring AOP 中执行方法)：</li>
</ul>
<pre><code>bean(tradeService)
</code></pre>
<ul>
<li>Spring beans 上的任何连接点(仅在 Spring AOP 中执行方法)具有匹配通配符表达式<code>*Service</code>的名称：</li>
</ul>
<pre><code>bean(*Service)
</code></pre>
<h5 id="写好切入点"><a href="#写好切入点" class="headerlink" title="写好切入点"></a>写好切入点</h5><p>在编译期间，AspectJ 处理 order 中的切入点以优化匹配 performance。检查 code 并确定每个连接点是否匹配(静态或动态)给定的切入点是一个代价高昂的 process。 (动态 match 表示无法通过静态分析完全确定 match，并且在 code 中放置一个测试以确定 code 是否正在运行时是否存在实际的 match)。在第一次遇到切入点声明时，AspectJ 将其重写为匹配 process 的最佳形式。这是什么意思？基本上，切入点在 DNF(析取范式)中重写，并且切入点的组件被排序，以便首先检查那些评估更便宜的组件。这意味着您不必担心理解各种切入点指示符的 performance，并且可以在切入点声明中的任何 order 中提供它们。</p>
<p>但是，AspectJ 只能使用它所说的内容。为了获得最佳的匹配性能，您应该考虑他们想要实现的目标，并在定义中尽可能缩小匹配的搜索空间。现有的指示符自然分为三组：kinded，scoping 和 contextual：</p>
<ul>
<li>Kinded 指示符选择一种特定的连接点：<code>execution</code>，<code>get</code>，<code>set</code>，<code>call</code>和<code>handler</code>。</li>
<li>范围指示符选择一组感兴趣的连接点(可能有多种类型)：<code>within</code>和<code>withincode</code></li>
<li>上下文指示符 match(并且可选地绑定)基于 context：<code>this</code>，<code>target</code>和<code>@annotation</code></li>
</ul>
<p>一个写得很好的切入点应至少包括前两种类型(kinded 和 scoping)。您可以根据连接点 context 将上下文指示符包含到 match 中，或者绑定 context 以在建议中使用。由于额外的处理和分析，仅提供一个 kinded 指示符或仅提供上下文指示符，但可能会影响编织 performance(time 和 memory used)。范围界定指示符非常快匹配，并且使用它们意味着 AspectJ 可以非常快速地解除不应该进一步处理的连接点组。如果可能，一个好的切入点应该总是包含一个。</p>
<h4 id="5-4-4-宣布建议"><a href="#5-4-4-宣布建议" class="headerlink" title="5.4.4. 宣布建议"></a>5.4.4. 宣布建议</h4><p>建议与切入点表达式相关联，并在切入点匹配的方法执行之前，之后或周围运行。切入点表达式可以是对命名切入点的简单引用，也可以是在适当位置声明的切入点表达式。</p>
<h5 id="在建议之前"><a href="#在建议之前" class="headerlink" title="在建议之前"></a>在建议之前</h5><p>您可以使用<code>@Before</code> annotation 在 aspect 中的通知之前声明：</p>
<pre><code>import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample &#123;

    @Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)
    public void doAccessCheck() &#123;
        // ...
    &#125;

&#125;
</code></pre>
<p>如果我们使用 in-place 切入点表达式，我们可以将前面的 example 写为以下 example：</p>
<pre><code>import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample &#123;

    @Before(&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;)
    public void doAccessCheck() &#123;
        // ...
    &#125;

&#125;
</code></pre>
<h5 id="返回建议后"><a href="#返回建议后" class="headerlink" title="返回建议后"></a>返回建议后</h5><p>返回建议后，匹配的方法执行正常返回。您可以使用<code>@AfterReturning</code> annotation 声明它：</p>
<pre><code>import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample &#123;

    @AfterReturning(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)
    public void doAccessCheck() &#123;
        // ...
    &#125;

&#125;
</code></pre>
<blockquote>
<p>您可以在同一个 aspect 中拥有多个建议声明(以及其他成员)。我们在这些示例中仅显示一个建议声明，以集中每个声明的效果。</p>
</blockquote>
<p>有时，您需要在建议正文中访问返回的实际 value。您可以使用绑定 return value 的<code>@AfterReturning</code>形式来获取该访问权限，如下面的 example 所示：</p>
<pre><code>import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample &#123;

    @AfterReturning(
        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,
        returning=&quot;retVal&quot;)
    public void doAccessCheck(Object retVal) &#123;
        // ...
    &#125;

&#125;
</code></pre>
<p><code>returning</code>属性中使用的 name 必须与 advice 方法中参数的 name 相对应。当方法执行返回时，return value 将作为相应的参数 value 传递给 advice 方法。 <code>returning</code>子句还将匹配仅限于那些 return 指定类型的 value 的方法执行(在这种情况下，<code>Object</code>，它匹配任何 return value)。</p>
<p>请注意，在返回建议后使用时，无法 return 完全不同的 reference。</p>
<h5 id="投掷建议后"><a href="#投掷建议后" class="headerlink" title="投掷建议后"></a>投掷建议后</h5><p>抛出建议运行时，匹配的方法执行通过抛出 exception 退出。您可以使用<code>@AfterThrowing</code> annotation 声明它，如下面的 example 所示：</p>
<pre><code>import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample &#123;

    @AfterThrowing(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)
    public void doRecoveryActions() &#123;
        // ...
    &#125;

&#125;
</code></pre>
<p>通常，只有在抛出给定类型的 exceptions 时才需要 run 建议，并且您还经常需要访问通知体中抛出的 exception。您可以使用<code>throwing</code>属性来限制匹配(如果需要，否则使用<code>Throwable</code>作为 exception 类型)并将抛出的 exception 绑定到 advice 参数。以下 example 显示了如何执行此操作：</p>
<pre><code>import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample &#123;

    @AfterThrowing(
        pointcut=&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;,
        throwing=&quot;ex&quot;)
    public void doRecoveryActions(DataAccessException ex) &#123;
        // ...
    &#125;

&#125;
</code></pre>
<p><code>throwing</code>属性中使用的 name 必须与 advice 方法中参数的 name 相对应。当通过抛出 exception 退出方法时，exception 将作为相应的参数 value 传递给 advice 方法。 <code>throwing</code>子句还将匹配仅限于那些抛出指定类型的 exception 的方法执行(在本例中为<code>DataAccessException</code>)。</p>
<h5 id="之后-最后-建议"><a href="#之后-最后-建议" class="headerlink" title="之后(最后)建议"></a>之后(最后)建议</h5><p>在匹配的方法执行退出之后(最终)建议运行之后。它是使用<code>@After</code> annotation 声明的。在建议之后必须准备好处理正常和 exception return 条件。它通常用于释放资源和类似目的。以下 example 显示了最终建议后如何使用：</p>
<pre><code>import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;

@Aspect
public class AfterFinallyExample &#123;

    @After(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation()&quot;)
    public void doReleaseLock() &#123;
        // ...
    &#125;

&#125;
</code></pre>
<h5 id="围绕建议"><a href="#围绕建议" class="headerlink" title="围绕建议"></a>围绕建议</h5><p>最后一种建议是建议。周围的建议围绕匹配方法的执行运行。它有机会在方法执行之前和之后完成工作，并确定何时，如何，甚至方法实际上都可以执行。如果您需要在方法执行之前和之后以 thread-safe 方式共享 state(启动和停止计时器，对于 example)，通常会使用 around 建议。始终使用符合您要求的最不强大的建议形式(也就是说，如果建议之前不要使用建议)。</p>
<p>使用<code>@Around</code> annotation 声明 around 建议。 advice 方法的第一个参数必须是<code>ProceedingJoinPoint</code>类型。在通知的主体内，在<code>ProceedingJoinPoint</code>上调用<code>proceed()</code>会导致执行基础方法。 <code>proceed</code>方法也可以传入<code>Object[]</code>。 array 中的值在进行时用作方法执行的 arguments。</p>
<blockquote>
<p>使用<code>Object[]</code>调用时<code>proceed</code>的行为与由 AspectJ 编译器编译的周围建议的<code>proceed</code>行为略有不同。对于使用传统 AspectJ 语言编写的周围建议，传递给<code>proceed</code>的 arguments 的数量必须匹配传递给 around 建议的 arguments 的数量(不是底层连接点采用的 arguments 的数量)，并且 value 传递给给定的参数位置取代了 value 所绑定的实体的连接点处的原始 value(如果现在没有意义，请不要担心)。 Spring 采用的方法比其 proxy-based，execution-only 语义更简单，更好匹配。如果编译为 Spring 编写的 @AspectJ 方面并使用带有 ARguments 的<code>proceed</code>与 AspectJ 编译器和 weaver，则只需要知道这种差异。有一种方法可以在 Spring AOP 和 AspectJ 上编写 100％兼容的方面，这在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-advice">以下有关建议参数的部分</a>中有所讨论。</p>
</blockquote>
<p>以下 example 显示了如何使用 around 建议：</p>
<pre><code>import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.ProceedingJoinPoint;

@Aspect
public class AroundExample &#123;

    @Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)
    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;
        // start stopwatch
        Object retVal = pjp.proceed();
        // stop stopwatch
        return retVal;
    &#125;

&#125;
</code></pre>
<p>around 建议返回的 value 是方法调用者看到的 return value。例如，一个简单的缓存 aspect 可以从缓存中返回 value(如果有的话)，如果没有则调用<code>proceed()</code>。请注意，<code>proceed</code>可以在 around 建议的主体内调用一次，多次或根本不调用。所有这些都是合法的。</p>
<h5 id="建议参数"><a href="#建议参数" class="headerlink" title="建议参数"></a>建议参数</h5><p>Spring 提供了完全类型的建议，这意味着您在建议签名中声明了所需的参数(正如我们之前看到的返回和抛出示例)，而不是在 time中使用<code>Object[]</code>数组。我们将在本节后面的内容中看到如何使建议和其他上下文值可用。首先，我们来看看如何编写通用建议，以便了解建议目前建议的方法。</p>
<h6 id="访问当前-JoinPoint"><a href="#访问当前-JoinPoint" class="headerlink" title="访问当前 JoinPoint"></a>访问当前 JoinPoint</h6><p>任何通知方法都可以声明一个类型为<code>org.aspectj.lang.JoinPoint</code>的参数作为其第一个参数(请注意，需要使用 around 通知声明<code>ProceedingJoinPoint</code>类型的第一个参数，它是<code>JoinPoint</code>的子类.<code>JoinPoint</code>接口提供了许多有用的方法：</p>
<ul>
<li><code>getArgs()</code>：返回方法 arguments。</li>
<li><code>getThis()</code>：返回代理 object。</li>
<li><code>getTarget()</code>：返回目标 object。</li>
<li><code>getSignature()</code>：返回正在建议的方法的描述。</li>
<li><code>toString()</code>：打印建议方法的有用描述。</li>
</ul>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html">javadoc</a>。</p>
<h6 id="将参数传递给建议"><a href="#将参数传递给建议" class="headerlink" title="将参数传递给建议"></a>将参数传递给建议</h6><p>我们已经看到了如何绑定返回的 value 或 exception value(在返回之后和抛出建议之后使用)。要使参数值可用于建议体，可以使用<code>args</code>的 binding 形式。如果在 args 表达式中使用参数 name 代替类型 name，则在调用通知时，相应参数的 value 将作为参数 value 传递。 示例应该使这更清楚。假设您想建议执行以<code>Account</code> object 作为第一个参数的 DAO 操作，并且您需要访问建议体中的帐户。你可以写下面的内容：</p>
<pre><code>@Before(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)
public void validateAccount(Account account) &#123;
    // ...
&#125;
</code></pre>
<p>切入点表达式的<code>args(account,..)</code>部分有两个目的。首先，它将匹配仅限于那些方法至少采用一个参数的方法执行，而传递给该参数的参数是<code>Account</code>的实例。其次，它通过<code>account</code>参数使实际的<code>Account</code> object 可用于建议。</p>
<p>另一种编写方法是声明一个切入点，当它与连接点匹配时“提供”<code>Account</code> object value，然后从建议中引用指定的切入点。这看起来如下：</p>
<pre><code>@Pointcut(&quot;com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)&quot;)
private void accountDataAccessOperation(Account account) &#123;&#125;

@Before(&quot;accountDataAccessOperation(account)&quot;)
public void validateAccount(Account account) &#123;
    // ...
&#125;
</code></pre>
<p>有关更多详细信息，请参阅 AspectJ 编程指南。</p>
<p>代理 object(<code>this</code>)，目标 object(<code>target</code>)和 annotations(<code>@within</code>，<code>@target</code>，<code>@annotation</code>和<code>@args</code>)都可以以类似的方式绑定。接下来的两个示例显示如何匹配使用<code>@Auditable</code> annotation 注释的方法的执行并提取 audit code：</p>
<p>这两个示例中的第一个显示了<code>@Auditable</code> annotation 的定义：</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Auditable &#123;
    AuditCode value();
&#125;
</code></pre>
<p>这两个示例中的第二个显示了与<code>@Auditable</code>方法的执行相匹配的建议：</p>
<pre><code>@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)&quot;)
public void audit(Auditable auditable) &#123;
    AuditCode code = auditable.value();
    // ...
&#125;
</code></pre>
<h6 id="建议参数和泛型"><a href="#建议参数和泛型" class="headerlink" title="建议参数和泛型"></a>建议参数和泛型</h6><p>Spring AOP 可以处理 class 声明和方法参数中使用的泛型。假设您有一个如下所示的泛型类型：</p>
<pre><code>public interface Sample&lt;T&gt; &#123;
    void sampleGenericMethod(T param);
    void sampleGenericCollectionMethod(Collection&lt;T&gt; param);
&#125;
</code></pre>
<p>通过将 advice 参数 typing 到要拦截方法的参数类型，可以将方法类型的拦截限制为某些参数类型：</p>
<pre><code>@Before(&quot;execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)&quot;)
public void beforeSampleMethod(MyType param) &#123;
    // Advice implementation
&#125;
</code></pre>
<p>此方法不适用于通用集合。因此，您无法按如下方式定义切入点：</p>
<pre><code>@Before(&quot;execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)&quot;)
public void beforeSampleMethod(Collection&lt;MyType&gt; param) &#123;
    // Advice implementation
&#125;
</code></pre>
<p>为了使这项工作，我们必须检查集合的每个元素，这是不合理的，因为我们也无法决定如何处理<code>null</code>值。要实现与此类似的操作，您必须将参数键入<code>Collection&lt;?&gt;</code>并手动检查元素的类型。</p>
<h6 id="确定参数名称"><a href="#确定参数名称" class="headerlink" title="确定参数名称"></a>确定参数名称</h6><p>通知调用中的参数 binding 依赖于切入点表达式中使用的匹配名称与通知和切入点方法签名中声明的参数名称。参数名称不能通过 Java 反射获得，因此 Spring AOP 使用以下策略来确定参数名称：</p>
<ul>
<li>如果用户已明确指定参数名称，则使用指定的参数名称。 advice 和 pointcut annotations 都有一个可选的<code>argNames</code>属性，您可以使用它来指定带注释的方法的参数名称。这些参数名称在运行时可用。以下 example 显示了如何使用<code>argNames</code>属性：</li>
</ul>
<pre><code>@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,
        argNames=&quot;bean,auditable&quot;)
public void audit(Object bean, Auditable auditable) &#123;
    AuditCode code = auditable.value();
    // ... use code and bean
&#125;
</code></pre>
<p>如果第一个参数是<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>或<code>JoinPoint.StaticPart</code>类型，则可以从<code>argNames</code>属性的 value 中省略参数的 name。对于 example，如果修改前面的建议以接收连接点 object，则<code>argNames</code>属性不需要包含它：</p>
<pre><code>@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,
        argNames=&quot;bean,auditable&quot;)
public void audit(JoinPoint jp, Object bean, Auditable auditable) &#123;
    AuditCode code = auditable.value();
    // ... use code, bean, and jp
&#125;
</code></pre>
<p>对<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>和<code>JoinPoint.StaticPart</code>类型的第一个参数赋予的特殊处理对于不收集任何其他连接点 context 的通知实例特别方便。在这种情况下，您可以省略<code>argNames</code>属性。对于 example，以下建议无需声明<code>argNames</code>属性：</p>
<pre><code>@Before(&quot;com.xyz.lib.Pointcuts.anyPublicMethod()&quot;)
public void audit(JoinPoint jp) &#123;
    // ... use jp
&#125;
</code></pre>
<ul>
<li>使用<code>&#39;argNames&#39;</code>属性有点笨拙，所以如果没有指定<code>&#39;argNames&#39;</code>属性，Spring AOP 会查看 class 的调试信息，并尝试从局部变量 table 中确定参数名称。此信息以 long 形式显示，因为 classes 已使用调试信息(至少<code>&#39;-g:vars&#39;</code>)进行编译。使用此 flag 进行编译的后果是：(1)您的 code 稍微容易理解(逆向工程)，(2)class 文件大小略大(通常无关紧要)，(3)优化删除未使用的本地变量未由编译器应用。换句话说，你应该通过 building 与 flag 一起遇到任何困难。</li>
</ul>
<blockquote>
<p>如果即使没有调试信息，AspectJ 编译器(ajc)也编译了 @AspectJ aspect，则无需添加<code>argNames</code>属性，因为编译器会保留所需的信息。</p>
</blockquote>
<ul>
<li>如果在没有必要的调试信息的情况下编译了 code，Spring AOP 会尝试推断 binding 变量与参数的配对(对于 example，如果只有一个变量绑定在切入点表达式中，并且 advice 方法只接受一个参数，那么配对很明显)。如果给定可用信息，变量的 binding 是不明确的，则抛出<code>AmbiguousBindingException</code>。</li>
<li>如果上述所有策略都失败，则抛出<code>IllegalArgumentException</code>。</li>
</ul>
<h6 id="继续-Arguments"><a href="#继续-Arguments" class="headerlink" title="继续 Arguments"></a>继续 Arguments</h6><p>我们之前评论过，我们将描述如何使用 arguments 编写<code>proceed</code>调用，这些调用在 Spring AOP 和 AspectJ 中一致地工作。解决方案是确保通知签名绑定 order 中的每个方法参数。以下 example 显示了如何执行此操作：</p>
<pre><code>@Around(&quot;execution(List&lt;Account&gt; find*(..)) &amp;&amp; &quot; +
        &quot;com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; &quot; +
        &quot;args(accountHolderNamePattern)&quot;)
public Object preProcessQueryPattern(ProceedingJoinPoint pjp,
        String accountHolderNamePattern) throws Throwable &#123;
    String newPattern = preProcess(accountHolderNamePattern);
    return pjp.proceed(new Object[] &#123;newPattern&#125;);
&#125;
</code></pre>
<p>在许多情况下，无论如何都要进行 binding(如前面的 example)。</p>
<h5 id="建议订购"><a href="#建议订购" class="headerlink" title="建议订购"></a>建议订购</h5><p>当多条建议都想在同一个连接点运行时会发生什么？ Spring AOP 遵循与 AspectJ 相同的优先级规则来确定建议执行的 order。最高优先级的建议首先“在路上”(因此，给出两条之前的建议，优先级最高的建议首先运行)。从连接点出来的“出路”中，最高优先级建议最后运行(因此，给出两条后建议，具有最高优先级的建议将以第二次运行)。</p>
<p>当在不同方面定义的两条建议都需要在同一个连接点运行时，除非另行指定，否则执行的 order 是未定义的。您可以通过指定优先级来控制执行的 order。这是通过在 aspect class 中实现<code>org.springframework.core.Ordered</code>接口或使用<code>Order</code> annotation 注释它，以正常的 Spring 方式完成的。给定两个方面，aspect 从<code>Ordered.getValue()</code>(或 annotation value)返回较低的 value 具有更高的优先级。</p>
<p>当在同一个 aspect 中定义的两条建议都需要在同一个连接点运行时，ordering 是未定义的(因为没有办法通过 javac-compiled classes 的反射来检索声明 order)。考虑将这些建议方法折叠到每个 aspect class 中每个连接点的一个建议方法中，或者将这些建议重构为单独的 aspect classes，您可以在 aspect level 中对其进行排序。</p>
<h4 id="5-4-5-简介"><a href="#5-4-5-简介" class="headerlink" title="5.4.5. 简介"></a>5.4.5. 简介</h4><p>简介(在 AspectJ 中称为 inter-type 声明)使 aspect 能够声明建议的 objects 实现给定的接口，并代表那些 objects 提供该接口的 implementation。</p>
<p>您可以使用<code>@DeclareParents</code> annotation 进行介绍。此 annotation 用于声明匹配类型具有新的 parent(因此为 name)。对于 example，给定一个名为<code>UsageTracked</code>的接口和一个名为<code>DefaultUsageTracked</code>的接口的 implementation，以下 aspect 声明服务接口的所有实现者也实现<code>UsageTracked</code>接口(通过 JMX 为 example 公开统计信息)：</p>
<pre><code>@Aspect
public class UsageTracking &#123;

    @DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)
    public static UsageTracked mixin;

    @Before(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;)
    public void recordUsage(UsageTracked usageTracked) &#123;
        usageTracked.incrementUseCount();
    &#125;

&#125;
</code></pre>
<p>要实现的接口由注释字段的类型确定。 <code>@DeclareParents</code> annotation 的<code>value</code>属性是 AspectJ 类型 pattern。匹配类型的任何 bean 都实现<code>UsageTracked</code>接口。请注意，在前面的 example 的 before 建议中，service beans 可以直接用作<code>UsageTracked</code>接口的 implementation。如果以编程方式访问 bean，您将编写以下内容：</p>
<pre><code>UsageTracked usageTracked = (UsageTracked) context.getBean(&quot;myService&quot;);
</code></pre>
<h4 id="5-4-6-Aspect-Instantiation-Models"><a href="#5-4-6-Aspect-Instantiation-Models" class="headerlink" title="5.4.6. Aspect Instantiation Models"></a>5.4.6. Aspect Instantiation Models</h4><blockquote>
<p>这是一个高级的 topic。如果您刚刚开始使用 AOP，您可以安全地跳过它直到稍后。</p>
</blockquote>
<p>默认情况下，application context 中的每个 aspect 都有一个实例。 AspectJ calls singleton instantiation model。可以使用备用生命周期定义方面。 Spring 支持 AspectJ 的<code>perthis</code>和<code>pertarget</code>实例化模型(目前不支持<code>percflow, percflowbelow,</code>和<code>pertypewithin</code>)。</p>
<p>您可以通过在<code>@Aspect</code> annotation 中指定<code>perthis</code>子句来声明<code>perthis</code> aspect。考虑以下 example：</p>
<pre><code>@Aspect(&quot;perthis(com.xyz.myapp.SystemArchitecture.businessService())&quot;)
public class MyAspect &#123;

    private int someState;

    @Before(com.xyz.myapp.SystemArchitecture.businessService())
    public void recordServiceUsage() &#123;
        // ...
    &#125;

&#125;
</code></pre>
<p>在前面的示例中，<code>&#39;perthis&#39;</code>子句的作用是为执行业务服务的每个唯一服务 object 创建一个 aspect 实例(每个唯一的 object 在切入点表达式匹配的连接点处绑定到’this’)。 aspect 实例是在服务 object 上调用方法的第一个 time 创建的。当服务 object 超出范围时，aspect 超出范围。在创建 aspect 实例之前，不执行其中的任何建议。一旦创建了 aspect 实例，其中声明的建议就会在匹配的连接点执行，但仅当服务 object 是与此 aspect 关联的服务时才执行。有关<code>per</code>子句的更多信息，请参阅 AspectJ 编程指南。</p>
<p><code>pertarget</code> instantiation model 的工作方式与<code>perthis</code>完全相同，但它会在匹配的连接点为每个唯一目标 object 创建一个 aspect 实例。</p>
<h4 id="5-4-7-AOP-Example"><a href="#5-4-7-AOP-Example" class="headerlink" title="5.4.7. AOP Example"></a>5.4.7. AOP Example</h4><p>现在您已经了解了所有组成部分的工作原理，我们可以将它们放在一起做一些有用的事情。</p>
<p>由于并发问题，业务服务的执行有时会失败(例如，死锁失败者)。如果重试该操作，则可能在下一次尝试时成功。对于适合在这种情况下重试的业务服务(幂等操作不需要返回给用户进行冲突解决)，我们希望透明地重试操作以避免 client 看到<code>PessimisticLockingFailureException</code>。这是明确跨越服务层中的多个服务的要求，因此非常适合通过 aspect 实现。</p>
<p>因为我们想要重试操作，所以我们需要使用 around 建议，以便我们可以多次调用<code>proceed</code>。以下清单显示了基本的 aspect implementation：</p>
<pre><code>@Aspect
public class ConcurrentOperationExecutor implements Ordered &#123;

    private static final int DEFAULT_MAX_RETRIES = 2;

    private int maxRetries = DEFAULT_MAX_RETRIES;
    private int order = 1;

    public void setMaxRetries(int maxRetries) &#123;
        this.maxRetries = maxRetries;
    &#125;

    public int getOrder() &#123;
        return this.order;
    &#125;

    public void setOrder(int order) &#123;
        this.order = order;
    &#125;

    @Around(&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;)
    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable &#123;
        int numAttempts = 0;
        PessimisticLockingFailureException lockFailureException;
        do &#123;
            numAttempts++;
            try &#123;
                return pjp.proceed();
            &#125;
            catch(PessimisticLockingFailureException ex) &#123;
                lockFailureException = ex;
            &#125;
        &#125; while(numAttempts &lt;= this.maxRetries);
        throw lockFailureException;
    &#125;

&#125;
</code></pre>
<p>请注意，aspect 实现<code>Ordered</code>接口，以便我们可以将 aspect 的优先级设置为高于 transaction 建议(我们希望每次 time 时都重新执行 transaction)。 <code>maxRetries</code>和<code>order</code> properties 都由 Spring 配置。主要行动发生在<code>doConcurrentOperation</code>周围的建议中。请注意，对于 moment，我们将重试逻辑应用于每个<code>businessService()</code>。我们试图继续，如果我们失败<code>PessimisticLockingFailureException</code>，我们再试一次，除非我们已经用尽所有的重试尝试。</p>
<p>相应的 Spring configuration 如下：</p>
<pre><code>&lt;aop:aspectj-autoproxy/&gt;

&lt;bean id=&quot;concurrentOperationExecutor&quot; class=&quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor&quot;&gt;
    &lt;property name=&quot;maxRetries&quot; value=&quot;3&quot;/&gt;
    &lt;property name=&quot;order&quot; value=&quot;100&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>要优化 aspect 以便它只重试幂等操作，我们可以定义以下<code>Idempotent</code> annotation：</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent &#123;
    // marker annotation
&#125;
</code></pre>
<p>然后我们可以使用 annotation 来注释服务操作的 implementation。对 aspect 的更改仅重试幂等操作涉及改进切入点表达式，以便只有<code>@Idempotent</code>操作 match，如下所示：</p>
<pre><code>@Around(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; &quot; +
        &quot;@annotation(com.xyz.myapp.service.Idempotent)&quot;)
public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable &#123;
    ...
&#125;
</code></pre>
<h3 id="5-5-Schema-based-AOP-支持"><a href="#5-5-Schema-based-AOP-支持" class="headerlink" title="5.5. Schema-based AOP 支持"></a>5.5. Schema-based AOP 支持</h3><p>如果您更喜欢 XML-based 格式，Spring 还支持使用新的<code>aop</code>名称空间标记定义方面。支持与使用 @AspectJ 样式时完全相同的切入点表达式和建议种类。因此，在本节中，我们将重点放在新语法上，并将 reader 引用到上一节(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-params">@AspectJ 支持</a>)中的讨论，以便了解编写切入点表达式和_conding advice 参数。</p>
<p>要使用本节中描述的 aop 命名空间标记，您需要 import <code>spring-aop</code> schema，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj">XML Schema-based configuration</a>中所述。有关如何 import <code>aop</code>命名空间中的标记，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas">AOP schema</a>。</p>
<p>在 Spring 配置中，所有 aspect 和 advisor 元素必须放在<code>&lt;aop:config&gt;</code>元素中(在 application context configuration 中可以有多个<code>&lt;aop:config&gt;</code>元素)。 <code>&lt;aop:config&gt;</code>元素可以包含切入点，顾问程序和 aspect 元素(请注意，这些元素必须在该 order 中声明)。</p>
<blockquote>
<p><code>&lt;aop:config&gt;</code>样式的 configuration 大量使用 Spring 的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas-aop">auto-proxying</a>机制。如果您已经通过使用<code>BeanNameAutoProxyCreator</code>或类似的东西使用显式 auto-proxying，这可能会导致问题(例如建议不被编织)。推荐用法 pattern 是仅使用<code>&lt;aop:config&gt;</code>样式或仅使用<code>AutoProxyCreator</code>样式，并且永远不要混用它们。</p>
</blockquote>
<h4 id="5-5-1-声明-Aspect"><a href="#5-5-1-声明-Aspect" class="headerlink" title="5.5.1. 声明 Aspect"></a>5.5.1. 声明 Aspect</h4><p>使用 schema 支持时，aspect 是在 Spring application context 中定义为 bean 的常规 Java object。 state 和行为在 object 的字段和方法中捕获，切入点和建议信息在 XML 中捕获。</p>
<p>您可以使用&lt; hh:// +4512+ *3* &gt;元素声明 aspect，并使用<code>ref</code>属性引用支持 bean，如下面的 example 所示：</p>
<pre><code>&lt;aop:config&gt;
    &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;
        ...
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;
    ...
&lt;/bean&gt;
</code></pre>
<p>支持 aspect(在这种情况下为<code>aBean</code>)的 bean 当然可以配置和依赖注入，就像任何其他 Spring bean 一样。</p>
<h4 id="5-5-2-声明切入点"><a href="#5-5-2-声明切入点" class="headerlink" title="5.5.2. 声明切入点"></a>5.5.2. 声明切入点</h4><p>您可以在<code>&lt;aop:config&gt;</code>元素中声明一个命名切入点，让切入点定义在多个方面和顾问之间共享。</p>
<p>表示服务层中任何业务服务执行的切入点可以定义如下：</p>
<pre><code>&lt;aop:config&gt;

    &lt;aop:pointcut id=&quot;businessService&quot;
        expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;

&lt;/aop:config&gt;
</code></pre>
<p>请注意，切入点表达式本身使用与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-autoproxy">@AspectJ 支持</a>中描述的相同的 AspectJ 切入点表达式语言。如果使用基于 schema 的声明样式，则可以引用切入点表达式中类型(@Aspects)中定义的命名切入点。定义上述切入点的另一种方法如下：</p>
<pre><code>&lt;aop:config&gt;

    &lt;aop:pointcut id=&quot;businessService&quot;
        expression=&quot;com.xyz.myapp.SystemArchitecture.businessService()&quot;/&gt;

&lt;/aop:config&gt;
</code></pre>
<p>假设您有一个<code>SystemArchitecture</code> aspect，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj">共享 Common 切入点定义</a>中所述。</p>
<p>然后在 aspect 中声明切入点与声明 top-level 切入点非常相似，如下面的 example 所示：</p>
<pre><code>&lt;aop:config&gt;

    &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;

        &lt;aop:pointcut id=&quot;businessService&quot;
            expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;

        ...

    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;
</code></pre>
<p>与 @AspectJ aspect 的方式大致相同，使用基于 schema 的定义样式声明的切入点可以收集连接点 context。对于 example，以下切入点将<code>this</code> object 收集为连接点 context 并将其传递给建议：</p>
<pre><code>&lt;aop:config&gt;

    &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;

        &lt;aop:pointcut id=&quot;businessService&quot;
            expression=&quot;execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)&quot;/&gt;

        &lt;aop:before pointcut-ref=&quot;businessService&quot; method=&quot;monitor&quot;/&gt;

        ...

    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;
</code></pre>
<p>必须声明建议以通过包含匹配名称的参数来接收收集的连接点 context，如下所示：</p>
<pre><code>public void monitor(Object service) &#123;
    ...
&#125;
</code></pre>
<p>组合切入点 sub-expressions 时，<code>&amp;&amp;</code>在 XML 文档中很难处理，因此您可以分别使用<code>and</code>，<code>or</code>和<code>not</code>关键字代替<code>&amp;&amp;</code>，<code>||</code>和<code>!</code>。对于 example，可以更好地编写上一个切入点，如下所示：</p>
<pre><code>&lt;aop:config&gt;

    &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;

        &lt;aop:pointcut id=&quot;businessService&quot;
            expression=&quot;execution(* com.xyz.myapp.service..(..)) and this(service)&quot;/&gt;

        &lt;aop:before pointcut-ref=&quot;businessService&quot; method=&quot;monitor&quot;/&gt;

        ...
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p>请注意，以这种方式定义的切入点由 XML <code>id</code>引用，不能用作命名切入点来形成复合切入点。因此，schema-based 定义样式中的命名切入点支持比 @AspectJ 样式提供的更有限。</p>
<h4 id="5-5-3-宣布建议"><a href="#5-5-3-宣布建议" class="headerlink" title="5.5.3. 宣布建议"></a>5.5.3. 宣布建议</h4><p>schema-based AOP 支持使用与 @AspectJ 样式相同的五种建议，它们具有完全相同的语义。</p>
<h5 id="在建议之前-1"><a href="#在建议之前-1" class="headerlink" title="在建议之前"></a>在建议之前</h5><p>在匹配的方法执行之前运行建议之前。它使用&lt; hh:// +4545+ *3* &gt;元素在<code>&lt;aop:aspect&gt;</code>中声明，如下面的 example 所示：</p>
<pre><code>&lt;aop:aspect id=&quot;beforeExample&quot; ref=&quot;aBean&quot;&gt;

    &lt;aop:before
        pointcut-ref=&quot;dataAccessOperation&quot;
        method=&quot;doAccessCheck&quot;/&gt;

    ...

&lt;/aop:aspect&gt;
</code></pre>
<p>这里，<code>dataAccessOperation</code>是在顶部(<code>&lt;aop:config&gt;</code>)level 定义的切入点的<code>id</code>。要改为内联切入点，请将<code>pointcut-ref</code>属性替换为<code>pointcut</code>属性，如下所示：</p>
<pre><code>&lt;aop:aspect id=&quot;beforeExample&quot; ref=&quot;aBean&quot;&gt;

    &lt;aop:before
        pointcut=&quot;execution(* com.xyz.myapp.dao.*.*(..))&quot;
        method=&quot;doAccessCheck&quot;/&gt;

    ...

&lt;/aop:aspect&gt;
</code></pre>
<p>正如我们在讨论 @AspectJ 样式时所提到的，使用命名切入点可以显着提高 code 的可读性。</p>
<p><code>method</code>属性标识提供建议正文的方法(<code>doAccessCheck</code>)。必须为包含建议的 aspect 元素引用的 bean 定义此方法。在执行数据访问操作(由切入点表达式匹配的方法执行连接点)之前，将调用 aspect bean 上的<code>doAccessCheck</code>方法。</p>
<h5 id="返回建议后-1"><a href="#返回建议后-1" class="headerlink" title="返回建议后"></a>返回建议后</h5><p>在匹配的方法执行正常完成后返回通知运行。它以与建议之前相同的方式在<code>&lt;aop:aspect&gt;</code>中声明。以下 example 显示了如何声明它：</p>
<pre><code>&lt;aop:aspect id=&quot;afterReturningExample&quot; ref=&quot;aBean&quot;&gt;

    &lt;aop:after-returning
        pointcut-ref=&quot;dataAccessOperation&quot;
        method=&quot;doAccessCheck&quot;/&gt;

    ...

&lt;/aop:aspect&gt;
</code></pre>
<p>与 @AspectJ 样式一样，您可以在建议体内获取 return value。为此，请使用 returns 属性指定 return value 应传递到的参数的 name，如下面的 example 所示：</p>
<pre><code>&lt;aop:aspect id=&quot;afterReturningExample&quot; ref=&quot;aBean&quot;&gt;

    &lt;aop:after-returning
        pointcut-ref=&quot;dataAccessOperation&quot;
        returning=&quot;retVal&quot;
        method=&quot;doAccessCheck&quot;/&gt;

    ...

&lt;/aop:aspect&gt;
</code></pre>
<p><code>doAccessCheck</code>方法必须声明一个名为<code>retVal</code>的参数。此参数的类型以与<code>@AfterReturning</code>描述的相同方式约束匹配。对于 example，您可以按如下方式声明方法签名：</p>
<pre><code>public void doAccessCheck(Object retVal) &#123;...
</code></pre>
<h5 id="投掷建议后-1"><a href="#投掷建议后-1" class="headerlink" title="投掷建议后"></a>投掷建议后</h5><p>抛出建议执行时，匹配的方法执行通过抛出 exception 退出。它通过使用 after-throwing 元素在<code>&lt;aop:aspect&gt;</code>内声明，如下面的 example 所示：</p>
<pre><code>&lt;aop:aspect id=&quot;afterThrowingExample&quot; ref=&quot;aBean&quot;&gt;

    &lt;aop:after-throwing
        pointcut-ref=&quot;dataAccessOperation&quot;
        method=&quot;doRecoveryActions&quot;/&gt;

    ...

&lt;/aop:aspect&gt;
</code></pre>
<p>与 @AspectJ 样式一样，您可以在通知主体中获得抛出的 exception。为此，请使用 throwing 属性指定 exception 应传递到的参数的 name，如下面的 example 所示：</p>
<pre><code>&lt;aop:aspect id=&quot;afterThrowingExample&quot; ref=&quot;aBean&quot;&gt;

    &lt;aop:after-throwing
        pointcut-ref=&quot;dataAccessOperation&quot;
        throwing=&quot;dataAccessEx&quot;
        method=&quot;doRecoveryActions&quot;/&gt;

    ...

&lt;/aop:aspect&gt;
</code></pre>
<p><code>doRecoveryActions</code>方法必须声明一个名为<code>dataAccessEx</code>的参数。此参数的类型以与<code>@AfterThrowing</code>描述的相同方式约束匹配。对于 example，方法签名可以声明如下：</p>
<pre><code>public void doRecoveryActions(DataAccessException dataAccessEx) &#123;...
</code></pre>
<h5 id="之后-最后-建议-1"><a href="#之后-最后-建议-1" class="headerlink" title="之后(最后)建议"></a>之后(最后)建议</h5><p>在(最终)建议运行之后，无论匹配的方法执行如何退出。您可以使用<code>after</code>元素声明它，如下面的 example 所示：</p>
<pre><code>&lt;aop:aspect id=&quot;afterFinallyExample&quot; ref=&quot;aBean&quot;&gt;

    &lt;aop:after
        pointcut-ref=&quot;dataAccessOperation&quot;
        method=&quot;doReleaseLock&quot;/&gt;

    ...

&lt;/aop:aspect&gt;
</code></pre>
<h5 id="围绕建议-1"><a href="#围绕建议-1" class="headerlink" title="围绕建议"></a>围绕建议</h5><p>最后一种建议是建议。周围的建议围绕匹配的方法执行运行。它有机会在方法执行之前和之后完成工作，并确定何时，如何，甚至方法实际上都可以执行。 around 方法通常用于在 thread-safe 方式执行方法之前和之后共享 state(启动和停止计时器，用于 example)。始终使用符合您要求的最不强大的建议形式。如果在建议之前可以使用 job，请不要使用周围的建议。</p>
<p>您可以使用<code>aop:around</code>元素声明周围的建议。 advice 方法的第一个参数必须是<code>ProceedingJoinPoint</code>类型。在通知体内，在<code>ProceedingJoinPoint</code>上调用<code>proceed()</code>会导致执行基础方法。也可以使用<code>Object[]</code>调用<code>proceed</code>方法。 array 中的值在进行时用作方法执行的 arguments。有关使用<code>Object[]</code>调用<code>proceed</code>的注释，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-common-pointcuts">围绕建议</a>。以下 example 显示了如何在 XML 中声明建议：</p>
<pre><code>&lt;aop:aspect id=&quot;aroundExample&quot; ref=&quot;aBean&quot;&gt;

    &lt;aop:around
        pointcut-ref=&quot;businessService&quot;
        method=&quot;doBasicProfiling&quot;/&gt;

    ...

&lt;/aop:aspect&gt;
</code></pre>
<p><code>doBasicProfiling</code>建议的 implementation 可以与 @AspectJ example(当然减去 annotation)完全相同，如下面的 example 所示：</p>
<pre><code>public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;
    // start stopwatch
    Object retVal = pjp.proceed();
    // stop stopwatch
    return retVal;
&#125;
</code></pre>
<h5 id="建议参数-1"><a href="#建议参数-1" class="headerlink" title="建议参数"></a>建议参数</h5><p>schema-based 声明样式支持完全类型化的建议，方法与 @AspectJ 支持描述的方式相同 - 通过 name 匹配建议方法参数的切入点参数。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-around-advice">建议参数</a>。如果您希望显式指定通知方法的参数名称(不依赖于前面描述的检测策略)，可以使用通知元素的<code>arg-names</code>属性来实现，该属性的处理方式与<code>argNames</code>属性的处理方式相同。 advice annotation(如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-params">确定参数名称</a>中所述)。以下 example 显示了如何在 XML 中指定参数 name：</p>
<pre><code>&lt;aop:before
    pointcut=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)&quot;
    method=&quot;audit&quot;
    arg-names=&quot;auditable&quot;/&gt;
</code></pre>
<p><code>arg-names</code>属性接受 comma-delimited 参数名称列表。</p>
<p>以下稍微涉及方法的示例显示了一些与一些强类型参数一起使用的建议：</p>
<pre><code>package x.y.service;

public interface PersonService &#123;

    Person getPerson(String personName, int age);
&#125;

public class DefaultFooService implements FooService &#123;

    public Person getPerson(String name, int age) &#123;
        return new Person(name, age);
    &#125;
&#125;
</code></pre>
<p>接下来是 aspect。请注意<code>profile(..)</code>方法接受多个 strongly-typed 参数的事实，第一个参数恰好是用于继续方法调用的连接点。此参数的存在表示<code>profile(..)</code>将用作<code>around</code>建议，如以下 example 所示：</p>
<pre><code>package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;

public class SimpleProfiler &#123;

    public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable &#123;
        StopWatch clock = new StopWatch(&quot;Profiling for &#39;&quot; + name + &quot;&#39; and &#39;&quot; + age + &quot;&#39;&quot;);
        try &#123;
            clock.start(call.toShortString());
            return call.proceed();
        &#125; finally &#123;
            clock.stop();
            System.out.println(clock.prettyPrint());
        &#125;
    &#125;
&#125;
</code></pre>
<p>最后，以下 example XML configuration 会影响特定连接点的前一个建议的执行：</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!-- this is the object that will be proxied by Spring&#39;s AOP infrastructure --&gt;
    &lt;bean id=&quot;personService&quot; class=&quot;x.y.service.DefaultPersonService&quot;/&gt;

    &lt;!-- this is the actual advice itself --&gt;
    &lt;bean id=&quot;profiler&quot; class=&quot;x.y.SimpleProfiler&quot;/&gt;

    &lt;aop:config&gt;
        &lt;aop:aspect ref=&quot;profiler&quot;&gt;

            &lt;aop:pointcut id=&quot;theExecutionOfSomePersonServiceMethod&quot;
                expression=&quot;execution(* x.y.service.PersonService.getPerson(String,int))
                and args(name, age)&quot;/&gt;

            &lt;aop:around pointcut-ref=&quot;theExecutionOfSomePersonServiceMethod&quot;
                method=&quot;profile&quot;/&gt;

        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>请考虑以下驱动程序脚本：</p>
<pre><code>import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.service.PersonService;

public final class Boot &#123;

    public static void main(final String[] args) throws Exception &#123;
        BeanFactory ctx = new ClassPathXmlApplicationContext(&quot;x/y/plain.xml&quot;);
        PersonService person = (PersonService) ctx.getBean(&quot;personService&quot;);
        person.getPerson(&quot;Pengo&quot;, 12);
    &#125;
&#125;
</code></pre>
<p>使用这样的 Boot class，我们将在标准输出上获得类似于以下内容的输出：</p>
<pre><code>StopWatch &#39;Profiling for &#39;Pengo&#39; and &#39;12&#39;&#39;: running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)
</code></pre>
<h5 id="建议订购-1"><a href="#建议订购-1" class="headerlink" title="建议订购"></a>建议订购</h5><p>当多个建议需要在同一个连接点(执行方法)执行时，ordering 规则如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-params-names">建议订购</a>中所述。方面之间的优先级是通过将<code>Order</code> annotation 添加到支持 aspect 的 bean 或 bean 实现<code>Ordered</code>接口来确定的。</p>
<h4 id="5-5-4-简介"><a href="#5-5-4-简介" class="headerlink" title="5.5.4. 简介"></a>5.5.4. 简介</h4><p>介绍(在 AspectJ 中称为 inter-type 声明)让 aspect 声明建议 objects 实现给定的接口并代表那些 objects 提供该接口的 implementation。</p>
<p>您可以使用<code>aop:aspect</code>中的<code>aop:declare-parents</code>元素进行介绍。您可以使用<code>aop:declare-parents</code>元素声明匹配类型具有新的 parent(因此为 name)。对于 example，给定名为<code>UsageTracked</code>的接口和名为<code>DefaultUsageTracked</code>的接口的 implementation，以下 aspect 声明服务接口的所有实现者也实现<code>UsageTracked</code>接口。 (在_中通过 JMX 为 example.)公开统计数据</p>
<pre><code>&lt;aop:aspect id=&quot;usageTrackerAspect&quot; ref=&quot;usageTracking&quot;&gt;

    &lt;aop:declare-parents
        types-matching=&quot;com.xzy.myapp.service.*+&quot;
        implement-interface=&quot;com.xyz.myapp.service.tracking.UsageTracked&quot;
        default-impl=&quot;com.xyz.myapp.service.tracking.DefaultUsageTracked&quot;/&gt;

    &lt;aop:before
        pointcut=&quot;com.xyz.myapp.SystemArchitecture.businessService()
            and this(usageTracked)&quot;
            method=&quot;recordUsage&quot;/&gt;

&lt;/aop:aspect&gt;
</code></pre>
<p>支持<code>usageTracking</code> bean 的 class 将包含以下方法：</p>
<pre><code>public void recordUsage(UsageTracked usageTracked) &#123;
    usageTracked.incrementUseCount();
&#125;
</code></pre>
<p>要实现的接口由<code>implement-interface</code>属性确定。 <code>types-matching</code>属性的 value 是 AspectJ 类型 pattern。匹配类型的任何 bean 都实现<code>UsageTracked</code>接口。请注意，在前面的 example 的 before 建议中，service beans 可以直接用作<code>UsageTracked</code>接口的 implementation。要以编程方式访问 bean，您可以编写以下内容：</p>
<pre><code>UsageTracked usageTracked = (UsageTracked) context.getBean(&quot;myService&quot;);
</code></pre>
<h4 id="5-5-5-Aspect-Instantiation-Models"><a href="#5-5-5-Aspect-Instantiation-Models" class="headerlink" title="5.5.5. Aspect Instantiation Models"></a>5.5.5. Aspect Instantiation Models</h4><p>schema-defined 方面唯一支持的实例化 model 是 singleton model。未来的版本可能支持其他实例化模型。</p>
<h4 id="5-5-6-顾问"><a href="#5-5-6-顾问" class="headerlink" title="5.5.6. 顾问"></a>5.5.6. 顾问</h4><p>“顾问”的概念来自 Spring 中定义的 AOP 支持，并且在 AspectJ 中没有直接的等价物。顾问就像一个小的 self-contained aspect，有一条建议。建议本身由 bean 表示，并且必须实现<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-ordering">Spring 中的建议类型</a>中描述的建议接口之一。顾问可以利用 AspectJ 切入点表达式。</p>
<p>Spring 支持带有<code>&lt;aop:advisor&gt;</code>元素的顾问程序概念。您最常见的是它与 transactional advice 一起使用，它在 Spring 中也有自己的命名空间支持。以下 example 显示了一个顾问：</p>
<pre><code>&lt;aop:config&gt;

    &lt;aop:pointcut id=&quot;businessService&quot;
        expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;

    &lt;aop:advisor
        pointcut-ref=&quot;businessService&quot;
        advice-ref=&quot;tx-advice&quot;/&gt;

&lt;/aop:config&gt;

&lt;tx:advice id=&quot;tx-advice&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<p>除了前面的 example 中使用的<code>pointcut-ref</code>属性之外，您还可以使用<code>pointcut</code>属性来内联定义切入点表达式。</p>
<p>要定义顾问程序的优先级以便建议可以参与 ordering，请使用<code>order</code>属性来定义顾问程序的<code>Ordered</code> value。</p>
<h4 id="5-5-7-AOP-Schema-Example"><a href="#5-5-7-AOP-Schema-Example" class="headerlink" title="5.5.7. AOP Schema Example"></a>5.5.7. AOP Schema Example</h4><p>本节说明当使用 schema 支持重写时，并发锁定失败如何从<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api-advice-types">AOP Example</a>重试 example。</p>
<p>由于并发问题，业务服务的执行有时会失败(例如，死锁失败者)。如果重试该操作，则可能在下一次尝试时成功。对于适合在这种情况下重试的业务服务(幂等操作不需要返回给用户进行冲突解决)，我们希望透明地重试操作以避免 client 看到<code>PessimisticLockingFailureException</code>。这是明确跨越服务层中的多个服务的要求，因此非常适合通过 aspect 实现。</p>
<p>因为我们想要重试操作，所以我们需要使用 around 建议，以便我们可以多次调用<code>proceed</code>。以下清单显示了基本的 aspect implementation(这是一个使用 schema 支持的常规 Java class)：</p>
<pre><code>public class ConcurrentOperationExecutor implements Ordered &#123;

    private static final int DEFAULT_MAX_RETRIES = 2;

    private int maxRetries = DEFAULT_MAX_RETRIES;
    private int order = 1;

    public void setMaxRetries(int maxRetries) &#123;
        this.maxRetries = maxRetries;
    &#125;

    public int getOrder() &#123;
        return this.order;
    &#125;

    public void setOrder(int order) &#123;
        this.order = order;
    &#125;

    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable &#123;
        int numAttempts = 0;
        PessimisticLockingFailureException lockFailureException;
        do &#123;
            numAttempts++;
            try &#123;
                return pjp.proceed();
            &#125;
            catch(PessimisticLockingFailureException ex) &#123;
                lockFailureException = ex;
            &#125;
        &#125; while(numAttempts &lt;= this.maxRetries);
        throw lockFailureException;
    &#125;

&#125;
</code></pre>
<p>请注意，aspect 实现<code>Ordered</code>接口，以便我们可以将 aspect 的优先级设置为高于 transaction 建议(我们希望每次 time 时都重新执行 transaction)。 <code>maxRetries</code>和<code>order</code> properties 都由 Spring 配置。主要操作发生在<code>doConcurrentOperation</code> around advice 方法中。我们试着继续。如果我们以<code>PessimisticLockingFailureException</code>失败，我们会再次尝试，除非我们已经用尽所有重试尝试。</p>
<blockquote>
<p>此 class 与 @AspectJ example 中使用的 class 相同，但删除了 annotations。</p>
</blockquote>
<p>相应的 Spring configuration 如下：</p>
<pre><code>&lt;aop:config&gt;

    &lt;aop:aspect id=&quot;concurrentOperationRetry&quot; ref=&quot;concurrentOperationExecutor&quot;&gt;

        &lt;aop:pointcut id=&quot;idempotentOperation&quot;
            expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;

        &lt;aop:around
            pointcut-ref=&quot;idempotentOperation&quot;
            method=&quot;doConcurrentOperation&quot;/&gt;

    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;

&lt;bean id=&quot;concurrentOperationExecutor&quot;
    class=&quot;com.xyz.myapp.service.impl.ConcurrentOperationExecutor&quot;&gt;
        &lt;property name=&quot;maxRetries&quot; value=&quot;3&quot;/&gt;
        &lt;property name=&quot;order&quot; value=&quot;100&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>请注意，对于 time，我们假设所有业务服务都是幂等的。如果不是这种情况，我们可以通过引入<code>Idempotent</code> annotation 并使用 annotation 来注释服务操作的 implementation 来优化 aspect 以便它只重试真正的幂等操作，如下面的 example 所示：</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent &#123;
    // marker annotation
&#125;
</code></pre>
<p>对 aspect 的更改仅重试幂等操作涉及改进切入点表达式，以便只有<code>@Idempotent</code>操作 match，如下所示：</p>
<pre><code>&lt;aop:pointcut id=&quot;idempotentOperation&quot;
        expression=&quot;execution(* com.xyz.myapp.service.*.*(..)) and
        @annotation(com.xyz.myapp.service.Idempotent)&quot;/&gt;
</code></pre>
<h3 id="5-6-选择要使用的-AOP-声明样式"><a href="#5-6-选择要使用的-AOP-声明样式" class="headerlink" title="5.6. 选择要使用的 AOP 声明样式"></a>5.6. 选择要使用的 AOP 声明样式</h3><p>一旦确定 aspect 是实现给定需求的最佳方法，您如何决定使用 Spring AOP 或 AspectJ 以及 Aspect 语言(code)样式， @AspectJ annotation 样式还是 Spring XML 样式？这些决策受到许多因素的影响，包括应用要求，开发工具和团队对 AOP 的熟悉程度。</p>
<h4 id="5-6-1-Spring-AOP-或-Full-AspectJ？"><a href="#5-6-1-Spring-AOP-或-Full-AspectJ？" class="headerlink" title="5.6.1. Spring AOP 或 Full AspectJ？"></a>5.6.1. Spring AOP 或 Full AspectJ？</h4><p>使用最简单的方法。 Spring AOP 比使用完整的 AspectJ 更简单，因为不需要将 AspectJ 编译器/ weaver 引入您的开发和 build 进程。如果您只需要建议在 Spring beans 上执行操作，Spring AOP 是正确的选择。如果您需要建议不由 Spring 容器管理的 objects(例如域 objects)，则需要使用 AspectJ。如果您希望建议除简单方法执行之外的连接点(对于 example，字段 get 或 set join points 等)，还需要使用 AspectJ。</p>
<p>使用 AspectJ 时，您可以选择 AspectJ 语言语法(也称为“code 样式”)或 @AspectJ annotation 样式。显然，如果您不使用 Java 5，则可以选择：使用 code 样式。如果方面在您的设计中扮演重要角色，并且您能够使用 Eclipse 的<a target="_blank" rel="noopener" href="https://www.eclipse.org/ajdt/">AspectJ 开发工具(AJDT)</a>插件，则 AspectJ 语言语法是首选选项。它更清晰，更简单，因为该语言是专门为写作方面而设计的。如果您不使用 Eclipse 或只有几个方面在您的 application 中没有主要作用，您可能需要考虑使用 @AspectJ 样式，在 IDE 中坚持使用常规 Java 编译，并在其中添加 aspect 编织阶段 build 脚本。</p>
<h4 id="5-6-2-AspectJ-或-Spring-AOP-的-XML？"><a href="#5-6-2-AspectJ-或-Spring-AOP-的-XML？" class="headerlink" title="5.6.2. @AspectJ 或 Spring AOP 的 XML？"></a>5.6.2. @AspectJ 或 Spring AOP 的 XML？</h4><p>如果您已选择使用 Spring AOP，则可以选择 @AspectJ 或 XML 样式。需要考虑各种权衡。</p>
<p>XML 样式可能是现有 Spring 用户最熟悉的，并且由真正的 POJO 支持。当使用 AOP 作为配置企业服务的工具时，XML 可能是一个不错的选择(一个好的测试是你是否认为切入点表达式是你可能想要独立改变的 configuration 的一部分)。使用 XML 样式，可以从您的 configuration 中清楚地看出系统中存在哪些方面。</p>
<p>XML 风格有两个缺点。首先，它没有完全封装它在一个地方解决的要求的实现。 DRY 原则规定，系统中的任何知识都应该有单一，明确，权威的表示。使用 XML 样式时，有关如何实现需求的知识将分支到 back bean class 的声明和 configuration 文件中的 XML。使用 @AspectJ 样式时，此信息封装在单个模块中：aspect。其次，XML 样式在它表达的内容方面比 @AspectJ 样式稍微受限：仅支持“singleton”aspect instantiation model，并且不可能组合在 XML 中声明的命名切入点。对于 example，在 @AspectJ 样式中，您可以编写如下内容：</p>
<pre><code>@Pointcut(&quot;execution(* get*())&quot;)
public void propertyAccess() &#123;&#125;

@Pointcut(&quot;execution(org.xyz.Account+ *(..))&quot;)
public void operationReturningAnAccount() &#123;&#125;

@Pointcut(&quot;propertyAccess() &amp;&amp; operationReturningAnAccount()&quot;)
public void accountPropertyAccess() &#123;&#125;
</code></pre>
<p>在 XML 样式中，您可以声明前两个切入点：</p>
<pre><code>&lt;aop:pointcut id=&quot;propertyAccess&quot;
        expression=&quot;execution(* get*())&quot;/&gt;

&lt;aop:pointcut id=&quot;operationReturningAnAccount&quot;
        expression=&quot;execution(org.xyz.Account+ *(..))&quot;/&gt;
</code></pre>
<p>XML 方法的缺点是您无法通过组合这些定义来定义<code>accountPropertyAccess</code>切入点。</p>
<p>@AspectJ 样式支持其他实例化模型和更丰富的切入点组合。它具有将 aspect 保持为模块化单元的优点。它还具有 @AspectJ 方面可以被 Spring AOP 和 AspectJ 理解(并因此消耗)的优点。因此，如果您以后决定需要 AspectJ 的功能来实现其他要求，则可以轻松迁移到 AspectJ-based 方法。总而言之，只要您的方面不仅仅是简单的企业服务配置，Spring 团队更喜欢 @AspectJ 风格。</p>
<h3 id="5-7-混合-Aspect-类型"><a href="#5-7-混合-Aspect-类型" class="headerlink" title="5.7. 混合 Aspect 类型"></a>5.7. 混合 Aspect 类型</h3><p>通过使用 auto-proxying 支持，schema-defined <code>&lt;aop:aspect&gt;</code>方面，<code>&lt;aop:advisor&gt;</code>声明的顾问程序，甚至在同一 configuration 中使用 Spring 1.2 样式定义的代理和拦截器，完全可以混合 @AspectJ 样式方面。所有这些都是通过使用相同的底层支持机制实现的，并且可以毫无困难地 co-exist。</p>
<h3 id="5-8-代理机制"><a href="#5-8-代理机制" class="headerlink" title="5.8. 代理机制"></a>5.8. 代理机制</h3><p>Spring AOP 使用 JDK 动态代理或 CGLIB 为给定目标 object 创建代理。 (只要有选择，JDK 动态代理就是首选)。</p>
<p>如果要代理的目标 object 实现至少一个接口，则使用 JDK 动态代理。目标类型实现的所有接口都是代理的。如果目标 object 未实现任何接口，则会创建 CGLIB 代理。</p>
<p>如果要强制使用 CGLIB 代理(对于 example，代理为目标 object 定义的每个方法，而不仅仅是那些由其接口实现的方法)，您可以这样做。但是，您应该考虑以下问题：</p>
<ul>
<li>无法建议<code>final</code>方法，因为它们无法被覆盖。</li>
<li>从 Spring 3.2 开始，不再需要将 CGLIB 添加到项目 classpath 中，因为 CGLIB classes 在<code>org.springframework</code>下重新打包并直接包含在 spring-core JAR 中。这意味着 CGLIB-based 代理支持“正常工作”，就像 JDK 动态代理一样。</li>
<li>从 Spring 4.0 开始，代理 object 的构造函数不再被调用两次，因为 CGLIB 代理实例是通过 Objenesis 创建的。只有当您的 JVM 不允许构造函数绕过时，您才可以从 Spring 的 AOP 支持中看到 double 调用和相应的 debug log 条目。</li>
</ul>
<p>要强制使用 CGLIB 代理，请将<code>&lt;aop:config&gt;</code>元素的<code>proxy-target-class</code>属性的 value 设置为 true，如下所示：</p>
<pre><code>&lt;aop:config proxy-target-class=&quot;true&quot;&gt;
    &lt;!-- other beans defined here... --&gt;
&lt;/aop:config&gt;
</code></pre>
<p>要在使用 @AspectJ auto-proxy 支持时强制 CGLIB 代理，请将<code>&lt;aop:aspectj-autoproxy&gt;</code>元素的<code>proxy-target-class</code>属性设置为<code>true</code>，如下所示：</p>
<pre><code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;
</code></pre>
<blockquote>
<p>多个<code>&lt;aop:config/&gt;</code>部分在运行时折叠为单个统一的 auto-proxy 创建者，这将应用指定的任何<code>&lt;aop:config/&gt;</code>部分(通常来自不同的 XML bean definition files)的最强代理设置。这也适用于<code>&lt;tx:annotation-driven/&gt;</code>和<code>&lt;aop:aspectj-autoproxy/&gt;</code>元素。</p>
</blockquote>
<p>需要明确的是，在<code>&lt;tx:annotation-driven/&gt;</code>，<code>&lt;aop:aspectj-autoproxy/&gt;</code>或<code>&lt;aop:config/&gt;</code>元素上使用<code>proxy-target-class=&quot;true&quot;</code>会强制对所有这三个元素使用 CGLIB 代理。</p>
<h4 id="5-8-1-了解-AOP-代理"><a href="#5-8-1-了解-AOP-代理" class="headerlink" title="5.8.1. 了解 AOP 代理"></a>5.8.1. 了解 AOP 代理</h4><p>Spring AOP 是 proxy-based。在编写自己的方面或使用 Spring Framework 提供的任何 Spring AOP-based 方面之前，掌握最后一个语句实际意味着什么的语义是非常重要的。</p>
<p>首先考虑具有 plain-vanilla，un-proxied，nothing-special-about-it，直 object reference 的场景，如下面的 code 片段所示：</p>
<pre><code>public class SimplePojo implements Pojo &#123;

    public void foo() &#123;
        // this next method invocation is a direct call on the &#39;this&#39; reference
        this.bar();
    &#125;

    public void bar() &#123;
        // some logic...
    &#125;
&#125;
</code></pre>
<p>如果在 object reference 上调用方法，则直接在该 object reference 上调用该方法，如下图所示：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/aop-proxy-plain-pojo-call.jpg" alt="aop proxy plain pojo call"></p>
<pre><code>public class Main &#123;

    public static void main(String[] args) &#123;

        Pojo pojo = new SimplePojo();

        // this is a direct method call on the &#39;pojo&#39; reference
        pojo.foo();
    &#125;
&#125;
</code></pre>
<p>当 client code 具有的 reference 是代理时，事情会略有变化。请考虑以下图表和 code 片段：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/aop-proxy-call.jpg" alt="aop 代理电话"></p>
<pre><code>public class Main &#123;

    public static void main(String[] args) &#123;

        ProxyFactory factory = new ProxyFactory(new SimplePojo());
        factory.addInterface(Pojo.class);
        factory.addAdvice(new RetryAdvice());

        Pojo pojo = (Pojo) factory.getProxy();

        // this is a method call on the proxy!
        pojo.foo();
    &#125;
&#125;
</code></pre>
<p>这里要理解的 key 是<code>Main</code> class 的<code>main(..)</code>方法中的 client code 对代理有一个 reference。这意味着 object reference 上的方法 calls 是代理上的 calls。因此，代理可以委托给与该特定方法调用相关的所有拦截器(通知)。但是，一旦调用最终到达目标 object(在这种情况下是<code>SimplePojo</code>，reference)，它可能会对或<code>this.foo()</code>进行调用的任何方法 calls 将被调用<code>this</code> reference，而不是代理。这具有重要意义。这意味着 self-invocation 不会导致与方法调用相关的建议有机会执行。</p>
<p>好的，那么该怎么办呢？最好的方法(术语“最好”，在这里松散地使用)是重构你的 code，以便 self-invocation 不会发生。这确实需要你做一些工作，但这是最好的，least-invasive 方法。接下来的方法是绝对可怕的，我们毫不犹豫地指出它，正是因为它是如此可怕。您可以(对我们来说很痛苦)将 class 中的逻辑完全绑定到 Spring AOP，如下面的示例所示：</p>
<pre><code>public class SimplePojo implements Pojo &#123;

    public void foo() &#123;
        // this works, but... gah!
        ((Pojo) AopContext.currentProxy()).bar();
    &#125;

    public void bar() &#123;
        // some logic...
    &#125;
&#125;
</code></pre>
<p>这完全将你的 code 耦合到 Spring AOP，它使 class 本身意识到它正在 AOP context 中使用，它在 AOP 面前飞行。在创建代理时，它还需要一些额外的 configuration，如下面的 example 所示：</p>
<pre><code>public class Main &#123;

    public static void main(String[] args) &#123;

        ProxyFactory factory = new ProxyFactory(new SimplePojo());
        factory.adddInterface(Pojo.class);
        factory.addAdvice(new RetryAdvice());
        factory.setExposeProxy(true);

        Pojo pojo = (Pojo) factory.getProxy();

        // this is a method call on the proxy!
        pojo.foo();
    &#125;
&#125;
</code></pre>
<p>最后，必须注意的是 AspectJ 没有这个 self-invocation 问题，因为它不是 proxy-based AOP framework。</p>
<h3 id="5-9-程序化创建-AspectJ-代理"><a href="#5-9-程序化创建-AspectJ-代理" class="headerlink" title="5.9. 程序化创建 @AspectJ 代理"></a>5.9. 程序化创建 @AspectJ 代理</h3><p>除了使用<code>&lt;aop:config&gt;</code>或<code>&lt;aop:aspectj-autoproxy&gt;</code>在 configuration 中声明方面之外，还可以以编程方式创建建议目标 objects 的代理。有关 Spring 的 AOP API 的完整详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-example">下一章</a>。在这里，我们希望专注于使用 @AspectJ 方面自动创建代理的能力。</p>
<p>您可以使用<code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> class 为一个或多个 @AspectJ 方面建议的目标 object 创建代理。这个 class 的基本用法非常简单，如下面的示例所示：</p>
<pre><code>// create a factory that can generate a proxy for the given target object
AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);

// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects
factory.addAspect(SecurityManager.class);

// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
factory.addAspect(usageTracker);

// now get the proxy object...
MyInterfaceType proxy = factory.getProxy();
</code></pre>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/aspectj/annotation/AspectJProxyFactory.html">javadoc</a>。</p>
<h3 id="5-10-将-AspectJ-与-Spring-Applications-一起使用"><a href="#5-10-将-AspectJ-与-Spring-Applications-一起使用" class="headerlink" title="5.10. 将 AspectJ 与 Spring Applications 一起使用"></a>5.10. 将 AspectJ 与 Spring Applications 一起使用</h3><p>到目前为止，我们在本章中介绍的所有内容都是纯粹的 Spring AOP。在本节中，我们将介绍如何使用 AspectJ 编译器或 weaver 代替 Spring AOP 或者除了 Spring AOP 之外，如果您的需求超出了 Spring AOP 提供的功能。</p>
<p>Spring 附带一个小的 AspectJ aspect library，它在你的发行版中可以 stand-alone 作为<code>spring-aspects.jar</code>。您需要将此添加到 order 中的 classpath 以使用其中的方面。 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-api">使用 AspectJ 与依赖关系 Inject Domain Objects with Spring</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-atconfigurable">AspectJ 的其他 Spring 方面</a>讨论了这个 library 的内容以及如何使用它。 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ajlib-other">使用 Spring IoC 配置 AspectJ 方面</a>讨论了如何依赖 inject 使用 AspectJ 编译器编织的 AspectJ 方面。最后，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-configure">Load-time 在 Spring Framework 中使用 AspectJ 进行编织</a>介绍了 load-time 编织使用 AspectJ 的 Spring applications。</p>
<h4 id="5-10-1-使用-AspectJ-与依赖关系-Inject-Domain-Objects-with-Spring"><a href="#5-10-1-使用-AspectJ-与依赖关系-Inject-Domain-Objects-with-Spring" class="headerlink" title="5.10.1. 使用 AspectJ 与依赖关系 Inject Domain Objects with Spring"></a>5.10.1. 使用 AspectJ 与依赖关系 Inject Domain Objects with Spring</h4><p>Spring 容器实例化并配置 application context 中定义的 beans。在给定包含要应用的 configuration 的 bean 定义的 name 的情况下，也可以要求 bean 工厂配置 pre-existing object。 <code>spring-aspects.jar</code>包含 annotation-driven aspect，它利用此功能允许依赖注入任何 object。该支持旨在用于在任何容器控制之外创建的 objects。域 objects 通常属于此类别，因为它们通常使用<code>new</code> operator 或 ORM 工具以编程方式创建，这是数据库查询的结果。</p>
<p><code>@Configurable</code> annotation 将 class 标记为符合 Spring-driven configuration 的条件。在最简单的情况下，您可以纯粹使用它作为标记 annotation，如下面的 example 所示：</p>
<pre><code>package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable
public class Account &#123;
    // ...
&#125;
</code></pre>
<p>当以这种方式用作标记接口时，Spring 通过使用与 fully-qualified 类型 name(<code>com.xyz.myapp.domain.Account</code>)具有相同 name 的 bean 定义(通常为 prototype-scoped)来配置带注释类型的新实例(在本例中为<code>Account</code>)。由于 bean 的默认 name 是其类型的 fully-qualified name，因此声明原型定义的便捷方法是省略<code>id</code>属性，如下面的 example 所示：</p>
<pre><code>&lt;bean class=&quot;com.xyz.myapp.domain.Account&quot; scope=&quot;prototype&quot;&gt;
    &lt;property name=&quot;fundsTransferService&quot; ref=&quot;fundsTransferService&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>如果要显式指定要使用的原型 bean 定义的 name，可以直接在 annotation 中执行此操作，如下面的 example 所示：</p>
<pre><code>package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable(&quot;account&quot;)
public class Account &#123;
    // ...
&#125;
</code></pre>
<p>Spring 现在查找名为<code>account</code>的 bean 定义，并将其用作配置新<code>Account</code>实例的定义。</p>
<p>您还可以使用自动装配来避免必须指定专用的 bean 定义。要让 Spring 应用自动装配，请使用<code>@Configurable</code> 注释的<code>autowire</code> property。您可以分别按类型或 name 指定<code>@Configurable(autowire=Autowire.BY_TYPE)</code>或<code>@Configurable(autowire=Autowire.BY_NAME</code>进行自动装配。作为替代，从 Spring 2.5 开始，最好通过在字段或方法 level 上使用<code>@Autowired</code>或<code>@Inject</code>为<code>@Configurable</code> beans 指定显式的 annotation-driven 依赖注入(有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">Annotation-based Container Configuration</a>)。</p>
<p>最后，您可以使用<code>dependencyCheck</code>属性(对于 example，<code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>)为新创建和配置的 object 中的 object references 启用 Spring 依赖性检查。如果此属性设置为<code>true</code>，则 Spring 会在 configuration 之后验证是否已设置所有 properties(不是 primitives 或集合)。</p>
<p>请注意，使用 annotation 本身不会做任何事情。 <code>spring-aspects.jar</code>中的<code>AnnotationBeanConfigurerAspect</code>作用于 annotation 的存在。本质上，aspect 说，“在从<code>@Configurable</code>注释的类型的新 object 初始化返回后，根据 annotation 的 properties 使用 Spring 配置新创建的 object”。在此 context 中，“初始化”是指新实例化的 objects(对于 example，objects 用<code>new</code> operator 实例化)以及正在进行反序列化的<code>Serializable</code> objects(对于 example，通过<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html">readResolve()</a>)。</p>
<blockquote>
<p>上段中的一个 key 短语是“实质上”。对于大多数情况，“在从新的 object 初始化返回之后”的确切语义很好。在这个 context 中，“初始化之后”意味着在构造 object 之后注入依赖项。这意味着依赖项不可用于 class 的构造函数体。如果希望在构造函数体执行之前注入依赖项，从而可以在构造函数体中使用，则需要在<code>@Configurable</code>声明中定义它，如下所示：</p>
</blockquote>
<pre><code>@Configurable(preConstruction=true)
</code></pre>
<p>您可以在<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ 编程指南</a>的 AspectJ <a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">在本附录中</a>中找到有关各种切入点类型的语言语义的更多信息。</p>
<p>为此，必须使用 AspectJ 编织器编写带注释的类型。您可以使用 build-time Ant 或 Maven 任务执行此操作(请参阅示例，<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">AspectJ 开发环境指南</a>)或 load-time 编织(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config">Load-time 在 Spring Framework 中使用 AspectJ 进行编织</a>)。 <code>AnnotationBeanConfigurerAspect</code>本身需要由 Spring 配置(在 order 中以获取 bean 工厂的 reference 用于配置新的 objects)。如果使用 Java-based configuration，则可以将<code>@EnableSpringConfigured</code>添加到任何<code>@Configuration</code> class，如下所示：</p>
<pre><code>@Configuration
@EnableSpringConfigured
public class AppConfig &#123;

&#125;
</code></pre>
<p>如果您更喜欢基于 XML 的 configuration，Spring <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">context 命名空间</a>定义了一个方便的<code>context:spring-configured</code>元素，您可以按如下方式使用它：</p>
<pre><code>&lt;context:spring-configured/&gt;
</code></pre>
<p>在配置 aspect 之前创建的<code>@Configurable</code> objects 实例会导致向 debug log 发出消息，并且不会发生 object 的 configuration。 example 可能是 Spring configuration 中的 bean，它在 Spring 初始化时创建域 objects。在这种情况下，您可以使用<code>depends-on</code> bean 属性手动指定 bean 依赖于 configuration aspect。以下 example 显示了如何使用<code>depends-on</code>属性：</p>
<pre><code>&lt;bean id=&quot;myService&quot;
        class=&quot;com.xzy.myapp.service.MyService&quot;
        depends-on=&quot;org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect&quot;&gt;

    &lt;!-- ... --&gt;

&lt;/bean&gt;
</code></pre>
<blockquote>
<p>不要通过 bean configurer aspect 激活<code>@Configurable</code>处理，除非你真的想在运行时依赖它的语义。特别是，请确保不要在 bean classes 上使用<code>@Configurable</code>作为常规 Spring beans 与容器一起注册。这样做会导致 double 初始化，一次通过容器，一次通过 aspect。</p>
</blockquote>
<h5 id="单元测试-Configurable-Objects"><a href="#单元测试-Configurable-Objects" class="headerlink" title="单元测试 @Configurable Objects"></a>单元测试 @Configurable Objects</h5><p><code>@Configurable</code>支持的目标之一是启用域 objects 的独立单元测试，而没有与 hard-coded 查找相关的困难。如果<code>@Configurable</code>类型尚未由 AspectJ 编织，则 annotation 在单元测试期间不会产生任何影响。您可以在测试的 object 中设置 mock 或 stub property references 并正常进行。如果_J类型已由 AspectJ 编织，您仍然可以正常地在容器外部进行单元测试，但是每次 time 时都会看到一条警告消息，表明它尚未由 Spring 配置<code>@Configurable</code> object。</p>
<h5 id="使用多个-Application-上下文"><a href="#使用多个-Application-上下文" class="headerlink" title="使用多个 Application 上下文"></a>使用多个 Application 上下文</h5><p>用于实现<code>@Configurable</code>支持的<code>AnnotationBeanConfigurerAspect</code>是 AspectJ singleton aspect。 singleton aspect 的范围与<code>static</code>成员的范围相同：每个类加载器都有一个 aspect 实例来定义类型。这意味着，如果在同一个类加载器层次结构中定义多个 application 上下文，则需要考虑定义<code>@EnableSpringConfigured</code> bean 的位置以及将<code>spring-aspects.jar</code>放在 classpath 的位置。</p>
<p>考虑一个典型的 Spring web application configuration，它具有一个共享 parent application context，用于定义 common 业务服务，支持这些服务所需的一切，以及一个 child application context，用于每个 servlet(包含特定于该 servlet 的定义)。所有这些上下文都在同一个类加载器层次结构中 co-exist，因此<code>AnnotationBeanConfigurerAspect</code>只能对其中一个进行 reference。在这种情况下，我们建议在 shared(parent)application context 中定义<code>@EnableSpringConfigured</code> bean。这定义了您可能希望 inject into domain objects 的服务。结果是你无法通过使用 @Configurable 机制(可能不是你想要做的事情)将 references 配置为 references 到 child(servlet-specific)上下文中定义的_bends。</p>
<p>在同一容器中部署多个 web applications 时，请确保每个 web application 都使用自己的类加载器加载<code>spring-aspects.jar</code>中的类型(对于 example，将<code>spring-aspects.jar</code>放在<code>&#39;WEB-INF/lib&#39;</code>中)。如果<code>spring-aspects.jar</code>仅添加到 container-wide classpath(因此由共享 parent 类加载器加载)，则所有 web applications 共享相同的 aspect 实例(这可能不是您想要的)。</p>
<h4 id="5-10-2-AspectJ-的其他-Spring-方面"><a href="#5-10-2-AspectJ-的其他-Spring-方面" class="headerlink" title="5.10.2. AspectJ 的其他 Spring 方面"></a>5.10.2. AspectJ 的其他 Spring 方面</h4><p>除了<code>@Configurable</code> aspect 之外，<code>spring-aspects.jar</code>还包含一个 AspectJ aspect，您可以使用它来驱动 Spring 的 transaction management 用于使用<code>@Transactional</code> annotation 注释的类型和方法。这主要适用于想要在 Spring 容器之外使用 Spring Framework 的 transaction 支持的用户。</p>
<p>解释<code>@Transactional</code> annotations 的 aspect 是<code>AnnotationTransactionAspect</code>。使用此 aspect 时，必须注释 implementation class(或 class 中的方法或两者)，而不是 class 实现的接口(如果有)。 AspectJ 遵循 Java 的规则，即接口上的注释不会被继承。</p>
<p>class 上的<code>@Transactional</code> annotation 指定了 class 中执行任何公共操作的默认 transaction 语义。</p>
<p>class 中的方法上的<code>@Transactional</code> annotation 覆盖 class annotation(如果存在)给出的默认 transaction 语义。可以注释任何可见性的方法，包括私有方法。直接注释 non-public 方法是获得 transaction 划分以执行此类方法的唯一方法。</p>
<blockquote>
<p>从 Spring Framework 4.2 开始，<code>spring-aspects</code>提供了一个类似的 aspect，为标准<code>javax.transaction.Transactional</code> annotation 提供了完全相同的 features。检查<code>JtaAnnotationTransactionAspect</code>以获取更多详细信息。</p>
</blockquote>
<p>对于想要使用 Spring configuration 和 transaction management 支持但不想(或不能)使用 annotations 的 AspectJ 程序员，<code>spring-aspects.jar</code>还包含<code>abstract</code>方面，您可以扩展以提供自己的切入点定义。有关更多信息，请参阅<code>AbstractBeanConfigurerAspect</code>和<code>AbstractTransactionAspect</code>方面的来源。作为示例，以下摘录显示了如何编写 aspect 来配置域 model 中定义的 objects 的所有实例，方法是使用 match 完全限定的 class 名称的原型 bean 定义：</p>
<pre><code>public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect &#123;

    public DomainObjectConfiguration() &#123;
        setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());
    &#125;

    // the creation of a new bean (any object in the domain model)
    protected pointcut beanCreation(Object beanInstance) :
        initialization(new(..)) &amp;&amp;
        SystemArchitecture.inDomainModel() &amp;&amp;
        this(beanInstance);

&#125;
</code></pre>
<h4 id="5-10-3-使用-Spring-IoC-配置-AspectJ-方面"><a href="#5-10-3-使用-Spring-IoC-配置-AspectJ-方面" class="headerlink" title="5.10.3. 使用 Spring IoC 配置 AspectJ 方面"></a>5.10.3. 使用 Spring IoC 配置 AspectJ 方面</h4><p>当您使用带有 Spring applications 的 AspectJ 方面时，很自然地希望并期望能够使用 Spring 配置这些方面。 AspectJ 运行时本身负责 aspect 创建，通过 Spring 配置 AspectJ-created 方面的方法取决于 aspect 使用的 AspectJ 实例化 model(<code>per-xxx</code>子句)。</p>
<p>AspectJ 的大多数方面都是 singleton 方面。 这些方面的配置很容易。您可以创建一个 bean 定义，它将_sepect 类型作为常规引用，并包含<code>factory-method=&quot;aspectOf&quot;</code> bean 属性。这可以确保 Spring 通过询问 AspectJ 来获取 aspect 实例，而不是尝试自己创建实例。以下 example 显示了如何使用<code>factory-method=&quot;aspectOf&quot;</code>属性：</p>
<pre><code>&lt;bean id=&quot;profiler&quot; class=&quot;com.xyz.profiler.Profiler&quot;
        factory-method=&quot;aspectOf&quot;&gt; (1)

    &lt;property name=&quot;profilingStrategy&quot; ref=&quot;jamonProfilingStrategy&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>注意<code>factory-method=&quot;aspectOf&quot;</code>属性</td>
</tr>
</tbody></table>
<p>Non-singleton 方面更难配置。但是，可以通过 creating 原型 bean 定义并使用<code>spring-aspects.jar</code>的<code>@Configurable</code>支持来配置 aspect 实例，一旦它们具有 AspectJ 运行时创建的 bean，就可以这样做。</p>
<p>如果你想要使用 AspectJ 编织个方面(例如，使用 load-time 编织域 model 类型)和其他想要与 Spring AOP 一起使用的 @AspectJ 方面，并且这些方面都在 Spring 中配置，你需要告诉 Spring AOP @AspectJ auto-proxying 支持_配置中定义的 @AspectJ 方面的哪个确切子集应该用于 auto-proxying。您可以通过在<code>&lt;aop:aspectj-autoproxy/&gt;</code>声明中使用一个或多个<code>&lt;include/&gt;</code>元素来完成此操作。每个<code>&lt;include/&gt;</code>元素指定一个 name pattern，只有名称与至少一个模式匹配的 beans 用于 Spring AOP auto-proxy configuration。以下 example 显示了如何使用<code>&lt;include/&gt;</code>元素：</p>
<pre><code>&lt;aop:aspectj-autoproxy&gt;
    &lt;aop:include name=&quot;thisBean&quot;/&gt;
    &lt;aop:include name=&quot;thatBean&quot;/&gt;
&lt;/aop:aspectj-autoproxy&gt;
</code></pre>
<blockquote>
<p>不要被<code>&lt;aop:aspectj-autoproxy/&gt;</code>元素的 name 误导。使用它会导致创建 Spring AOP 代理。这里使用 @AspectJ 样式的 aspect 声明，但不涉及 AspectJ 运行时。</p>
</blockquote>
<h4 id="5-10-4-Load-time-在-Spring-Framework-中使用-AspectJ-进行编织"><a href="#5-10-4-Load-time-在-Spring-Framework-中使用-AspectJ-进行编织" class="headerlink" title="5.10.4. Load-time 在 Spring Framework 中使用 AspectJ 进行编织"></a>5.10.4. Load-time 在 Spring Framework 中使用 AspectJ 进行编织</h4><p>Load-time weaving(LTW)是指在将 AspectJ 方面加载到 Java 虚拟机(JVM)中时将其编织到 application 的 class files 中的过程。本节的重点是在 Spring Framework 的特定 context 中配置和使用 LTW。本节不是 LTW 的一般介绍。有关 LTW 细节的详细信息以及仅使用 AspectJ 配置 LTW(完全不涉及 Spring)，请参阅<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">AspectJ 开发环境指南的 LTW 部分</a>。</p>
<p>Spring Framework 为 AspectJ LTW 带来的 value 在编织 process 上实现了很多 finer-grained 控制。 ‘Vanilla’AspectJ LTW 通过使用 Java(5)代理来实现，该代理通过在启动 JVM 时指定 VM 参数来启用。因此，它是一个 JVM-wide 设置，在某些情况下可能会很好，但通常有点过于粗糙。 Spring-enabled LTW 允许您以__ 1 为基础打开 LTW，这更多 fine-grained 并且在’single-JVM-multiple-application’环境中更有意义(例如在典型的 application 服务器环境中找到的)。</p>
<p>此外，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas-context">在某些环境中</a>，此支持允许 load-time 编织而不对 application 服务器的启动脚本进行任何修改，这需要添加<code>-javaagent:path/to/aspectjweaver.jar</code>或(如本节后面所述)<code>-javaagent:path/to/org.springframework.instrument-&#123;version&#125;.jar</code>(以前称为<code>spring-agent.jar</code>)。开发人员修改一个或多个构成 application context 的 files 以启用 load-time 编织，而不是依赖于通常负责部署 configuration 的管理员，例如启动脚本。</p>
<p>现在销售宣传已经结束，让我们首先介绍使用 Spring 的 AspectJ LTW 的快速示例，然后详细介绍 example 中引入的元素。有关完整的 example，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-petclinic">Petclinic sample application</a>。</p>
<h5 id="A-First-Example"><a href="#A-First-Example" class="headerlink" title="A First Example"></a>A First Example</h5><p>假设您是一名 application 开发人员，他的任务是诊断系统中某些 performance 问题的原因。我们将开启一个简单的分析 aspect，而不是 break 出分析工具，让我们快速获得一些 performance metrics。然后，我们可以立即将 finer-grained 分析工具应用于该特定区域。</p>
<blockquote>
<p>此处提供的 example 使用 XML configuration。您还可以使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-environments">Java configuration</a>配置和使用 @AspectJ 。具体来说，您可以使用<code>@EnableLoadTimeWeaving</code> annotation 作为<code>&lt;context:load-time-weaver/&gt;</code>的替代方法(有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java">下面</a>)。</p>
</blockquote>
<p>以下 example 显示了分析 aspect，它不是花哨的 - 它是一个使用@AspectJ-style aspect 声明的 time-based 分析器：</p>
<pre><code>package foo;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.util.StopWatch;
import org.springframework.core.annotation.Order;

@Aspect
public class ProfilingAspect &#123;

    @Around(&quot;methodsToBeProfiled()&quot;)
    public Object profile(ProceedingJoinPoint pjp) throws Throwable &#123;
        StopWatch sw = new StopWatch(getClass().getSimpleName());
        try &#123;
            sw.start(pjp.getSignature().getName());
            return pjp.proceed();
        &#125; finally &#123;
            sw.stop();
            System.out.println(sw.prettyPrint());
        &#125;
    &#125;

    @Pointcut(&quot;execution(public * foo..*.*(..))&quot;)
    public void methodsToBeProfiled()&#123;&#125;
&#125;
</code></pre>
<p>我们还需要创建一个<code>META-INF/aop.xml</code>文件，以通知 AspectJ weaver 我们想要将<code>ProfilingAspect</code>编织到我们的 classes 中。此文件约定，即 Java classpath 上名为<code>META-INF/aop.xml</code>的文件(或 files)的存在是标准 AspectJ。以下 example 显示了<code>aop.xml</code>文件：</p>
<pre><code>&lt;!DOCTYPE aspectj PUBLIC &quot;-//AspectJ//DTD//EN&quot; &quot;http://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;&gt;
&lt;aspectj&gt;

    &lt;weaver&gt;
        &lt;!-- only weave classes in our application-specific packages --&gt;
        &lt;include within=&quot;foo.*&quot;/&gt;
    &lt;/weaver&gt;

    &lt;aspects&gt;
        &lt;!-- weave in just this aspect --&gt;
        &lt;aspect name=&quot;foo.ProfilingAspect&quot;/&gt;
    &lt;/aspects&gt;

&lt;/aspectj&gt;
</code></pre>
<p>现在我们可以继续 configuration 的 Spring-specific 部分。我们需要配置<code>LoadTimeWeaver</code>(稍后解释)。这个 load-time weaver 是必不可少的 component，负责将一个或多个<code>META-INF/aop.xml</code> files 中的 aspect configuration 编织到 application 中的 classes 中。好处是它不需要很多 configuration(你可以指定更多的选项，但稍后会详细介绍)，如下面的示例所示：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- a service object; we will be profiling its methods --&gt;
    &lt;bean id=&quot;entitlementCalculationService&quot;
            class=&quot;foo.StubEntitlementCalculationService&quot;/&gt;

    &lt;!-- this switches on the load-time weaving --&gt;
    &lt;context:load-time-weaver/&gt;
&lt;/beans&gt;
</code></pre>
<p>现在所有必需的 artifacts(aspect，<code>META-INF/aop.xml</code>文件和 Spring configuration)都已到位，我们可以使用<code>main(..)</code>方法创建以下驱动程序 class 来演示 LTW 的运行情况：</p>
<pre><code>package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main &#123;

    public static void main(String[] args) &#123;

        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;, Main.class);

        EntitlementCalculationService entitlementCalculationService
            = (EntitlementCalculationService) ctx.getBean(&quot;entitlementCalculationService&quot;);

        // the profiling aspect is &#39;woven&#39; around this method execution
        entitlementCalculationService.calculateEntitlement();
    &#125;
&#125;
</code></pre>
<p>我们还有最后一件事要做。本节的介绍确实说可以用 Spring 选择性地在_<code>ClassLoader</code>基础上打开 LTW，这是 true。但是，对于这个例子，我们使用 Java 代理(随 Spring 提供)来打开 LTW。我们使用以下命令来运行前面显示的<code>Main</code> class：</p>
<pre><code>java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main
</code></pre>
<p><code>-javaagent</code>是用于指定和启用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">代理程序来检测在 JVM 上运行的程序</a>的 flag。 Spring Framework 附带了一个代理<code>InstrumentationSavingAgent</code>，它包装在<code>spring-instrument.jar</code>中，作为前面 example 中<code>-javaagent</code>参数的 value 提供。</p>
<p>执行<code>Main</code>程序的输出看起来像下一个 example。 (我在<code>calculateEntitlement()</code> implementation 中引入了<code>Thread.sleep(..)</code>语句，以便探查器实际捕获 0 毫秒以外的东西(<code>01234</code>毫秒不是 AOP 引入的开销)。下面的清单显示了运行探查器时得到的输出：</p>
<pre><code>Calculating entitlement

StopWatch &#39;ProfilingAspect&#39;: running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement
</code></pre>
<p>由于这个 LTW 是通过使用 full-blown AspectJ 实现的，因此我们不仅限于建议 Spring beans。 <code>Main</code>程序的以下细微变化产生相同的结果：</p>
<pre><code>package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main &#123;

    public static void main(String[] args) &#123;

        new ClassPathXmlApplicationContext(&quot;beans.xml&quot;, Main.class);

        EntitlementCalculationService entitlementCalculationService =
            new StubEntitlementCalculationService();

        // the profiling aspect will be &#39;woven&#39; around this method execution
        entitlementCalculationService.calculateEntitlement();
    &#125;
&#125;
</code></pre>
<p>请注意，在前面的程序中，我们如何引导 Spring 容器，然后在 Spring 的 context 之外创建<code>StubEntitlementCalculationService</code>的新实例。剖析建议仍在编织中。</p>
<p>不可否认，示例过于简单化。但是，Spring 中 LTW 支持的基础知识都已在前面的示例中引入，本节的内容详细解释了 configuration 和用法的每一位背后的“原因”。</p>
<blockquote>
<p>此 example 中使用的<code>ProfilingAspect</code>可能是基本的，但它非常有用。它是开发人员在开发过程中可以使用的 development-time aspect 的一个很好的例子，然后很容易从部署到 UAT 或 production 的 application 的构建中排除。</p>
</blockquote>
<h5 id="方面"><a href="#方面" class="headerlink" title="方面"></a>方面</h5><p>您在 LTW 中使用的方面必须是 AspectJ 方面。您可以使用 AspectJ 语言本身编写它们，也可以在@AspectJ-style 中编写方面。那么你的方面都是有效的 AspectJ 和 Spring AOP 方面。此外，编译的 aspect classes 需要在 classpath 上可用。</p>
<h5 id="‘META-INF-aop-xml’"><a href="#‘META-INF-aop-xml’" class="headerlink" title="‘META-INF/aop.xml’"></a>‘META-INF/aop.xml’</h5><p>AspectJ LTW 基础结构是使用 Java classpath 上的一个或多个<code>META-INF/aop.xml</code> files 配置的(直接或更常见地，在 jar files 中)。</p>
<p>LTW 部分<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">AspectJ reference 文档</a>详细介绍了该文件的结构和内容。因为 aop.xml 文件是 100％AspectJ，所以我们在此不再进一步描述。</p>
<h5 id="必需-libraries-JARS"><a href="#必需-libraries-JARS" class="headerlink" title="必需 libraries(JARS)"></a>必需 libraries(JARS)</h5><p>至少，您需要以下 libraries 来使用 Spring Framework 对 AspectJ LTW 的支持：</p>
<ul>
<li><code>spring-aop.jar</code>(version 2.5 或更高版本，加上所有必需的依赖项)</li>
<li><code>aspectjweaver.jar</code>(version 1.6.8 或更高版本)</li>
</ul>
<p>如果您使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-spring">Spring-provided 代理启用检测</a>，您还需要：</p>
<ul>
<li><code>spring-instrument.jar</code></li>
</ul>
<h5 id="Spring-Configuration"><a href="#Spring-Configuration" class="headerlink" title="Spring Configuration"></a>Spring Configuration</h5><p>Spring 的 LTW 支持中的 key component 是<code>LoadTimeWeaver</code>接口(在<code>org.springframework.instrument.classloading</code>包中)，以及与 Spring 发行版一起提供的众多 implementations。 <code>LoadTimeWeaver</code>负责在运行时向<code>ClassLoader</code>添加一个或多个<code>java.lang.instrument.ClassFileTransformers</code>，这为各种有趣的 applications 打开了大门，其中一个恰好是方面的 LTW。</p>
<blockquote>
<p>如果您不熟悉运行时 class 文件转换的 idea，请在继续之前查看<code>java.lang.instrument</code>包的 javadoc API 文档。虽然该文档并不全面，但至少可以看到 key 接口和 classes(在阅读本节时为 reference)。</p>
</blockquote>
<p>为特定的<code>ApplicationContext</code>配置<code>LoadTimeWeaver</code>可以像添加一个 line 一样简单。 (请注意，您几乎肯定需要使用<code>ApplicationContext</code>作为 Spring 容器 - 通常，<code>BeanFactory</code>是不够的，因为 LTW 支持使用<code>BeanFactoryPostProcessors</code> .)</p>
<p>要启用 Spring Framework 的 LTW 支持，您需要配置<code>LoadTimeWeaver</code>，通常使用<code>@EnableLoadTimeWeaving</code> annotation 来完成，如下所示：</p>
<pre><code>@Configuration
@EnableLoadTimeWeaving
public class AppConfig &#123;

&#125;
</code></pre>
<p>或者，如果您更喜欢 XML-based configuration，请使用<code>&lt;context:load-time-weaver/&gt;</code>元素。请注意，该元素在<code>context</code>名称空间中定义。以下 example 显示了如何使用<code>&lt;context:load-time-weaver/&gt;</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:load-time-weaver/&gt;

&lt;/beans&gt;
</code></pre>
<p>前面的 configuration 会自动为您定义和注册许多 LTW-specific infrastructure beans，例如<code>LoadTimeWeaver</code>和<code>AspectJWeavingEnabler</code>。默认的<code>LoadTimeWeaver</code>是<code>DefaultContextLoadTimeWeaver</code> class，它试图装饰自动检测到的<code>LoadTimeWeaver</code>。 “自动检测”的确切类型<code>LoadTimeWeaver</code>取决于您的运行时环境。以下 table 总结了各种<code>LoadTimeWeaver</code> __mplement：</p>
<table>
<thead>
<tr>
<th>运行环境</th>
<th><code>LoadTimeWeaver</code> 实现</th>
</tr>
</thead>
<tbody><tr>
<td>在 Oracle 的<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html">WebLogic</a>中运行</td>
<td><code>WebLogicLoadTimeWeaver</code></td>
</tr>
<tr>
<td>在 Oracle 的<a target="_blank" rel="noopener" href="http://glassfish.dev.java.net/">GlassFish</a>中运行</td>
<td><code>GlassFishLoadTimeWeaver</code></td>
</tr>
<tr>
<td>在<a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Apache Tomcat</a>运行</td>
<td><code>TomcatLoadTimeWeaver</code></td>
</tr>
<tr>
<td>Running in Red Hat 的<a target="_blank" rel="noopener" href="http://www.jboss.org/jbossas/">JBoss AS</a>或<a target="_blank" rel="noopener" href="http://www.wildfly.org/">WildFly</a></td>
<td><code>JBossLoadTimeWeaver</code></td>
</tr>
<tr>
<td>在 IBM 的<a target="_blank" rel="noopener" href="https://www-01.ibm.com/software/webservers/appserv/was/">WebSphere</a>运行</td>
<td><code>WebSphereLoadTimeWeaver</code></td>
</tr>
<tr>
<td>JVM 以 Spring <code>InstrumentationSavingAgent</code>(<code>java -javaagent:path/to/spring-instrument.jar</code>)开头</td>
<td><code>InstrumentationLoadTimeWeaver</code></td>
</tr>
<tr>
<td>回退，期望底层的 ClassLoader 遵循 common 约定(对于适用于<code>TomcatInstrumentableClassLoader</code>和<a target="_blank" rel="noopener" href="http://www.caucho.com/">树脂</a>的 example)</td>
<td><code>ReflectiveLoadTimeWeaver</code></td>
</tr>
</tbody></table>
<p>请注意，table lists 仅列出使用<code>DefaultContextLoadTimeWeaver</code>时自动检测的<code>LoadTimeWeavers</code>。您可以准确指定要使用的<code>LoadTimeWeaver</code> implementation。</p>
<p>要使用 Java configuration 指定特定的<code>LoadTimeWeaver</code>，请实现<code>LoadTimeWeavingConfigurer</code>接口并覆盖<code>getLoadTimeWeaver()</code>方法。以下 example 指定<code>ReflectiveLoadTimeWeaver</code>：</p>
<pre><code>@Configuration
@EnableLoadTimeWeaving
public class AppConfig implements LoadTimeWeavingConfigurer &#123;

    @Override
    public LoadTimeWeaver getLoadTimeWeaver() &#123;
        return new ReflectiveLoadTimeWeaver();
    &#125;
&#125;
</code></pre>
<p>如果使用 XML-based configuration，则可以将完全限定的类名指定为<code>&lt;context:load-time-weaver/&gt;</code>元素上<code>weaver-class</code>属性的 value。同样，以下 example 指定<code>ReflectiveLoadTimeWeaver</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:load-time-weaver
            weaver-class=&quot;org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>由 configuration 定义和注册的<code>LoadTimeWeaver</code>可以稍后使用众所周知的 name，<code>loadTimeWeaver</code>从 Spring 容器中检索。请记住，<code>LoadTimeWeaver</code>仅作为 Spring 的 LTW 基础设施添加一个或多个<code>ClassFileTransformers</code>的机制存在。执行 LTW 的实际<code>ClassFileTransformer</code>是<code>ClassPreProcessorAgentAdapter</code>(来自<code>org.aspectj.weaver.loadtime</code>包)class。有关详细信息，请参阅<code>ClassPreProcessorAgentAdapter</code> class 的 class-level javadoc，因为编织实际如何实现的细节超出了本文档的范围。</p>
<p>还有一个 configuration 的最后一个属性要讨论：<code>aspectjWeaving</code>属性(如果使用 XML，则为<code>aspectj-weaving</code>)。此属性控制是否启用 LTW。它接受三个可能值中的一个，如果该属性不存在，则默认 value 为<code>autodetect</code>。以下 table 总结了三个可能的值：</p>
<table>
<thead>
<tr>
<th>Annotation Value</th>
<th>XML Value</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ENABLED</code></td>
<td><code>on</code></td>
<td>AspectJ 编织打开，方面在 load-time 处编织。</td>
</tr>
<tr>
<td><code>DISABLED</code></td>
<td><code>off</code></td>
<td>LTW 已关闭。没有 aspect 编织在 load-time。</td>
</tr>
<tr>
<td><code>AUTODETECT</code></td>
<td><code>autodetect</code></td>
<td>如果 Spring LTW 基础结构可以找到至少一个<code>META-INF/aop.xml</code>文件，则 AspectJ 编织开启。否则，它关闭。这是默认值。</td>
</tr>
</tbody></table>
<h5 id="Environment-specific-Configuration"><a href="#Environment-specific-Configuration" class="headerlink" title="Environment-specific Configuration"></a>Environment-specific Configuration</h5><p>最后一节包含在 application 服务器和 web 容器等环境中使用 Spring 的 LTW 支持时所需的任何其他设置和 configuration。</p>
<h6 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h6><p>从历史上看，<a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Apache Tomcat</a>的默认 class 加载器不支持 class 转换，这就是 Spring 提供满足此需求的增强 implementation 的原因。命名为<code>TomcatInstrumentableClassLoader</code>，加载程序在 Tomcat 6.0 及以上版本上运行。</p>
<blockquote>
<p>不要在 Tomcat 8.0 及更高版本上定义<code>TomcatInstrumentableClassLoader</code>。相反，让 Spring 通过<code>TomcatLoadTimeWeaver</code>策略自动使用 Tomcat 的新原生<code>InstrumentableClassLoader</code>工具。</p>
</blockquote>
<p>如果仍需要使用<code>TomcatInstrumentableClassLoader</code>，则可以为每个 web application 单独注册，如下所示：</p>
<ul>
<li>将<code>org.springframework.instrument.tomcat.jar</code>复制到<code>$CATALINA_HOME/lib</code>，其中<code>$CATALINA_HOME</code>表示 Tomcat 安装的根目录</li>
<li>通过编辑 web application context 文件指示 Tomcat 使用自定义 class 加载程序(而不是默认值)，如下面的 example 所示：</li>
</ul>
<pre><code>&lt;Context path=&quot;/myWebApp&quot; docBase=&quot;/my/webApp/location&quot;&gt;
    &lt;Loader
        loaderClass=&quot;org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader&quot;/&gt;
&lt;/Context&gt;
</code></pre>
<p>Apache Tomcat 6.0 支持多个 context 位置：</p>
<ul>
<li>服务器配置文件：<code>$CATALINA_HOME/conf/server.xml</code></li>
<li>默认 context configuration：<code>$CATALINA_HOME/conf/context.xml</code>，它影响所有已部署的 web applications</li>
<li>per-web application configuration，可以部署在 server-side <code>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</code>上，也可以嵌入 web-app 归档内部<code>META-INF/context.xml</code></li>
</ul>
<p>为了提高效率，我们建议使用嵌入式 per-web application configuration 样式，因为它只影响使用自定义 class 加载器的 applications，并且不需要对服务器 configuration 进行任何更改。有关可用 context 位置的更多详细信息，请参阅 Tomcat 6.0.x <a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-6.0-doc/config/context.html">文件</a>。</p>
<p>或者，考虑使用 Spring-provided 泛型 VM 代理，在 Tomcat 的启动脚本中指定(在本节前面介绍过)。这使得所有已部署的 web applications 都可以使用检测，无论它们发生在上。</p>
<h6 id="WebLogic，WebSphere，Resin，GlassFish-和-JBoss"><a href="#WebLogic，WebSphere，Resin，GlassFish-和-JBoss" class="headerlink" title="WebLogic，WebSphere，Resin，GlassFish 和 JBoss"></a>WebLogic，WebSphere，Resin，GlassFish 和 JBoss</h6><p>最新版本的 WebLogic Server(version 10 及更高版本)，IBM WebSphere Application Server(version 7 及更高版本)，Resin(version 3.1 及更高版本)和 JBoss(version 6.x 或更高版本)提供了能够进行本地检测的<code>ClassLoader</code>。 Spring 的原生 LTW 利用此类 ClassLoader implementations 来启用 AspectJ 编织。您可以通过激活 load-time 编织来启用 LTW，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-environment-generic">如前所述</a>。具体来说，您无需修改启动脚本即可添加<code>-javaagent:path/to/spring-instrument.jar</code>。</p>
<p>请注意，GlassFish instrumentation-capable <code>ClassLoader</code>仅在其 EAR 环境中可用。对于 GlassFish web applications，请按照 Tomcat 设置说明<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-using-aspectj">前面概述过</a>进行操作。</p>
<p>请注意，在 JBoss 6.x 上，您需要禁用应用服务器扫描以防止它在 application 实际启动之前 classes classes。一个快速的解决方法是使用以下内容向 artifact 添加名为<code>WEB-INF/jboss-scanning.xml</code>的文件：</p>
<pre><code>&lt;scanning xmlns=&quot;urn:jboss:scanning:1.0&quot;/&gt;
</code></pre>
<h6 id="Generic-Java-Applications"><a href="#Generic-Java-Applications" class="headerlink" title="Generic Java Applications"></a>Generic Java Applications</h6><p>如果在不支持或不支持现有<code>LoadTimeWeaver</code> implementations 的环境中需要 class 检测，则 JDK 代理可以是唯一的解决方案。对于这种情况，Spring 提供<code>InstrumentationLoadTimeWeaver</code>，这需要一个 Spring-specific(但非常一般)VM 代理，<code>org.springframework.instrument-&#123;version&#125;.jar</code>(以前称为<code>spring-agent.jar</code>)。</p>
<p>要使用它，必须通过提供以下 JVM 选项来启动具有 Spring 代理的虚拟机：</p>
<pre><code>-javaagent:/path/to/org.springframework.instrument-&#123;version&#125;.jar
</code></pre>
<p>请注意，这需要修改 VM 启动脚本，这可能会阻止您在 application Server 环境中使用它(取决于您的操作 policies)。此外，JDK 代理可以检测整个 VM，这可能很昂贵。</p>
<p>出于性能原因，我们建议您仅在目标环境(例如<a target="_blank" rel="noopener" href="https://www.eclipse.org/jetty/">码头</a>)没有(或不支持)专用 LTW 时才使用此 configuration。</p>
<h3 id="5-11-更多资源"><a href="#5-11-更多资源" class="headerlink" title="5.11. 更多资源"></a>5.11. 更多资源</h3><p>有关 AspectJ 的更多信息可以在<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj">AspectJ 网站</a>上找到。</p>
<p>Eclipse AspectJ 由 Adrian Colyer 等人。人。 (Addison-Wesley，2005)为 AspectJ 语言提供了全面的介绍和参考。</p>
<p>AspectJ in Action，第二版由 Ramnivas Laddad(Manning，2009)强烈推荐。本书的重点是 AspectJ，但是很多一般的 AOP 主题都在探索中(在某种程度上)。</p>
<h2 id="6-Spring-AOP-API"><a href="#6-Spring-AOP-API" class="headerlink" title="6. Spring AOP API"></a>6. Spring AOP API</h2><p>前一章描述了 Spring 对 AOP 的支持，包括 @AspectJ 和 schema-based aspect 定义。在本章中，我们将讨论 lower-level Spring AOP API 以及 Spring 1.2 applications 中通常使用的 AOP 支持。对于新的 applications，我们建议使用前一章中描述的 Spring 2.0 和更高版本的 AOP 支持。但是，当您使用现有的 applications 时(或者当您阅读书籍和文章时)，您可能会遇到 Spring 1.2-style 示例。 Spring 5 保持向后兼容 Spring 1.2，Spring 5 完全支持本章中描述的所有内容。</p>
<h3 id="6-1-Spring-中的切入点-API"><a href="#6-1-Spring-中的切入点-API" class="headerlink" title="6.1. Spring 中的切入点 API"></a>6.1. Spring 中的切入点 API</h3><p>本节描述 Spring 如何处理关键切入点概念。</p>
<h4 id="6-1-1-概念"><a href="#6-1-1-概念" class="headerlink" title="6.1.1. 概念"></a>6.1.1. 概念</h4><p>Spring 的切入点 model 可以独立于通知类型启用切入点重用。您可以使用相同的切入点来定位不同的建议。</p>
<p><code>org.springframework.aop.Pointcut</code>接口是中央接口，用于将建议定位到特定的 classes 和方法。完整的界面如下：</p>
<pre><code>public interface Pointcut &#123;

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

&#125;
</code></pre>
<p>将<code>Pointcut</code>接口拆分为两部分允许重用 class 和方法匹配部分以及 fine-grained 组合操作(例如使用另一个方法匹配器执行“union”)。</p>
<p><code>ClassFilter</code>接口用于将切入点限制为给定的一组目标 classes。如果<code>matches()</code>方法始终返回 true，则匹配所有目标 classes。以下清单显示了<code>ClassFilter</code>接口定义：</p>
<pre><code>public interface ClassFilter &#123;

    boolean matches(Class clazz);
&#125;
</code></pre>
<p><code>MethodMatcher</code>接口通常更重要。完整的界面如下：</p>
<pre><code>public interface MethodMatcher &#123;

    boolean matches(Method m, Class targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class targetClass, Object[] args);
&#125;
</code></pre>
<p><code>matches(Method, Class)</code>方法用于测试此切入点是否与目标 class 上的给定方法匹配。创建 AOP 代理时可以执行此 evaluation，以避免在每次方法调用时都需要测试。如果 two-argument <code>matches</code>方法为给定方法返回<code>true</code>，并且 MethodMatcher 的<code>isRuntime()</code>方法返回<code>true</code>，则在每次方法调用时都会调用 three-argument matches 方法。这使得切入点可以在执行目标通知之前立即查看传递给方法调用的 arguments。</p>
<p>大多数<code>MethodMatcher</code> __mplement 都是静态的，这意味着它们的<code>isRuntime()</code>方法返回<code>false</code>。在这种情况下，永远不会调用 three-argument <code>matches</code>方法。</p>
<blockquote>
<p>如果可能，尝试使切入点成为静态，允许 AOP framework 在创建 AOP 代理时缓存切入点 evaluation 的结果。</p>
</blockquote>
<h4 id="6-1-2-切入点的操作"><a href="#6-1-2-切入点的操作" class="headerlink" title="6.1.2. 切入点的操作"></a>6.1.2. 切入点的操作</h4><p>Spring 支持切入点上的操作(尤其是 union 和 intersection)。</p>
<p>Union 表示切入点匹配的方法。交叉意味着两个切入点 match 的方法。 Union 通常更有用。您可以使用<code>org.springframework.aop.support.Pointcuts</code> class 中的静态方法或在同一个包中使用<code>ComposablePointcut</code> class 来组合切入点。但是，使用 AspectJ 切入点表达式通常是一种更简单的方法。</p>
<h4 id="6-1-3-AspectJ-表达式切入点"><a href="#6-1-3-AspectJ-表达式切入点" class="headerlink" title="6.1.3. AspectJ 表达式切入点"></a>6.1.3. AspectJ 表达式切入点</h4><p>从 2.0 开始，Spring 使用的最重要的切入点类型是<code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code>。这是一个切入点，它使用 AspectJ-supplied library 来解析 AspectJ 切入点表达式 string。</p>
<p>有关受支持的 AspectJ 切入点 primitives 的讨论，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-environment-tomcat">前一章</a>。</p>
<h4 id="6-1-4-Convenience-Pointcut-Implementations"><a href="#6-1-4-Convenience-Pointcut-Implementations" class="headerlink" title="6.1.4. Convenience Pointcut Implementations"></a>6.1.4. Convenience Pointcut Implementations</h4><p>Spring 提供了几个方便的切入点实现。您可以直接使用其中一些。其他人打算在 application-specific 切入点中进行子类化。</p>
<h5 id="静态切入点"><a href="#静态切入点" class="headerlink" title="静态切入点"></a>静态切入点</h5><p>静态切入点基于方法和目标 class，不能考虑方法的 arguments。对于大多数用途，静态切入点足够 - 并且最好。当首次调用方法时，Spring 只能评估一次静态切入点。之后，无需再次使用每个方法调用来评估切入点。</p>
<p>本节的 rest 描述了 Spring 中包含的一些静态切入点 implementations。</p>
<h6 id="正则表达式切入点"><a href="#正则表达式切入点" class="headerlink" title="正则表达式切入点"></a>正则表达式切入点</h6><p>指定静态切入点的一种显而易见的方法是正则表达式。除了 Spring 之外，几个 AOP 框架使这成为可能。 <code>org.springframework.aop.support.JdkRegexpMethodPointcut</code>是一个通用的正则表达式切入点，它使用 JDK 中的正则表达式支持。</p>
<p>使用<code>JdkRegexpMethodPointcut</code> class，您可以提供 pattern strings 的列表。如果其中任何一个是 match，则切入点的计算结果为<code>true</code>。 (所以，结果实际上是 pointcuts.)的 union</p>
<p>以下 example 显示了如何使用<code>JdkRegexpMethodPointcut</code>：</p>
<pre><code>&lt;bean id=&quot;settersAndAbsquatulatePointcut&quot;
        class=&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot;&gt;
    &lt;property name=&quot;patterns&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>Spring 提供了一个名为<code>RegexpMethodPointcutAdvisor</code>的便捷 class，它允许我们 reference <code>Advice</code>(记住<code>Advice</code>可以是一个拦截器，在建议之前，抛出建议等)。在幕后，Spring 使用<code>JdkRegexpMethodPointcut</code>。使用<code>RegexpMethodPointcutAdvisor</code>简化了布线，因为_ bean 封装了切入点和建议，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;settersAndAbsquatulateAdvisor&quot;
        class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&gt;
    &lt;property name=&quot;advice&quot;&gt;
        &lt;ref bean=&quot;beanNameOfAopAllianceInterceptor&quot;/&gt;
    &lt;/property&gt;
    &lt;property name=&quot;patterns&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>您可以将<code>RegexpMethodPointcutAdvisor</code>与任何<code>Advice</code>类型一起使用。</p>
<h6 id="Attribute-driven-切入点"><a href="#Attribute-driven-切入点" class="headerlink" title="Attribute-driven 切入点"></a>Attribute-driven 切入点</h6><p>一种重要的静态切入点是 metadata-driven 切入点。这使用元数据属性的值(通常是 source-level 元数据)。</p>
<h5 id="动态切入点"><a href="#动态切入点" class="headerlink" title="动态切入点"></a>动态切入点</h5><p>与静态切入点相比，动态切入点的评估成本更高。它们考虑了方法 arguments 以及静态信息。这意味着必须使用每个方法调用来评估它们，并且不能缓存结果，因为 arguments 会有所不同。</p>
<p>主要示例是<code>control flow</code>切入点。</p>
<h6 id="控制流切入点"><a href="#控制流切入点" class="headerlink" title="控制流切入点"></a>控制流切入点</h6><p>Spring 控制流切入点在概念上类似于 AspectJ <code>cflow</code>切入点，虽然功能较弱。 (目前无法指定切入点在另一个 pointcut.)匹配的连接点下执行。控制流切入点与当前调用堆栈匹配。对于 example，如果连接点是由<code>com.mycompany.web</code>包中的方法调用的，则可能会触发。通过<code>SomeCaller</code> class。使用<code>org.springframework.aop.support.ControlFlowPointcut</code> class 指定控制流切入点。</p>
<blockquote>
<p>在运行时评估控制流切入点的成本远远高于其他动态切入点。在 Java 1.4 中，成本大约是其他动态切入点的五倍。</p>
</blockquote>
<h4 id="6-1-5-切入点超级课程"><a href="#6-1-5-切入点超级课程" class="headerlink" title="6.1.5. 切入点超级课程"></a>6.1.5. 切入点超级课程</h4><p>Spring 提供了有用的切入点超类来帮助您实现自己的切入点。</p>
<p>因为静态切入点最有用，所以您应该将<code>StaticMethodMatcherPointcut</code>子类化。这需要只实现一个抽象方法(尽管您可以覆盖其他方法来自定义行为)。以下 example 显示了如何子类化<code>StaticMethodMatcherPointcut</code>：</p>
<pre><code>class TestStaticPointcut extends StaticMethodMatcherPointcut &#123;

    public boolean matches(Method m, Class targetClass) &#123;
        // return true if custom criteria match
    &#125;
&#125;
</code></pre>
<p>还有动态切入点的超类。</p>
<p>您可以在 Spring 1.0 RC2 及更高版本中使用任何建议类型的自定义切入点。</p>
<h4 id="6-1-6-自定义切入点"><a href="#6-1-6-自定义切入点" class="headerlink" title="6.1.6. 自定义切入点"></a>6.1.6. 自定义切入点</h4><p>因为 Spring AOP 中的切入点是 Java classes 而不是语言 features(如在 AspectJ 中)，所以您可以声明自定义切入点，无论是静态还是动态。 Spring 中的自定义切入点可以是任意复杂的。但是，如果可以，我们建议使用 AspectJ 切入点表达式语言。</p>
<blockquote>
<p>更高版本的 Spring 可能会为 JAC 提供的“语义切入点”提供支持 - 例如，“所有改变目标 object 中实例变量的方法”。</p>
</blockquote>
<h3 id="6-2-Spring-中的建议-API"><a href="#6-2-Spring-中的建议-API" class="headerlink" title="6.2. Spring 中的建议 API"></a>6.2. Spring 中的建议 API</h3><p>现在我们可以检查 Spring AOP 如何处理建议。</p>
<h4 id="6-2-1-建议生命周期"><a href="#6-2-1-建议生命周期" class="headerlink" title="6.2.1. 建议生命周期"></a>6.2.1. 建议生命周期</h4><p>每个建议都是 Spring bean。建议实例可以在所有建议的 objects 之间共享，或者对每个建议的 object 都是唯一的。这对应于 per-class 或 per-instance 建议。</p>
<p>Per-class 建议最常用。它适用于通用建议，例如 transaction 顾问。这些不依赖于代理 object 的 state 或添加新的 state。它们仅仅依赖于方法和 arguments。</p>
<p>Per-instance 建议适合介绍，以支持 mixins。在这种情况下，建议将 state 添加到代理的 object。</p>
<p>您可以在同一个 AOP 代理中混合使用共享和 per-instance 建议。</p>
<h4 id="6-2-2-Spring-中的建议类型"><a href="#6-2-2-Spring-中的建议类型" class="headerlink" title="6.2.2. Spring 中的建议类型"></a>6.2.2. Spring 中的建议类型</h4><p>Spring 提供了几种建议类型，并且可以扩展以支持任意建议类型。本节介绍基本概念和标准建议类型。</p>
<h5 id="围绕建议拦截"><a href="#围绕建议拦截" class="headerlink" title="围绕建议拦截"></a>围绕建议拦截</h5><p>Spring 中最基本的建议类型是围绕建议进行拦截。</p>
<p>Spring 符合 AOP <code>Alliance</code>接口，用于使用方法拦截的周围建议。实现<code>MethodInterceptor</code>并实现建议的 Classes 也应该实现以下接口：</p>
<pre><code>public interface MethodInterceptor extends Interceptor &#123;

    Object invoke(MethodInvocation invocation) throws Throwable;
&#125;
</code></pre>
<p><code>invoke()</code>方法的<code>MethodInvocation</code>参数公开了被调用的方法，目标连接点，AOP 代理和方法的 arguments。 <code>invoke()</code>方法应该_return 调用的结果：连接点的 return value。</p>
<p>以下 example 显示了一个简单的<code>MethodInterceptor</code> implementation：</p>
<pre><code>public class DebugInterceptor implements MethodInterceptor &#123;

    public Object invoke(MethodInvocation invocation) throws Throwable &#123;
        System.out.println(&quot;Before: invocation=[&quot; + invocation + &quot;]&quot;);
        Object rval = invocation.proceed();
        System.out.println(&quot;Invocation returned&quot;);
        return rval;
    &#125;
&#125;
</code></pre>
<p>注意对<code>MethodInvocation</code>的<code>proceed()</code>方法的调用。这沿拦截器链向下进入连接点。大多数拦截器调用此方法并 return 其 return value。但是，<code>MethodInterceptor</code>，就像任何一个建议一样，可以 return 一个不同的 value 或抛出一个 exception 而不是调用 proceed 方法。但是，如果没有充分的理由，您不希望这样做。</p>
<blockquote>
<p><code>MethodInterceptor</code> implementations 提供与其他 AOP Alliance-compliant AOP implementations 的互操作性。本节其余部分讨论的其他建议类型实现了 common AOP 概念，但是以 Spring-specific 方式实现。虽然使用最具体的建议类型有一个优势，但如果您可能想要在另一个 AOP framework 中运行 aspect，请坚持使用<code>MethodInterceptor</code>。请注意，切入点目前在框架之间不可互操作，AOP 联盟目前不定义切入点接口。</p>
</blockquote>
<h5 id="在建议之前-2"><a href="#在建议之前-2" class="headerlink" title="在建议之前"></a>在建议之前</h5><p>更简单的建议类型是之前的建议。这不需要<code>MethodInvocation</code> object，因为只在进入方法之前调用它。</p>
<p>之前建议的主要优点是不需要调用<code>proceed()</code>方法，因此不会无意中无法继续拦截链。</p>
<p>以下清单显示了<code>MethodBeforeAdvice</code>接口：</p>
<pre><code>public interface MethodBeforeAdvice extends BeforeAdvice &#123;

    void before(Method m, Object[] args, Object target) throws Throwable;
&#125;
</code></pre>
<p>(Spring 的 API 设计允许在建议之前使用字段，尽管通常的 objects 适用于字段拦截，并且 Spring 不太可能实现 it.)</p>
<p>请注意 return 类型是<code>void</code>。在建议可以在连接点执行之前插入自定义行为但不能更改 return value。如果 before advice 抛出了 exception，则会中止拦截器链的进一步执行。 exception 传播回拦截器链。如果取消选中它或在被调用方法的签名上，它将直接传递给 client。否则，它被 AOP 代理包装在未经检查的 exception 中。</p>
<p>以下 example 显示 Spring 中的 before 建议，它计算所有方法调用：</p>
<pre><code>public class CountingBeforeAdvice implements MethodBeforeAdvice &#123;

    private int count;

    public void before(Method m, Object[] args, Object target) throws Throwable &#123;
        ++count;
    &#125;

    public int getCount() &#123;
        return count;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>之前建议可以与任何切入点一起使用。</p>
</blockquote>
<h5 id="引发建议"><a href="#引发建议" class="headerlink" title="引发建议"></a>引发建议</h5><p>如果连接点抛出 exception，则在连接点的 return 之后调用抛出建议。 Spring 提供类型投掷建议。请注意，这意味着<code>org.springframework.aop.ThrowsAdvice</code>接口不包含任何方法。它是一个标记接口，用于标识给定的 object 实现一个或多个类型化的 throws 建议方法。这些应该是以下形式：</p>
<pre><code>afterThrowing([Method, args, target], subclassOfThrowable)
</code></pre>
<p>只需要最后一个参数。方法签名可以有一个或四个 arguments，具体取决于 advice 方法是否对方法和 arguments 感兴趣。接下来的两个列表显示了作为 throws 建议示例的 classes。</p>
<p>如果抛出<code>RemoteException</code>(包括从子类)，则调用以下建议：</p>
<pre><code>public class RemoteThrowsAdvice implements ThrowsAdvice &#123;

    public void afterThrowing(RemoteException ex) throws Throwable &#123;
        // Do something with remote exception
    &#125;
&#125;
</code></pre>
<p>与前面的建议不同，下一个 example 声明了四个 arguments，因此它可以访问被调用的方法，方法 arguments 和 target object。如果抛出<code>ServletException</code>，则调用以下建议：</p>
<pre><code>public class ServletThrowsAdviceWithArguments implements ThrowsAdvice &#123;

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) &#123;
        // Do something with all arguments
    &#125;
&#125;
</code></pre>
<p>最后的 example 说明了如何在处理<code>RemoteException</code>和<code>ServletException</code>的单个 class 中使用这两个方法。可以在单个 class 中组合任意数量的 throws 建议方法。以下清单显示了最终的 example：</p>
<pre><code>public static class CombinedThrowsAdvice implements ThrowsAdvice &#123;

    public void afterThrowing(RemoteException ex) throws Throwable &#123;
        // Do something with remote exception
    &#125;

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) &#123;
        // Do something with all arguments
    &#125;
&#125;
</code></pre>
<blockquote>
<p>如果 throws-advice 方法本身抛出一个 exception，它会覆盖原始的 exception(也就是说，它会更改抛出给用户的 exception)。覆盖的 exception 通常是 RuntimeException，它与任何方法签名兼容。但是，如果 throws-advice 方法抛出已检查的 exception，则它必须_匹配目标方法的声明的 exceptions，因此在某种程度上耦合到特定的目标方法签名。不要抛出与目标方法的签名不兼容的未声明的已检查 exception！</p>
</blockquote>
<blockquote>
<p>抛出建议可以与任何切入点一起使用。</p>
</blockquote>
<h5 id="返回建议后-2"><a href="#返回建议后-2" class="headerlink" title="返回建议后"></a>返回建议后</h5><p>在 Spring 中返回后的建议必须实现<code>org.springframework.aop.AfterReturningAdvice</code>接口，如下所示：</p>
<pre><code>public interface AfterReturningAdvice extends Advice &#123;

    void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable;
&#125;
</code></pre>
<p>返回后的建议可以访问 return value(它无法修改)，调用的方法，方法的 arguments 和目标。</p>
<p>返回建议后的以下内容计算所有未抛出 exceptions 的成功方法调用：</p>
<pre><code>public class CountingAfterReturningAdvice implements AfterReturningAdvice &#123;

    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable &#123;
        ++count;
    &#125;

    public int getCount() &#123;
        return count;
    &#125;
&#125;
</code></pre>
<p>此建议不会更改执行路径。如果它抛出一个 exception，它会被拦截链而不是 return value 抛出。</p>
<blockquote>
<p>返回建议后可以使用任何切入点。</p>
</blockquote>
<h5 id="简介建议"><a href="#简介建议" class="headerlink" title="简介建议"></a>简介建议</h5><p>Spring 将介绍建议视为一种特殊的拦截建议。</p>
<p>简介需要<code>IntroductionAdvisor</code>和<code>IntroductionInterceptor</code>来实现以下接口：</p>
<pre><code>public interface IntroductionInterceptor extends MethodInterceptor &#123;

    boolean implementsInterface(Class intf);
&#125;
</code></pre>
<p>从 AOP Alliance <code>MethodInterceptor</code>接口继承的<code>invoke()</code>方法必须实现介绍。也就是说，如果调用的方法在引入的接口上，则引入拦截器负责处理方法调用 - 它不能调用<code>proceed()</code>。</p>
<p>引言建议不能与任何切入点一起使用，因为它仅适用于 class，而不是方法 level。您只能使用<code>IntroductionAdvisor</code>的介绍建议，它具有以下方法：</p>
<pre><code>public interface IntroductionAdvisor extends Advisor, IntroductionInfo &#123;

    ClassFilter getClassFilter();

    void validateInterfaces() throws IllegalArgumentException;
&#125;

public interface IntroductionInfo &#123;

    Class[] getInterfaces();
&#125;
</code></pre>
<p>没有<code>MethodMatcher</code>，因此没有<code>Pointcut</code>与介绍建议相关联。只有 class 过滤是合乎逻辑的。</p>
<p><code>getInterfaces()</code>方法返回此顾问程序引入的接口。</p>
<p>内部使用<code>validateInterfaces()</code>方法来查看引入的接口是否可以由配置的<code>IntroductionInterceptor</code>实现。</p>
<p>考虑 Spring 测试套件中的 example，并假设我们要将以下接口引入一个或多个 objects：</p>
<pre><code>public interface Lockable &#123;
    void lock();
    void unlock();
    boolean locked();
&#125;
</code></pre>
<p>这说明了一个混合。我们希望能够将建议的 objects 转换为<code>Lockable</code>，无论其类型如何，并调用锁定和解锁方法。如果我们调用<code>lock()</code>方法，我们希望所有 setter 方法都抛出<code>LockedException</code>。因此，我们可以添加一个 aspect，它提供了使 objects 不可变的能力，而不需要它们知道它：AOP 的一个很好的例子。</p>
<p>首先，我们需要<code>IntroductionInterceptor</code>来完成繁重的任务。在这种情况下，我们扩展<code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>便利 class。我们可以直接实现<code>IntroductionInterceptor</code>，但在大多数情况下使用<code>DelegatingIntroductionInterceptor</code>是最好的。</p>
<p><code>DelegatingIntroductionInterceptor</code>旨在委托对引入的接口的实际 implementation 的介绍，隐藏使用拦截这样做。您可以使用构造函数参数将委托设置为任何 object。默认委托(使用 no-argument 构造函数时)为<code>this</code>。因此，在下一个 example 中，委托是<code>DelegatingIntroductionInterceptor</code>的<code>LockMixin</code>子类。给定一个委托(默认情况下，它本身)，<code>DelegatingIntroductionInterceptor</code>实例查找委托实现的所有接口(除了<code>IntroductionInterceptor</code>)并支持对其中任何接口的介绍。诸如<code>LockMixin</code>之类的子类可以调用<code>suppressInterface(Class intf)</code>方法来抑制不应该公开的接口。但是，无论<code>IntroductionInterceptor</code>准备支持多少个接口，<code>IntroductionAdvisor</code>都使用控制哪些接口实际暴露。引入的接口隐藏了目标对同一接口的任何 implementation。</p>
<p>因此，<code>LockMixin</code>扩展<code>DelegatingIntroductionInterceptor</code>并实现<code>Lockable</code>本身。超类自动选择可以支持引入<code>Lockable</code>，因此我们不需要指定。我们可以用这种方式引入任意数量的接口。</p>
<p>注意使用<code>locked</code>实例变量。这有效地将额外的 state 添加到目标 object 中的 state。</p>
<p>以下 example 显示了 example <code>LockMixin</code> class：</p>
<pre><code>public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable &#123;

    private boolean locked;

    public void lock() &#123;
        this.locked = true;
    &#125;

    public void unlock() &#123;
        this.locked = false;
    &#125;

    public boolean locked() &#123;
        return this.locked;
    &#125;

    public Object invoke(MethodInvocation invocation) throws Throwable &#123;
        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf(&quot;set&quot;) == 0) &#123;
            throw new LockedException();
        &#125;
        return super.invoke(invocation);
    &#125;

&#125;
</code></pre>
<p>通常，您不需要覆盖<code>invoke()</code>方法。 <code>DelegatingIntroductionInterceptor</code> implementation(如果引入方法，calls <code>delegate</code>方法，否则进入连接点)通常就足够了。在本例中，我们需要添加一个检查：如果处于锁定模式，则不能调用 setter 方法。</p>
<p>所需的介绍只需要保存一个不同的<code>LockMixin</code>实例并指定引入的接口(在这种情况下，只有<code>Lockable</code>)。更复杂的 example 可能会对引入拦截器(将被定义为原型)进行 reference。在这种情况下，没有与<code>LockMixin</code>相关的 configuration，因此我们使用<code>new</code>创建它。以下 example 显示了我们的<code>LockMixinAdvisor</code> class：</p>
<pre><code>public class LockMixinAdvisor extends DefaultIntroductionAdvisor &#123;

    public LockMixinAdvisor() &#123;
        super(new LockMixin(), Lockable.class);
    &#125;
&#125;
</code></pre>
<p>我们可以非常简单地应用此顾问程序，因为它不需要 configuration。 (但是，如果没有<code>IntroductionAdvisor</code> .)就不可能使用<code>IntroductionInterceptor</code>与通常一样，顾问必须是 per-instance，因为它是有状态的。对于每个建议的 object，我们需要<code>LockMixinAdvisor</code>的不同实例，因此需要<code>LockMixin</code>。顾问包括建议 object 的 state 的一部分。</p>
<p>我们可以像在任何其他顾问中一样，使用 XML configuration 中的<code>Advised.addAdvisor()</code>方法或(推荐方式)以编程方式应用此顾问程序。下面讨论的所有代理创建选项，包括“自动代理创建器”，正确处理引入和有状态混合。</p>
<h3 id="6-3-Spring-中的-Advisor-API"><a href="#6-3-Spring-中的-Advisor-API" class="headerlink" title="6.3. Spring 中的 Advisor API"></a>6.3. Spring 中的 Advisor API</h3><p>在 Spring 中，Advisor 是一个 aspect，它只包含一个与切入点表达式相关联的建议 object。</p>
<p>除了介绍的特殊情况，任何顾问都可以使用任何建议。 <code>org.springframework.aop.support.DefaultPointcutAdvisor</code>是最常用的顾问 class。它可以与<code>MethodInterceptor</code>，<code>BeforeAdvice</code>或<code>ThrowsAdvice</code>一起使用。</p>
<p>可以在同一个 AOP 代理中混合 Spring 中的顾问程序和通知类型。例如，您可以在一个代理 configuration 中使用拦截建议，抛出建议和建议之前。 Spring 自动创建必要的拦截链。</p>
<h3 id="6-4-使用-ProxyFactoryBean-创建-AOP-代理"><a href="#6-4-使用-ProxyFactoryBean-创建-AOP-代理" class="headerlink" title="6.4. 使用 ProxyFactoryBean 创建 AOP 代理"></a>6.4. 使用 ProxyFactoryBean 创建 AOP 代理</h3><p>如果您使用 Spring IoC 容器(<code>ApplicationContext</code>或<code>BeanFactory</code>)为您的业务 objects(你应该！)，你想使用 Spring 的 AOP <code>FactoryBean</code> implementations 之一。 (请记住，工厂 bean 引入了一个间接层，让它创建一个不同的 type.)的对象</p>
<blockquote>
<p>Spring AOP 支持还使用了工厂 beans。</p>
</blockquote>
<p>在 Spring 中创建 AOP 代理的基本方法是使用<code>org.springframework.aop.framework.ProxyFactoryBean</code>。这样可以完全控制切入点，任何适用的建议以及它们的 ordering。但是，如果您不需要此类控件，则可以使用更简单的选项。</p>
<h4 id="6-4-1-基本"><a href="#6-4-1-基本" class="headerlink" title="6.4.1. 基本"></a>6.4.1. 基本</h4><p>与其他 Spring <code>FactoryBean</code> __mplementations 一样，<code>ProxyFactoryBean</code>引入了 level 间接。如果你定义<code>ProxyFactoryBean</code>名为<code>foo</code>，objects reference <code>foo</code>看不到<code>ProxyFactoryBean</code>实例本身，而是由<code>ProxyFactoryBean</code>中的<code>getObject()</code>方法的 implementation 创建的 object。此方法创建一个包装目标 object 的 AOP 代理。</p>
<p>使用<code>ProxyFactoryBean</code>或另一个 IoC-aware class 创建 AOP 代理的最重要的好处之一是 IoC 可以管理建议和切入点。这是一个强大的 feature，可以实现其他 AOP 框架难以实现的某些方法。对于 example，一个建议本身可以 reference application objects(除了目标，它应该在任何 AOP framework 中可用)，受益于 Dependency Injection 提供的所有可插拔性。</p>
<h4 id="6-4-2-JavaBean-Properties"><a href="#6-4-2-JavaBean-Properties" class="headerlink" title="6.4.2. JavaBean Properties"></a>6.4.2. JavaBean Properties</h4><p>在 common 中，Spring 提供了大多数<code>FactoryBean</code> __mplement，<code>ProxyFactoryBean</code> class 本身就是一个 JavaBean。它的 properties 用于：</p>
<ul>
<li>指定要代理的目标。</li>
<li>指定是否使用 CGLIB(稍后描述并参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">JDK-和 CGLIB-based 代理</a>)。</li>
</ul>
<p>一些 key properties 继承自<code>org.springframework.aop.framework.ProxyConfig</code>(Spring 中所有 AOP 代理工厂的超类)。这些 key properties 包括以下内容：</p>
<ul>
<li><code>proxyTargetClass</code>：<code>true</code>如果要代理目标 class，而不是目标 class 的接口。如果此 property value 设置为<code>true</code>，则会创建 CGLIB 代理(但也请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-pfb-proxy-types">JDK-和 CGLIB-based 代理</a>)。</li>
<li><code>optimize</code>：控制是否将积极优化应用于通过 CGLIB 创建的代理。除非您完全了解相关 AOP 代理如何处理优化，否则您不应轻易使用此设置。目前仅用于 CGLIB 代理。它对 JDK 动态代理没有影响。</li>
<li><code>frozen</code>：如果代理 configuration 为<code>frozen</code>，则不再允许更改 configuration。这既可以作为轻微优化，也可以用于在创建代理后不希望调用者能够操作代理(通过<code>Advised</code>接口)的情况。此 property 的默认 value 为<code>false</code>，因此允许更改(例如添加其他建议)。</li>
<li><code>exposeProxy</code>：确定当前代理是否应该在<code>ThreadLocal</code>中公开，以便目标可以访问它。如果目标需要获取代理并且<code>exposeProxy</code> property 设置为<code>true</code>，则目标可以使用<code>AopContext.currentProxy()</code>方法。</li>
</ul>
<p>特定于<code>ProxyFactoryBean</code>的其他 properties 包括以下内容：</p>
<ul>
<li><code>proxyInterfaces</code>：<code>String</code>接口名称的 array。如果未提供，则使用目标 class 的 CGLIB 代理(但也请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-pfb-proxy-types">JDK-和 CGLIB-based 代理</a>)。</li>
<li><code>interceptorNames</code>：<code>Advisor</code> _ar的<code>Advisor</code>，拦截器或其他建议名称。 Ordering 很重要，在第一个 come-first 服务的基础上。也就是说，列表中的第一个拦截器是第一个能够拦截调用的拦截器。</li>
</ul>
<p>名称是当前工厂中的 bean 名称，包括来自祖先工厂的 bean 名称。你不能在这里提到 bean references，因为这样做会导致<code>ProxyFactoryBean</code>忽略建议的 singleton 设置。</p>
<p>您可以使用星号(<code>*</code>)附加拦截器 name。这样做会导致应用所有顾问程序 beans，其名称以要应用星号之前的部分开头。您可以在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-pfb-proxy-types">使用“Global”顾问</a>中找到使用此 feature 的 example 示例。</p>
<ul>
<li>singleton：无论调用<code>getObject()</code>方法的频率如何，工厂是否应该_return 一个 object。几个<code>FactoryBean</code> implementations 提供了这样一种方法。默认的 value 是<code>true</code>。如果你想使用有状态的建议 - 对于 example，对于有状态的 mixins - 使用原型建议和<code>false</code>的 singleton value。</li>
</ul>
<h4 id="6-4-3-JDK-和-CGLIB-based-代理"><a href="#6-4-3-JDK-和-CGLIB-based-代理" class="headerlink" title="6.4.3. JDK-和 CGLIB-based 代理"></a>6.4.3. JDK-和 CGLIB-based 代理</h4><p>本节作为关于<code>ProxyFactoryBean</code>如何选择为特定目标 object(将被代理)创建 JDK-based 代理或 CGLIB-based 代理的权威文档。</p>
<blockquote>
<p>关于创建 JDK-或 CGLIB-based 代理的行为在 Spring 的 1.2.x 和 2.0 版本之间发生了变化。对于 auto-detecting 接口，<code>ProxyFactoryBean</code>现在表现出与<code>TransactionProxyFactoryBean</code> class 相似的语义。</p>
</blockquote>
<p>如果要代理的目标 object 的 class(以下简称为 target class)未实现任何接口，则会创建 CGLIB-based 代理。这是最简单的方案，因为 JDK 代理是 interface-based，没有接口意味着甚至不可能进行 JDK 代理。您可以通过设置<code>interceptorNames</code> property 来插入目标 bean 并指定拦截器列表。请注意，即使<code>ProxyFactoryBean</code>的<code>proxyTargetClass</code> property 已设置为<code>false</code>，也会创建 CGLIB-based 代理。 (这样做是没有意义的，最好从 bean 定义中删除，因为它最多是冗余的，最坏的情况是 confusing.)</p>
<p>如果目标 class 实现一个(或多个)接口，则创建的代理类型取决于<code>ProxyFactoryBean</code>的 configuration。</p>
<p>如果<code>ProxyFactoryBean</code>的<code>proxyTargetClass</code> property 已设置为<code>true</code>，则会创建 CGLIB-based 代理。这是有道理的，并且符合最少惊喜的原则。即使<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code> property 已设置为一个或多个完全限定的接口名称，<code>proxyTargetClass</code> property 设置为<code>true</code>这一事实会导致 CGLIB-based 代理生效。</p>
<p>如果<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code> property 已设置为一个或多个完全限定的接口名称，则会创建 JDK-based 代理。创建的代理实现<code>proxyInterfaces</code> property 中指定的所有接口。如果目标 class 碰巧实现了比<code>proxyInterfaces</code> property 中指定的接口多得多的接口，那么这一切都很好，但返回的代理并没有实现这些额外的接口。</p>
<p>如果尚未设置<code>ProxyFactoryBean</code>的<code>proxyInterfaces</code> property，但目标 class 确实实现了一个(或多个)接口，则<code>ProxyFactoryBean</code> auto-detects 目标 class 实际上实现了至少一个接口，并创建了 JDK-based 代理。实际代理的接口是 target class 实现的所有接口。实际上，这与提供目标 class 为<code>proxyInterfaces</code> property 实现的每个接口的列表相同。但是，它的工作量明显减少，并且不易出现印刷错误。</p>
<h4 id="6-4-4-代理接口"><a href="#6-4-4-代理接口" class="headerlink" title="6.4.4. 代理接口"></a>6.4.4. 代理接口</h4><p>考虑一下<code>ProxyFactoryBean</code>的简单示例。这个例子涉及：</p>
<ul>
<li>代理的目标 bean。这是 example 中的<code>personTarget</code> bean 定义。</li>
<li><code>Advisor</code>和<code>Interceptor</code>用于提供建议。</li>
<li>AOP 代理 bean 定义，用于指定目标 object(<code>personTarget</code> bean)，代理接口和要应用的建议。</li>
</ul>
<p>以下清单显示了 example：</p>
<pre><code>&lt;bean id=&quot;personTarget&quot; class=&quot;com.mycompany.PersonImpl&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;Tony&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;51&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myAdvisor&quot; class=&quot;com.mycompany.MyAdvisor&quot;&gt;
    &lt;property name=&quot;someProperty&quot; value=&quot;Custom string property value&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;debugInterceptor&quot; class=&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;&gt;
&lt;/bean&gt;

&lt;bean id=&quot;person&quot;
    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.mycompany.Person&quot;/&gt;

    &lt;property name=&quot;target&quot; ref=&quot;personTarget&quot;/&gt;
    &lt;property name=&quot;interceptorNames&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>请注意，<code>interceptorNames</code> property 采用<code>String</code>列表，该列表包含当前工厂中拦截器或顾问程序的 bean 名称。您可以在返回之前，之后使用顾问程序，拦截器，并抛出建议 objects。顾问的排序非常重要。</p>
<blockquote>
<p>您可能想知道为什么列表不包含 bean references。原因是，如果<code>ProxyFactoryBean</code>的 singleton property 设置为<code>false</code>，它必须能够 return 独立的代理实例。如果任何顾问本身就是原型，则需要返回一个独立的实例，因此必须能够从工厂获得原型的实例。持有参考是不够的。</p>
</blockquote>
<p>前面显示的<code>person</code> bean 定义可用于代替<code>Person</code> implementation，如下所示：</p>
<pre><code>Person person = (Person) factory.getBean(&quot;person&quot;);
</code></pre>
<p>同一个 IoC context 中的其他 beans 可以表达对它的强类型依赖，就像普通的 Java object 一样。以下 example 显示了如何执行此操作：</p>
<pre><code>&lt;bean id=&quot;personUser&quot; class=&quot;com.mycompany.PersonUser&quot;&gt;
    &lt;property name=&quot;person&quot;&gt;&lt;ref bean=&quot;person&quot;/&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>此 example 中的<code>PersonUser</code> class 显示<code>Person</code>类型的 property。就其而言，AOP 代理可以透明地用于代替“真正的”人实现。但是，它的 class 将是一个动态代理 class。可以将它转换为<code>Advised</code>接口(稍后讨论)。</p>
<p>您可以使用匿名内部 bean 隐藏目标和代理之间的区别。只有<code>ProxyFactoryBean</code>定义是不同的。该建议仅用于完整性。以下 example 显示了如何使用匿名内部 bean：</p>
<pre><code>&lt;bean id=&quot;myAdvisor&quot; class=&quot;com.mycompany.MyAdvisor&quot;&gt;
    &lt;property name=&quot;someProperty&quot; value=&quot;Custom string property value&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;debugInterceptor&quot; class=&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;/&gt;

&lt;bean id=&quot;person&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.mycompany.Person&quot;/&gt;
    &lt;!-- Use inner bean, not local reference to target --&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;com.mycompany.PersonImpl&quot;&gt;
            &lt;property name=&quot;name&quot; value=&quot;Tony&quot;/&gt;
            &lt;property name=&quot;age&quot; value=&quot;51&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;interceptorNames&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>使用匿名内部 bean 的优点是只有一个<code>Person</code>类型的 object。如果我们想要阻止 application context 的用户获取 un-advised object 的 reference 或者需要避免 Spring IoC 自动装配的任何歧义，这将非常有用。可以说，<code>ProxyFactoryBean</code>定义为 self-contained 也有一个优点。但是，有时能够从工厂获得 un-advised 目标实际上可能是一个优势(例如，在某些测试场景中)。</p>
<h4 id="6-4-5-代理-Classes"><a href="#6-4-5-代理-Classes" class="headerlink" title="6.4.5. 代理 Classes"></a>6.4.5. 代理 Classes</h4><p>如果您需要代理 class 而不是一个或多个接口，该怎么办？</p>
<p>想象一下，在我们之前的例子中，没有<code>Person</code>接口。我们需要建议一个没有实现任何业务接口的 class <code>Person</code>。在这种情况下，您可以将 Spring 配置为使用 CGLIB 代理而不是动态代理。为此，请将前面显示的<code>ProxyFactoryBean</code>上的<code>proxyTargetClass</code> property 设置为<code>true</code>。虽然最好是编程到接口而不是 classes，但在使用 legacy code 时，建议不实现接口的 classes 的功能非常有用。 (一般来说，Spring 不是规定性的.虽然它可以很容易地应用好的做法，但它避免强迫特定的 approach.)</p>
<p>如果您愿意，即使您有接口，也可以在任何情况下强制使用 CGLIB。</p>
<p>CGLIB 代理通过在运行时生成目标 class 的子类来工作。 Spring 将此生成的子类配置为将方法 calls 委托给原始目标。子类用于实现 Decorator pattern，在通知中编织。</p>
<p>CGLIB 代理通常应对用户透明。但是，有一些问题需要考虑：</p>
<ul>
<li>无法建议<code>Final</code>方法，因为它们无法被覆盖。</li>
<li>无需将 CGLIB 添加到 classpath。从 Spring 3.2 开始，CGLIB 被重新打包并包含在 spring-core JAR 中。换句话说，CGLIB-based AOP“开箱即用”，JDK 动态代理也是如此。</li>
</ul>
<p>CGLIB 代理和动态代理之间几乎没有性能差异。从 Spring 1.0 开始，动态代理略快一些。但是，这可能会在未来发生变化。 在这种情况下，绩效不应该是一个决定性的考虑因素。</p>
<h4 id="6-4-6-使用“Global”顾问"><a href="#6-4-6-使用“Global”顾问" class="headerlink" title="6.4.6. 使用“Global”顾问"></a>6.4.6. 使用“Global”顾问</h4><p>通过在拦截器 name 上附加一个星号，所有具有 bean 名称的顾问都会将星号之前的部分匹配添加到顾问程序链中。如果您需要添加一组标准的“global”顾问程序，这可以派上用场。以下 example 定义了两个 global 顾问程序：</p>
<pre><code>&lt;bean id=&quot;proxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;target&quot; ref=&quot;service&quot;/&gt;
    &lt;property name=&quot;interceptorNames&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;global*&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;global_debug&quot; class=&quot;org.springframework.aop.interceptor.DebugInterceptor&quot;/&gt;
&lt;bean id=&quot;global_performance&quot; class=&quot;org.springframework.aop.interceptor.PerformanceMonitorInterceptor&quot;/&gt;
</code></pre>
<h3 id="6-5-简明的代理定义"><a href="#6-5-简明的代理定义" class="headerlink" title="6.5. 简明的代理定义"></a>6.5. 简明的代理定义</h3><p>特别是在定义 transactional 代理时，最终可能会有许多类似的代理定义。使用 parent 和 child bean 定义以及内部 bean 定义可以产生更清晰，更简洁的代理定义。</p>
<p>首先，我们为代理创建 parent，template，bean 定义，如下所示：</p>
<pre><code>&lt;bean id=&quot;txProxyTemplate&quot; abstract=&quot;true&quot;
        class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
    &lt;property name=&quot;transactionAttributes&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>这从未实例化，因此它实际上可能是不完整的。然后，需要创建的每个代理都是 child bean 定义，它将代理的目标包装为内部 bean 定义，因为目标永远不会单独使用。以下 example 显示了这样的 child bean：</p>
<pre><code>&lt;bean id=&quot;myService&quot; parent=&quot;txProxyTemplate&quot;&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;org.springframework.samples.MyServiceImpl&quot;&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>您可以从 parent 模板覆盖 properties。在以下 example 中，我们覆盖 transaction 传播设置：</p>
<pre><code>&lt;bean id=&quot;mySpecialService&quot; parent=&quot;txProxyTemplate&quot;&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;bean class=&quot;org.springframework.samples.MySpecialServiceImpl&quot;&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;transactionAttributes&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;get*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key=&quot;find*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key=&quot;load*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key=&quot;store*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>请注意，在 parent bean example 中，我们通过将<code>abstract</code>属性设置为<code>true</code>显式地将 parent bean 定义标记为抽象，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-global-advisors">先前</a>所述，因此实际上可能无法实例化它。 Application 上下文(但不是简单的 bean 工厂)，默认情况下，pre-instantiate 所有单例。因此，重要的是(至少对于 singleton beans)，如果你有一个(parent)bean 定义，你打算只用作模板，并且这个定义指定一个 class，你必须确保将<code>abstract</code>属性设置为<code>true</code>。否则，application context 实际上会尝试 pre-instantiate 它。</p>
<h3 id="6-6-使用-ProxyFactory-以编程方式创建-AOP-代理"><a href="#6-6-使用-ProxyFactory-以编程方式创建-AOP-代理" class="headerlink" title="6.6. 使用 ProxyFactory 以编程方式创建 AOP 代理"></a>6.6. 使用 ProxyFactory 以编程方式创建 AOP 代理</h3><p>使用 Spring 以编程方式创建 AOP 代理很容易。这使您可以使用 Spring AOP 而不依赖于 Spring IoC。</p>
<p>target object 实现的接口会自动代理。以下清单显示了为目标 object 创建代理，其中包含一个拦截器和一个顾问程序：</p>
<pre><code>ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addAdvice(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();
</code></pre>
<p>第一个 step 是构造一个<code>org.springframework.aop.framework.ProxyFactory</code>类型的 object。您可以使用目标 object 创建它，如前面的 example，或指定要在备用构造函数中代理的接口。</p>
<p>您可以添加建议(使用拦截器作为专门的建议)，顾问或两者，并在<code>ProxyFactory</code>的生命周期中操纵它们。如果添加<code>IntroductionInterceptionAroundAdvisor</code>，则可以使代理实现其他接口。</p>
<p><code>ProxyFactory</code>(继承自<code>AdvisedSupport</code>)也有便捷方法，可以添加其他建议类型，例如 before 和 throws 建议。 <code>AdvisedSupport</code>是<code>ProxyFactory</code>和<code>ProxyFactoryBean</code>的超类。</p>
<blockquote>
<p>在大多数应用程序中，将 AOP 代理创建与 IoC framework 集成是最佳实践。我们建议您通常使用 AOP 来外部化来自 Java code 的 configuration。</p>
</blockquote>
<h3 id="6-7-操纵建议的-Objects"><a href="#6-7-操纵建议的-Objects" class="headerlink" title="6.7. 操纵建议的 Objects"></a>6.7. 操纵建议的 Objects</h3><p>但是，您创建 AOP 代理，可以使用<code>org.springframework.aop.framework.Advised</code>接口操作它们。无论它实现哪个其他接口，任何 AOP 代理都可以转换为此接口。该界面包括以下方法：</p>
<pre><code>Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();
</code></pre>
<p><code>getAdvisors()</code>方法为每个已添加到工厂的顾问程序，拦截器或其他通知类型返回<code>Advisor</code>。如果添加了<code>Advisor</code>，则此索引处返回的顾问程序是您添加的 object。如果您添加了一个拦截器或其他建议类型，Spring 将其包装在一个顾问程序中，并且切入点始终返回<code>true</code>。因此，如果添加了<code>MethodInterceptor</code>，则为此索引返回的顾问程序是<code>DefaultPointcutAdvisor</code>，它返回<code>MethodInterceptor</code>以及与所有 classes 和方法匹配的切入点。</p>
<p><code>addAdvisor()</code>方法可用于添加任何<code>Advisor</code>。通常，持有切入点和建议的顾问程序是通用<code>DefaultPointcutAdvisor</code>，您可以将其用于任何建议或切入点(但不适用于介绍)。</p>
<p>默认情况下，即使创建了代理，也可以添加或删除顾问程序或拦截器。唯一的限制是不可能添加或删除介绍顾问，因为工厂的现有代理不显示接口更改。 (您可以从工厂获取新代理以避免此 problem.)</p>
<p>以下 example 显示将 AOP 代理转换为<code>Advised</code>接口并检查和操作其建议：</p>
<pre><code>Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + &quot; advisors&quot;);

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(new DebugInterceptor());

// Add selective advice using a pointcut
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals(&quot;Added two advisors&quot;, oldAdvisorCount + 2, advised.getAdvisors().length);
</code></pre>
<blockquote>
<p>尽管毫无疑问，合法的使用案例是否可行(无双关语)修改 production 中的商业 object 建议是值得怀疑的。但是，它在开发中非常有用(例如，在测试中)。我们有时发现能够以拦截器或其他建议的形式添加 test code 非常有用，进入我们想要测试的方法调用。 (例如，建议可以进入为该方法创建的 transaction，也许在运行 SQL 以检查数据库是否已正确更新，然后标记 transaction for roll back.)</p>
</blockquote>
<p>根据您创建代理的方式，通常可以设置<code>frozen</code> flag。在这种情况下，<code>Advised</code> <code>isFrozen()</code>方法返回<code>true</code>，任何通过添加或删除修改建议的尝试都会导致<code>AopConfigException</code>。在某些情况下，冻结建议的 object 的 state 的功能很有用(例如，为了防止调用 code 删除安全拦截器)。如果已知不需要运行时建议修改，它也可以在 Spring 1.1 中使用以允许积极优化。</p>
<h3 id="6-8-使用“auto-proxy”设施"><a href="#6-8-使用“auto-proxy”设施" class="headerlink" title="6.8. 使用“auto-proxy”设施"></a>6.8. 使用“auto-proxy”设施</h3><p>到目前为止，我们已经考虑使用<code>ProxyFactoryBean</code>或类似的工厂 bean 显式创建 AOP 代理。</p>
<p>Spring 还允许我们使用“auto-proxy” bean 定义，它可以自动代理所选的 bean 定义。这是基于 Spring 的“bean post processor”基础结构构建的，它可以在容器加载时修改任何 bean 定义。</p>
<p>在此 model 中，您在 XML bean 定义文件中设置了一些特殊的 bean 定义来配置 auto-proxy 基础结构。这允许您声明符合 auto-proxying 的目标。你不需要使用<code>ProxyFactoryBean</code>。</p>
<p>有两种方法可以做到这一点：</p>
<ul>
<li>通过使用引用当前 context 中特定 beans 的 auto-proxy 创建者。</li>
<li>一个特殊的 auto-proxy 创建案例值得单独考虑：auto-proxy 创建由 source-level 元数据属性驱动。</li>
</ul>
<h4 id="6-8-1-Auto-proxy-Bean-定义"><a href="#6-8-1-Auto-proxy-Bean-定义" class="headerlink" title="6.8.1. Auto-proxy Bean 定义"></a>6.8.1. Auto-proxy Bean 定义</h4><p>本节介绍<code>org.springframework.aop.framework.autoproxy</code>包提供的 auto-proxy 创建者。</p>
<h5 id="BeanNameAutoProxyCreator"><a href="#BeanNameAutoProxyCreator" class="headerlink" title="BeanNameAutoProxyCreator"></a>BeanNameAutoProxyCreator</h5><p><code>BeanNameAutoProxyCreator</code> class 是<code>BeanPostProcessor</code>，它自动为 beans 创建 AOP 代理，其名称为 match 文字值或通配符。以下 example 显示了如何创建<code>BeanNameAutoProxyCreator</code> bean：</p>
<pre><code>&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt;
    &lt;property name=&quot;beanNames&quot; value=&quot;jdk*,onlyJdk&quot;/&gt;
    &lt;property name=&quot;interceptorNames&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;myInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>与<code>ProxyFactoryBean</code>一样，有一个<code>interceptorNames</code> property 而不是拦截器列表，以允许原型顾问的正确行为。命名为“拦截器”可以是顾问或任何建议类型。</p>
<p>与 auto-proxying 一般，使用<code>BeanNameAutoProxyCreator</code>的主要目的是将相同的 configuration 一致地应用于多个 objects，并使用最小的 configuration 量。将声明性 transactions 应用于多个 objects 是一种流行的选择。</p>
<p>Bean 定义的名称 match，例如前面的 example 中的<code>jdkMyBean</code>和<code>onlyJdk</code>，是带有目标 class 的普通旧 bean 定义。 <code>BeanNameAutoProxyCreator</code>自动创建 AOP 代理。相同的建议适用于所有匹配的 beans。请注意，如果使用顾问程序(而不是前面的 example 中的拦截器)，则切入点可能会以不同的方式应用于不同的 beans。</p>
<h5 id="DefaultAdvisorAutoProxyCreator"><a href="#DefaultAdvisorAutoProxyCreator" class="headerlink" title="DefaultAdvisorAutoProxyCreator"></a>DefaultAdvisorAutoProxyCreator</h5><p>一个更通用且极其强大的 auto-proxy 创建者是<code>DefaultAdvisorAutoProxyCreator</code>。这会在当前 context 中自动应用符合条件的顾问程序，而无需在 auto-proxy 顾问程序的 bean 定义中包含特定的 bean 名称。它提供了与<code>BeanNameAutoProxyCreator</code>一致的 configuration 和避免重复的相同优点。</p>
<p>使用此机制涉及：</p>
<ul>
<li>指定<code>DefaultAdvisorAutoProxyCreator</code> bean 定义。</li>
<li>在相同或相关的上下文中指定任意数量的顾问程序。请注意，这些必须是顾问，而不是拦截器或其他建议。这是必要的，因为必须有一个切入点来评估，以检查每个建议是否符合候选 bean 定义。</li>
</ul>
<p><code>DefaultAdvisorAutoProxyCreator</code>自动评估每个顾问程序中包含的切入点，以查看它应该应用于每个业务 object 的建议(如果有的话)(例如 example 中的<code>businessObject1</code>和<code>businessObject2</code>)。</p>
<p>这意味着可以自动将任意数量的顾问程序应用于每个业务 object。如果任何顾问程序中没有切入点与业务 object 中的任何方法匹配，则 object 不会被代理。当为新业务 objects 添加 bean 定义时，如有必要，它们会自动代理。</p>
<p>Auto-proxying 通常具有使调用者或依赖项无法获得 un-advised object 的优点。在此<code>ApplicationContext</code>上调用<code>getBean(&quot;businessObject1&quot;)</code>将返回 AOP 代理，而不是目标业务 object。 (前面显示的“内部 bean”成语也提供了这个 benefit.)</p>
<p>以下 example 创建<code>DefaultAdvisorAutoProxyCreator</code> bean 以及本节中讨论的其他元素：</p>
<pre><code>&lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;/&gt;

&lt;bean class=&quot;org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor&quot;&gt;
    &lt;property name=&quot;transactionInterceptor&quot; ref=&quot;transactionInterceptor&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customAdvisor&quot; class=&quot;com.mycompany.MyAdvisor&quot;/&gt;

&lt;bean id=&quot;businessObject1&quot; class=&quot;com.mycompany.BusinessObject1&quot;&gt;
    &lt;!-- Properties omitted --&gt;
&lt;/bean&gt;

&lt;bean id=&quot;businessObject2&quot; class=&quot;com.mycompany.BusinessObject2&quot;/&gt;
</code></pre>
<p>如果要将相同的建议一致地应用于许多业务 objects，则<code>DefaultAdvisorAutoProxyCreator</code>非常有用。基础结构定义到位后，您可以添加新的业务 objects，而不包括特定的代理 configuration。您还可以轻松地删除其他方面(对于 example，跟踪或 performance 监视方面)，只需对 configuration 进行最少的更改。</p>
<p><code>DefaultAdvisorAutoProxyCreator</code>提供对过滤的支持(通过使用命名约定，以便仅评估某些顾问程序，这允许在同一工厂中使用多个，不同配置的 AdvisorAutoProxyCreators)和 ordering。如果这是一个问题，顾问可以实现<code>org.springframework.core.Ordered</code>接口以确保正确的 ordering。前面的 example 中使用的<code>TransactionAttributeSourceAdvisor</code>具有可配置的 order value。默认设置是无序的。</p>
<h3 id="6-9-使用-TargetSource-Implementations"><a href="#6-9-使用-TargetSource-Implementations" class="headerlink" title="6.9. 使用 TargetSource Implementations"></a>6.9. 使用 TargetSource Implementations</h3><p>Spring 提供<code>TargetSource</code>的概念，在<code>org.springframework.aop.TargetSource</code>接口中表示。该接口负责返回实现连接点的“target object”。在 AOP 代理处理方法调用的每个 time 时，都要求<code>TargetSource</code> implementation 提供目标实例。</p>
<p>使用 Spring AOP 的开发人员通常不需要直接使用<code>TargetSource</code> implementations，但这提供了支持池，热插拔和其他复杂目标的强大方法。例如，通过使用池来管理实例，池<code>TargetSource</code>可以为每次调用返回不同的目标实例。</p>
<p>如果未指定<code>TargetSource</code>，则使用默认 implementation 来包装本地 object。每次调用都会返回相同的目标(正如您所期望的那样)。</p>
<p>本节的 rest 描述了 Spring 提供的标准目标源以及如何使用它们。</p>
<blockquote>
<p>使用自定义目标源时，您的目标通常需要是原型而不是 singleton bean 定义。这允许 Spring 在需要时创建新的目标实例。</p>
</blockquote>
<h4 id="6-9-1-Hot-swappable-目标来源"><a href="#6-9-1-Hot-swappable-目标来源" class="headerlink" title="6.9.1. Hot-swappable 目标来源"></a>6.9.1. Hot-swappable 目标来源</h4><p><code>org.springframework.aop.target.HotSwappableTargetSource</code>的存在是为了让 AOP 代理的目标切换，同时让调用者保持对它的 references。</p>
<p>更改目标源的目标会立即生效。 <code>HotSwappableTargetSource</code>是 thread-safe。</p>
<p>您可以使用 HotSwappableTargetSource 上的<code>swap()</code>方法更改目标，如下面的 example 所示：</p>
<pre><code>HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean(&quot;swapper&quot;);
Object oldTarget = swapper.swap(newTarget);
</code></pre>
<p>以下 example 显示了所需的 XML 定义：</p>
<pre><code>&lt;bean id=&quot;initialTarget&quot; class=&quot;mycompany.OldTarget&quot;/&gt;

&lt;bean id=&quot;swapper&quot; class=&quot;org.springframework.aop.target.HotSwappableTargetSource&quot;&gt;
    &lt;constructor-arg ref=&quot;initialTarget&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;swappable&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;targetSource&quot; ref=&quot;swapper&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的<code>swap()</code>调用更改了可交换 bean 的目标。 对 bean 持有 reference 的客户端不知道更改但立即开始命中新目标。</p>
<p>虽然这个 example 没有添加任何建议(没有必要添加使用<code>TargetSource</code>的建议)，但任何<code>TargetSource</code>都可以与任意建议一起使用。</p>
<h4 id="6-9-2-汇集目标来源"><a href="#6-9-2-汇集目标来源" class="headerlink" title="6.9.2. 汇集目标来源"></a>6.9.2. 汇集目标来源</h4><p>使用池化目标源为 stateless session EJB 提供了类似的编程 model，其中维护了相同实例的池，方法调用将在池中释放 objects。</p>
<p>Spring 池和 SLSB 池之间的一个重要区别是 Spring 池可以应用于任何 POJO。与 Spring 一样，此服务可以 non-invasive 方式应用。</p>
<p>Spring 为 Commons _Pool 2.2 提供支持，它提供了一个相当有效的池 implementation。您需要 application 的 classpath 上的<code>commons-pool</code> Jar 才能使用此 feature。您还可以将<code>org.springframework.aop.target.AbstractPoolingTargetSource</code>子类化为支持任何其他池 API。</p>
<blockquote>
<p>Commons _Pool 1.5 也受支持，但从 Spring Framework 4.2 开始不推荐使用。</p>
</blockquote>
<p>以下清单显示了 example configuration：</p>
<pre><code>&lt;bean id=&quot;businessObjectTarget&quot; class=&quot;com.mycompany.MyBusinessObject&quot;
        scope=&quot;prototype&quot;&gt;
    ... properties omitted
&lt;/bean&gt;

&lt;bean id=&quot;poolTargetSource&quot; class=&quot;org.springframework.aop.target.CommonsPool2TargetSource&quot;&gt;
    &lt;property name=&quot;targetBeanName&quot; value=&quot;businessObjectTarget&quot;/&gt;
    &lt;property name=&quot;maxSize&quot; value=&quot;25&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;businessObject&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;targetSource&quot; ref=&quot;poolTargetSource&quot;/&gt;
    &lt;property name=&quot;interceptorNames&quot; value=&quot;myInterceptor&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>请注意，目标 object(前面的 example 中的<code>businessObjectTarget</code>)必须是原型。这使得<code>PoolingTargetSource</code> implementation 可以根据需要创建目标的新实例来扩展池。有关其 properties 的信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html">AbstractPoolingTargetSource 的 javadoc</a>和您希望使用的具体子类。 <code>maxSize</code>是最基本的，并且始终保证存在。</p>
<p>在这种情况下，<code>myInterceptor</code>是需要在同一 IoC context 中定义的拦截器的 name。但是，您无需指定拦截器来使用池。如果您只想要池化而没有其他建议，请不要设置<code>interceptorNames</code> property。</p>
<p>您可以将 Spring 配置为能够将任何池化的 object 转换为<code>org.springframework.aop.target.PoolingConfig</code>接口，该接口通过介绍公开有关 configuration 和池当前大小的信息。您需要定义类似于以下内容的顾问程序：</p>
<pre><code>&lt;bean id=&quot;poolConfigAdvisor&quot; class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt;
    &lt;property name=&quot;targetObject&quot; ref=&quot;poolTargetSource&quot;/&gt;
    &lt;property name=&quot;targetMethod&quot; value=&quot;getPoolingConfigMixin&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>通过在<code>AbstractPoolingTargetSource</code> class 上调用便捷方法获得此顾问程序，因此使用<code>MethodInvokingFactoryBean</code>。此顾问程序的 name(<code>poolConfigAdvisor</code>，此处)必须位于<code>ProxyFactoryBean</code>中的拦截器名称列表中，以暴露池化的 object。</p>
<p>演员阵容定义如下：</p>
<pre><code>PoolingConfig conf = (PoolingConfig) beanFactory.getBean(&quot;businessObject&quot;);
System.out.println(&quot;Max pool size is &quot; + conf.getMaxSize());
</code></pre>
<blockquote>
<p>通常不需要池化 stateless 服务 objects。我们不相信它应该是默认选择，因为大多数 stateless objects 自然是线程安全的，并且如果资源被缓存，实例池是有问题的。</p>
</blockquote>
<p>使用 auto-proxying 可以实现更简单的池化。您可以设置任何 auto-proxy 创建者使用的<code>TargetSource</code> __mplement。</p>
<h4 id="6-9-3-原型目标来源"><a href="#6-9-3-原型目标来源" class="headerlink" title="6.9.3. 原型目标来源"></a>6.9.3. 原型目标来源</h4><p>设置“原型”目标源类似于设置池<code>TargetSource</code>。在这种情况下，将在每次方法调用时创建目标的新实例。虽然在现代 JVM 中创建一个新的 object 的成本并不高，但连接新的 object(满足其 IoC 依赖性)的成本可能更高。因此，如果没有充分的理由，就不应该使用这种方法。</p>
<p>为此，您可以修改前面显示的<code>poolTargetSource</code>定义，如下所示(为清晰起见，我们还更改了 name)：</p>
<pre><code>&lt;bean id=&quot;prototypeTargetSource&quot; class=&quot;org.springframework.aop.target.PrototypeTargetSource&quot;&gt;
    &lt;property name=&quot;targetBeanName&quot; ref=&quot;businessObjectTarget&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>唯一的 property 是目标 bean 的 name。在<code>TargetSource</code> implementations 中使用继承来确保一致的命名。与池化目标源一样，目标 bean 必须是原型 bean 定义。</p>
<h4 id="6-9-4-ThreadLocal-目标源"><a href="#6-9-4-ThreadLocal-目标源" class="headerlink" title="6.9.4. ThreadLocal 目标源"></a>6.9.4. ThreadLocal 目标源</h4><p>如果需要为每个传入请求创建 object(每个线程)，<code>ThreadLocal</code>目标源很有用。 <code>ThreadLocal</code>的概念提供了一个 JDK-wide 工具来透明地将一个资源与一个线程一起存储。设置<code>ThreadLocalTargetSource</code>与其他类型的目标源所解释的几乎相同，如下面的示例所示：</p>
<pre><code>&lt;bean id=&quot;threadlocalTargetSource&quot; class=&quot;org.springframework.aop.target.ThreadLocalTargetSource&quot;&gt;
    &lt;property name=&quot;targetBeanName&quot; value=&quot;businessObjectTarget&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p><code>ThreadLocal</code>实例在 multi-threaded 和 multi-classloader 环境中错误地使用它们时会出现严重问题(可能导致 memory 泄漏)。您应该始终考虑将 threadlocal 包装在其他 class 中，并且永远不要直接使用<code>ThreadLocal</code>本身(wrapper class 除外)。此外，您应该始终记住正确设置和取消设置(后者只需要调用<code>ThreadLocal.set(null)</code>)线程的本地资源。在任何情况下都应该进行取消，因为不取消它可能会导致有问题的行为。 Spring 的<code>ThreadLocal</code>支持为您执行此操作，应始终考虑使用<code>ThreadLocal</code>实例而无需其他正确处理 code。</p>
</blockquote>
<h3 id="6-10-定义新的建议类型"><a href="#6-10-定义新的建议类型" class="headerlink" title="6.10. 定义新的建议类型"></a>6.10. 定义新的建议类型</h3><p>Spring AOP 旨在可扩展。虽然拦截 implementation 策略目前在内部使用，但除了拦截建议之外，之前，抛出建议和返回建议之后，还可以支持任意建议类型。</p>
<p><code>org.springframework.aop.framework.adapter</code>包是一个 SPI 包，可以在不更改核心 framework 的情况下添加对新自定义通知类型的支持。自定义<code>Advice</code>类型的唯一约束是它必须实现<code>org.aopalliance.aop.Advice</code>标记接口。</p>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html">org.springframework.aop.framework.adapter</a> javadoc。</p>
<h2 id="7-Null-safety"><a href="#7-Null-safety" class="headerlink" title="7. Null-safety"></a>7. Null-safety</h2><p>尽管 Java 不允许您使用其类型系统表达 null-safety，但 Spring Framework 现在在<code>org.springframework.lang</code>包中提供以下注释，以便您声明 API 和字段的可为空性：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/lang/NonNull.html">@NonNull</a>：注释表示特定参数 returnvalue 或字段不能<code>null</code>(参数和 return value 不需要<code>@NonNullApi</code>和<code>@NonNullFields</code>适用)。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/lang/Nullable.html">@Nullable</a>：注释表示特定参数 returnvalue 或 field 可以是<code>null</code>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html">@NonNullApi</a>：包 level 的 Annotation 声明 non-null 作为参数和 return 值的默认行为。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/lang/NonNullFields.html">@NonNullFields</a>：包 level 的 Annotation 声明 non-null 作为字段的默认行为。</li>
</ul>
<p>Spring Framework 利用这些注释，但它们也可以在任何基于 Spring 的 Java 项目中使用，以声明 null-safe API 和可选的 null-safe 字段。尚未支持泛型类型 arguments，varargs 和 array 元素的可空性，但应该在即将发布的版本中，请参阅<a target="_blank" rel="noopener" href="https://jira.spring.io/browse/SPR-15942">SPR-15942</a>以获取 up-to-date 信息。预计 Spring Framework 发布之间的可空性声明为 fine-tuned，包括次要声明。方法体内使用的类型的可为空性超出了此 feature 的范围。</p>
<blockquote>
<p>_Reactor 或 Spring Data 这样的库提供了使用此 feature 的 null-safe API。</p>
</blockquote>
<h3 id="7-1-用例"><a href="#7-1-用例" class="headerlink" title="7.1. 用例"></a>7.1. 用例</h3><p>除了为 Spring Framework API 可空性提供显式声明之外，IDE(例如 IDEA 或 Eclipse)可以使用这些注释来提供与 null-safety 相关的有用警告，以避免在运行时<code>NullPointerException</code>。</p>
<p>它们还用于在 Kotlin 项目中制作 Spring API null-safe，因为 Kotlin 本身支持<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a>。更多详情可在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/languages.html#beans-child-bean-definitions">Kotlin 支持文档</a>中找到。</p>
<h3 id="7-2-JSR-305-meta-annotations"><a href="#7-2-JSR-305-meta-annotations" class="headerlink" title="7.2. JSR 305 meta-annotations"></a>7.2. JSR 305 meta-annotations</h3><p>Spring annotations 是 meta-annotated with <a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a> annotations(一个休眠但广泛传播的 JSR)。 JSR 305 meta-annotations 让像 IDEA 或 Kotlin 这样的工具供应商以通用方式提供 null-safety 支持，而不必支持 Spring annotations。</p>
<p>没有必要也不建议在项目 classpath 中添加 JSR 305 依赖项以利用 Spring null-safe API。只有在其代码库中使用 null-safety annotations 的 Spring-based libraries 等项目才应添加带有<code>compileOnly</code> Gradle configuration 或 Maven <code>provided</code>范围的<code>com.google.code.findbugs:jsr305:3.0.2</code>以避免编译警告。</p>
<h2 id="8-数据缓冲区和编解码器"><a href="#8-数据缓冲区和编解码器" class="headerlink" title="8.数据缓冲区和编解码器"></a>8.数据缓冲区和编解码器</h2><p>Java NIO 提供<code>ByteBuffer</code>，但许多 libraries 在它们自己的字节缓冲区 API 之上构建，特别是对于使用直接缓冲区重用缓冲区 and/or 有利于 performance 的网络操作。对于 example Netty 具有<code>ByteBuf</code>层次结构，Undertow 使用 XNIO，Jetty 使用池化字节缓冲区并释放回调，依此类推。 <code>spring-core</code>模块提供了一组抽象来处理各种字节缓冲区 API，如下所示：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#kotlin-null-safety">DataBufferFactory</a>抽象创建数据缓冲区。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#databuffers-factory">DataBuffer</a>表示字节缓冲区，可以是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#databuffers-buffer">汇集</a>。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#databuffers-buffer-pooled">DataBufferUtils</a>提供数据缓冲区的实用程序方法。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#databuffers-utils">编解码器</a>将数据缓冲流解码或编码为更高的 level objects。</li>
</ul>
<h3 id="8-1-DataBufferFactory"><a href="#8-1-DataBufferFactory" class="headerlink" title="8.1. DataBufferFactory"></a>8.1. DataBufferFactory</h3><p><code>DataBufferFactory</code>用于以两种方式之一创建数据缓冲区：</p>
<ul>
<li>分配一个新的数据缓冲区，可选择预先指定容量(如果已知)，即使<code>DataBuffer</code>的实现可以根据需要增长和缩小，这也会更有效。</li>
<li>包装现有的<code>byte[]</code>或<code>java.nio.ByteBuffer</code>，它使用<code>DataBuffer</code> implementation 来装饰给定数据，并且不涉及分配。</li>
</ul>
<p>请注意，WebFlux applications 不直接创建<code>DataBufferFactory</code>，而是通过 client 侧的<code>ServerHttpResponse</code>或<code>ClientHttpRequest</code>访问它。工厂类型取决于底层的客户端或服务器 e.g. <code>NettyDataBufferFactory</code>表示 Reactor Netty，<code>DefaultDataBufferFactory</code>表示其他人。</p>
<h3 id="8-2-的-DataBuffer"><a href="#8-2-的-DataBuffer" class="headerlink" title="8.2. 的 DataBuffer"></a>8.2. 的 DataBuffer</h3><p><code>DataBuffer</code>接口提供与<code>java.nio.ByteBuffer</code>类似的操作，但也带来一些额外的好处，其中一些受 Netty <code>ByteBuf</code>的启发。以下是部分福利清单：</p>
<ul>
<li>读写独立职位，i.e。不需要调用<code>flip()</code>来在读写之间交替。</li>
<li>与<code>java.lang.StringBuilder</code>一样，按需扩容。</li>
<li>通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#codecs">PooledDataBuffer</a>汇总缓冲区和 reference 计数。</li>
<li>将缓冲区视为<code>java.nio.ByteBuffer</code>，<code>InputStream</code>或<code>OutputStream</code>。</li>
<li>确定给定字节的索引或最后一个索引。</li>
</ul>
<h3 id="8-3-PooledDataBuffer"><a href="#8-3-PooledDataBuffer" class="headerlink" title="8.3. PooledDataBuffer"></a>8.3. PooledDataBuffer</h3><p>正如 Javadoc for <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html">字节缓冲区</a>中所解释的，字节缓冲区可以是直接缓冲区或 non-direct。直接缓冲区可以驻留在 Java 堆之外，这样就无需复制本机 I/O 操作。这使得直接缓冲区对于通过 socket 接收和发送数据特别有用，但是它们创建和释放的成本也更高，这导致了池缓冲区的 idea。</p>
<p><code>PooledDataBuffer</code>是<code>DataBuffer</code>的扩展，它有助于 reference 计数，这对于字节缓冲池是必不可少的。它是如何工作的？分配<code>PooledDataBuffer</code>时，reference 计数为 1. Calls 到<code>retain()</code>递增计数，而 calls 到<code>release()</code>递减计数。当计数大于 0 时_long，保证缓冲区不被释放。当计数减少到 0 时，可以释放池化缓冲区，这实际上可能意味着缓冲区的保留 memory 返回到 memory 池。</p>
<p>请注意，不是直接在<code>PooledDataBuffer</code>上操作，在大多数情况下最好使用<code>DataBufferUtils</code>中的方便方法，只有当它是<code>PooledDataBuffer</code>的实例时才应用释放或保留到<code>DataBuffer</code>。</p>
<h3 id="8-4-DataBufferUtils"><a href="#8-4-DataBufferUtils" class="headerlink" title="8.4. DataBufferUtils"></a>8.4. DataBufferUtils</h3><p><code>DataBufferUtils</code>提供了许多实用程序方法来操作数据缓冲区：</p>
<ul>
<li>将数据缓冲区流连接到单个缓冲区，可能没有副本 e.g. 通过复合缓冲区，如果底层字节缓冲区 API 支持。</li>
<li>将<code>InputStream</code>或 NIO <code>Channel</code>转换为<code>Flux&lt;DataBuffer&gt;</code>，反之亦然<code>Publisher&lt;DataBuffer&gt;</code>转入<code>OutputStream</code>或 NIO <code>Channel</code>。</li>
<li>如果缓冲区是<code>PooledDataBuffer</code>的实例，则释放或保留<code>DataBuffer</code>的方法。</li>
<li>从字节流中跳过或取出，直到特定的字节数。</li>
</ul>
<h3 id="8-5-编解码器"><a href="#8-5-编解码器" class="headerlink" title="8.5. 编解码器"></a>8.5. 编解码器</h3><p><code>org.springframework.core.codec</code>包提供以下策略接口：</p>
<ul>
<li><code>Encoder</code>将<code>Publisher&lt;T&gt;</code>编码为数据缓冲区流。</li>
<li><code>Decoder</code>将<code>Publisher&lt;DataBuffer&gt;</code>解码为更高 level objects 的流。</li>
</ul>
<p><code>spring-core</code>模块提供<code>byte[]</code>，<code>ByteBuffer</code>，<code>DataBuffer</code>，<code>Resource</code>和<code>String</code>编码器和解码器 implementations。 <code>spring-web</code>模块添加了 Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers 和其他编码器和解码器。请参阅 WebFlux 部分中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#databuffers-buffer-pooled">编解码器</a>。</p>
<h3 id="8-6-使用-DataBuffer"><a href="#8-6-使用-DataBuffer" class="headerlink" title="8.6. 使用 DataBuffer"></a>8.6. 使用 DataBuffer</h3><p>使用数据缓冲区时，必须特别注意确保释放缓冲区，因为它们可能是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-codecs">汇集</a>。我们将使用编解码器来说明它是如何工作的，但概念更普遍适用。让我们看看内部编解码器必须在内部管理数据缓冲区。</p>
<p>在创建更高 level objects 之前，<code>Decoder</code>是读取输入数据缓冲区的最后一个，因此它必须按如下方式释放它们：</p>
<ul>
<li>如果<code>Decoder</code>只是读取每个输入缓冲区并准备立即释放它，它可以通过<code>DataBufferUtils.release(dataBuffer)</code>来实现。</li>
<li>如果<code>Decoder</code>正在使用<code>Flux</code>或<code>Mono</code> operators，例如<code>flatMap</code>，<code>reduce</code>和其他在内部预取和缓存数据项的操作符，或者正在使用<code>filter</code>，<code>skip</code>等其他省略项的操作符，则必须将<code>doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)</code>添加到组合中确保这些缓冲区在被丢弃之前被释放，也可能因此导致错误或取消信号。</li>
<li>如果<code>Decoder</code>以任何其他方式保留一个或多个数据缓冲区，则必须确保在完全读取时释放它们，或者在读取和释放高速缓存数据缓冲区之前发生错误或取消信号。</li>
</ul>
<p>请注意，<code>DataBufferUtils#join</code>提供了一种安全有效的方法，可将数据缓冲区流聚合到单个数据缓冲区中。同样，<code>skipUntilByteCount</code>和<code>takeUntilByteCount</code>是解码器使用的附加安全方法。</p>
<p><code>Encoder</code>分配其他人必须读取(和释放)的数据缓冲区。所以<code>Encoder</code>没什么可做的。但是，如果在使用数据填充缓冲区时发生序列化错误，则<code>Encoder</code>必须注意释放数据缓冲区。例如：</p>
<pre><code>DataBuffer buffer = factory.allocateBuffer();
boolean release = true;
try &#123;
    // serialize and populate buffer..
    release = false;
&#125;
finally &#123;
    if (release) &#123;
        DataBufferUtils.release(buffer);
    &#125;
&#125;
return buffer;
</code></pre>
<p>的 consumer 负责释放它接收的数据缓冲区。在 WebFlux application 中，<code>Encoder</code>的输出用于写入 HTTP 服务器响应或 client HTTP 请求，在这种情况下，释放数据缓冲区是 code 写入服务器响应或 client 的责任。请求。</p>
<p>请注意，在 Netty 上运行时，会有<a target="_blank" rel="noopener" href="https://github.com/netty/netty/wiki/Reference-counted-objects#databuffers-buffer-pooled">排除缓冲区泄漏</a>的调试选项。</p>
<h2 id="9-附录"><a href="#9-附录" class="headerlink" title="9.附录"></a>9.附录</h2><h3 id="9-1-XML-模式"><a href="#9-1-XML-模式" class="headerlink" title="9.1. XML 模式"></a>9.1. XML 模式</h3><p>附录的这一部分列出了与核心容器相关的 XML 模式。</p>
<h4 id="9-1-1-util-Schema"><a href="#9-1-1-util-Schema" class="headerlink" title="9.1.1. util Schema"></a>9.1.1. util Schema</h4><p>正如 name 所暗示的那样，<code>util</code>标签处理 common，实用程序配置问题，例如配置集合，引用常量等等。要使用<code>util</code> schema 中的标记，您需要在 Spring XML configuration 文件的顶部添加以下前导码(片段中的文本引用正确的 schema，以便<code>util</code>命名空间中的标记可供您使用)：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;

        &lt;!-- bean definitions here --&gt;
&lt;/beans&gt;
</code></pre>
<h5 id="使用-lt-hh-5534-3-gt"><a href="#使用-lt-hh-5534-3-gt" class="headerlink" title="使用&lt; hh:// +5534+ *3* &gt;"></a>使用&lt; hh:// +5534+ *3* &gt;</h5><p>考虑以下 bean 定义：</p>
<pre><code>&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;isolation&quot;&gt;
        &lt;bean id=&quot;java.sql.Connection.TRANSACTION_SERIALIZABLE&quot;
                class=&quot;org.springframework.beans.factory.config.FieldRetrievingFactoryBean&quot; /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的 configuration 使用 Spring <code>FactoryBean</code> implementation(<code>FieldRetrievingFactoryBean</code>)将 bean 上的<code>isolation</code> property 的 value 设置为<code>java.sql.Connection.TRANSACTION_SERIALIZABLE</code>常量的 value。这一切都很好，但它很冗长，并且(不必要地)将 Spring 的内部管道暴露给最终用户。</p>
<p>以下 XML Schema-based version 更简洁，清楚地表达了开发人员的意图(“_in this constant value”)，并且它读起来更好：</p>
<pre><code>&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;isolation&quot;&gt;
        &lt;util:constant static-field=&quot;java.sql.Connection.TRANSACTION_SERIALIZABLE&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h6 id="从字段-Value-设置-Bean-Property-或-Constructor-参数"><a href="#从字段-Value-设置-Bean-Property-或-Constructor-参数" class="headerlink" title="从字段 Value 设置 Bean Property 或 Constructor 参数"></a>从字段 Value 设置 Bean Property 或 Constructor 参数</h6><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html">FieldRetrievingFactoryBean</a>是<code>FactoryBean</code>，它检索<code>static</code>或 non-static 字段 value。它通常用于检索<code>public</code> <code>static</code> <code>final</code>常量，然后可以使用这些常量为另一个 bean 设置 property value 或 constructor 参数。</p>
<p>以下 example 通过使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#troubleshooting-buffer-leaks">staticField</a> property 显示如何公开<code>static</code>字段：</p>
<pre><code>&lt;bean id=&quot;myField&quot;
        class=&quot;org.springframework.beans.factory.config.FieldRetrievingFactoryBean&quot;&gt;
    &lt;property name=&quot;staticField&quot; value=&quot;java.sql.Connection.TRANSACTION_SERIALIZABLE&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>还有一个便利用法表单，其中<code>static</code>字段被指定为 bean name，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;java.sql.Connection.TRANSACTION_SERIALIZABLE&quot;
        class=&quot;org.springframework.beans.factory.config.FieldRetrievingFactoryBean&quot;/&gt;
</code></pre>
<p>这确实意味着 bean <code>id</code>不再有任何选择(因此引用它的任何其他 bean 也必须使用这个更长的 name)，但这个表单定义非常简洁，非常方便用作内部 bean 因为不必为 bean reference 指定，如下面的 example 所示：</p>
<pre><code>&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;isolation&quot;&gt;
        &lt;bean id=&quot;java.sql.Connection.TRANSACTION_SERIALIZABLE&quot;
                class=&quot;org.springframework.beans.factory.config.FieldRetrievingFactoryBean&quot; /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>您还可以访问另一个 bean 的 non-static(实例)字段，如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html">FieldRetrievingFactoryBean</a> class 的 API 文档中所述。</p>
<p>在 Spring 中将枚举值作为 property 或构造函数 arguments 注入到 beans 中很容易。你实际上不需要做任何事情或知道关于 Spring 内部的任何事情(甚至关于_c 等类的_c_)。以下 example 枚举显示了注入 enum value 是多么容易：</p>
<pre><code>package javax.persistence;

public enum PersistenceContextType &#123;

    TRANSACTION,
    EXTENDED
&#125;
</code></pre>
<p>现在考虑以下类型<code>PersistenceContextType</code>的 setter 和相应的 bean 定义：</p>
<pre><code>package example;

public class Client &#123;

    private PersistenceContextType persistenceContextType;

    public void setPersistenceContextType(PersistenceContextType type) &#123;
        this.persistenceContextType = type;
    &#125;
&#125;
</code></pre>
<pre><code>&lt;bean class=&quot;example.Client&quot;&gt;
    &lt;property name=&quot;persistenceContextType&quot; value=&quot;TRANSACTION&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="使用-lt-hh-5572-3-gt"><a href="#使用-lt-hh-5572-3-gt" class="headerlink" title="使用&lt; hh:// +5572+ *3* &gt;"></a>使用&lt; hh:// +5572+ *3* &gt;</h5><p>考虑以下 example：</p>
<pre><code>&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id=&quot;testBean&quot; class=&quot;org.springframework.beans.TestBean&quot; scope=&quot;prototype&quot;&gt;
    &lt;property name=&quot;age&quot; value=&quot;10&quot;/&gt;
    &lt;property name=&quot;spouse&quot;&gt;
        &lt;bean class=&quot;org.springframework.beans.TestBean&quot;&gt;
            &lt;property name=&quot;age&quot; value=&quot;11&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 10, which is the value of property &#39;age&#39; of bean &#39;testBean&#39; --&gt;
&lt;bean id=&quot;testBean.age&quot; class=&quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;/&gt;
</code></pre>
<p>前面的 configuration 使用 Spring <code>FactoryBean</code> implementation(<code>PropertyPathFactoryBean</code>)来创建一个 bean(类型为<code>int</code>)，名为<code>testBean.age</code>，其 value 等于<code>testBean</code> bean 的<code>age</code> property。</p>
<p>现在考虑以下 example，它添加一个<code>&lt;util:property-path/&gt;</code>元素：</p>
<pre><code>&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id=&quot;testBean&quot; class=&quot;org.springframework.beans.TestBean&quot; scope=&quot;prototype&quot;&gt;
    &lt;property name=&quot;age&quot; value=&quot;10&quot;/&gt;
    &lt;property name=&quot;spouse&quot;&gt;
        &lt;bean class=&quot;org.springframework.beans.TestBean&quot;&gt;
            &lt;property name=&quot;age&quot; value=&quot;11&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 10, which is the value of property &#39;age&#39; of bean &#39;testBean&#39; --&gt;
&lt;util:property-path id=&quot;name&quot; path=&quot;testBean.age&quot;/&gt;
</code></pre>
<p><code>&lt;property-path/&gt;</code>元素的<code>path</code>属性的 value 遵循<code>beanName.beanProperty</code>的形式。在这种情况下，它会选择名为<code>testBean</code>的 bean 的<code>age</code> property。 <code>age</code> property 的 value 是<code>10</code>。</p>
<h6 id="使用-lt-hh-5591-3-gt-设置-Bean-Property-或-Constructor-Argument"><a href="#使用-lt-hh-5591-3-gt-设置-Bean-Property-或-Constructor-Argument" class="headerlink" title="使用&lt; hh:// +5591+ *3* &gt;设置 Bean Property 或 Constructor Argument"></a>使用&lt; hh:// +5591+ *3* &gt;设置 Bean Property 或 Constructor Argument</h6><p><code>PropertyPathFactoryBean</code>是<code>FactoryBean</code>，它评估给定目标 object 上的 property 路径。目标 object 可以直接指定，也可以由 bean name 指定。然后，您可以在另一个 bean 定义中将此 value 用作 property value 或 constructor 参数。</p>
<p>以下 example 显示了一个用于另一个 bean 的路径，由 name：</p>
<pre><code>// target bean to be referenced by name
&lt;bean id=&quot;person&quot; class=&quot;org.springframework.beans.TestBean&quot; scope=&quot;prototype&quot;&gt;
    &lt;property name=&quot;age&quot; value=&quot;10&quot;/&gt;
    &lt;property name=&quot;spouse&quot;&gt;
        &lt;bean class=&quot;org.springframework.beans.TestBean&quot;&gt;
            &lt;property name=&quot;age&quot; value=&quot;11&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

// results in 11, which is the value of property &#39;spouse.age&#39; of bean &#39;person&#39;
&lt;bean id=&quot;theAge&quot;
        class=&quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;&gt;
    &lt;property name=&quot;targetBeanName&quot; value=&quot;person&quot;/&gt;
    &lt;property name=&quot;propertyPath&quot; value=&quot;spouse.age&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>在下面的示例中，将针对内部 bean 评估路径：</p>
<pre><code>&lt;!-- results in 12, which is the value of property &#39;age&#39; of the inner bean --&gt;
&lt;bean id=&quot;theAge&quot;
        class=&quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;&gt;
    &lt;property name=&quot;targetObject&quot;&gt;
        &lt;bean class=&quot;org.springframework.beans.TestBean&quot;&gt;
            &lt;property name=&quot;age&quot; value=&quot;12&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;propertyPath&quot; value=&quot;age&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>还有一个快捷方式表单，其中 bean name 是 property 路径。以下 example 显示了快捷方式：</p>
<pre><code>&lt;!-- results in 10, which is the value of property &#39;age&#39; of bean &#39;person&#39; --&gt;
&lt;bean id=&quot;person.age&quot;
        class=&quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;/&gt;
</code></pre>
<p>这个表单确实意味着 bean 的 name 中没有选择。任何 reference 它也必须使用相同的<code>id</code>，这是路径。如果用作内部 bean，则根本不需要引用它，如下面的示例所示：</p>
<pre><code>&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;age&quot;&gt;
        &lt;bean id=&quot;person.age&quot;
                class=&quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>您可以在实际定义中专门设置结果类型。对于大多数用例来说，这不是必需的，但它有时可能很有用。有关此 feature 的更多信息，请参阅 javadoc。</p>
<h5 id="使用-lt-hh-5603-3-gt"><a href="#使用-lt-hh-5603-3-gt" class="headerlink" title="使用&lt; hh:// +5603+ *3* &gt;"></a>使用&lt; hh:// +5603+ *3* &gt;</h5><p>考虑以下 example：</p>
<pre><code>&lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;
&lt;bean id=&quot;jdbcConfiguration&quot; class=&quot;org.springframework.beans.factory.config.PropertiesFactoryBean&quot;&gt;
    &lt;property name=&quot;location&quot; value=&quot;classpath:com/foo/jdbc-production.properties&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的 configuration 使用 Spring <code>FactoryBean</code> implementation(<code>PropertiesFactoryBean</code>)来实例化一个<code>java.util.Properties</code>实例，其值从提供的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#setStaticField(java.lang.String)">资源</a>位置加载。</p>
<p>以下 example 使用<code>util:properties</code>元素来表示更简洁的表示：</p>
<pre><code>&lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;
&lt;util:properties id=&quot;jdbcConfiguration&quot; location=&quot;classpath:com/foo/jdbc-production.properties&quot;/&gt;
</code></pre>
<h5 id="使用-lt-hh-5614-3-gt"><a href="#使用-lt-hh-5614-3-gt" class="headerlink" title="使用&lt; hh:// +5614+ *3* &gt;"></a>使用&lt; hh:// +5614+ *3* &gt;</h5><p>考虑以下 example：</p>
<pre><code>&lt;!-- creates a java.util.List instance with values loaded from the supplied &#39;sourceList&#39; --&gt;
&lt;bean id=&quot;emails&quot; class=&quot;org.springframework.beans.factory.config.ListFactoryBean&quot;&gt;
    &lt;property name=&quot;sourceList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的 configuration 使用 Spring <code>FactoryBean</code> implementation(<code>ListFactoryBean</code>)来创建<code>java.util.List</code>实例，并使用从提供的<code>sourceList</code>获取的值对其进行初始化。</p>
<p>以下 example 使用<code>&lt;util:list/&gt;</code>元素来表示更简洁的表示：</p>
<pre><code>&lt;!-- creates a java.util.List instance with the supplied values --&gt;
&lt;util:list id=&quot;emails&quot;&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
&lt;/util:list&gt;
</code></pre>
<p>您还可以使用<code>&lt;util:list/&gt;</code>元素上的<code>list-class</code>属性显式控制实例化和填充的<code>List</code>的确切类型。例如，如果我们确实需要实例化<code>java.util.LinkedList</code>，我们可以使用以下 configuration：</p>
<pre><code>&lt;util:list id=&quot;emails&quot; list-class=&quot;java.util.LinkedList&quot;&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;d&#39;[emailprotected]&lt;/value&gt;
&lt;/util:list&gt;
</code></pre>
<p>如果未提供<code>list-class</code>属性，则容器将选择<code>List</code> implementation。</p>
<h5 id="使用-lt-hh-5632-3-gt"><a href="#使用-lt-hh-5632-3-gt" class="headerlink" title="使用&lt; hh:// +5632+ *3* &gt;"></a>使用&lt; hh:// +5632+ *3* &gt;</h5><p>考虑以下 example：</p>
<pre><code>&lt;!-- creates a java.util.Map instance with values loaded from the supplied &#39;sourceMap&#39; --&gt;
&lt;bean id=&quot;emails&quot; class=&quot;org.springframework.beans.factory.config.MapFactoryBean&quot;&gt;
    &lt;property name=&quot;sourceMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;pechorin&quot; value=&quot;[emailprotected]&quot;/&gt;
            &lt;entry key=&quot;raskolnikov&quot; value=&quot;[emailprotected]&quot;/&gt;
            &lt;entry key=&quot;stavrogin&quot; value=&quot;[emailprotected]&quot;/&gt;
            &lt;entry key=&quot;porfiry&quot; value=&quot;[emailprotected]&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的 configuration 使用 Spring <code>FactoryBean</code> implementation(<code>MapFactoryBean</code>)来创建一个<code>java.util.Map</code>实例，该实例使用从提供的<code>&#39;sourceMap&#39;</code>获取的 key-value 对进行初始化。</p>
<p>以下 example 使用<code>&lt;util:map/&gt;</code>元素来表示更简洁的表示：</p>
<pre><code>&lt;!-- creates a java.util.Map instance with the supplied key-value pairs --&gt;
&lt;util:map id=&quot;emails&quot;&gt;
    &lt;entry key=&quot;pechorin&quot; value=&quot;[emailprotected]&quot;/&gt;
    &lt;entry key=&quot;raskolnikov&quot; value=&quot;[emailprotected]&quot;/&gt;
    &lt;entry key=&quot;stavrogin&quot; value=&quot;[emailprotected]&quot;/&gt;
    &lt;entry key=&quot;porfiry&quot; value=&quot;[emailprotected]&quot;/&gt;
&lt;/util:map&gt;
</code></pre>
<p>您还可以使用<code>&lt;util:map/&gt;</code>元素上的<code>&#39;map-class&#39;</code>属性显式控制实例化和填充的<code>Map</code>的确切类型。例如，如果我们确实需要实例化<code>java.util.TreeMap</code>，我们可以使用以下 configuration：</p>
<pre><code>&lt;util:map id=&quot;emails&quot; map-class=&quot;java.util.TreeMap&quot;&gt;
    &lt;entry key=&quot;pechorin&quot; value=&quot;[emailprotected]&quot;/&gt;
    &lt;entry key=&quot;raskolnikov&quot; value=&quot;[emailprotected]&quot;/&gt;
    &lt;entry key=&quot;stavrogin&quot; value=&quot;[emailprotected]&quot;/&gt;
    &lt;entry key=&quot;porfiry&quot; value=&quot;[emailprotected]&quot;/&gt;
&lt;/util:map&gt;
</code></pre>
<p>如果未提供<code>&#39;map-class&#39;</code>属性，则容器将选择<code>Map</code> implementation。</p>
<h5 id="使用-lt-hh-5650-3-gt"><a href="#使用-lt-hh-5650-3-gt" class="headerlink" title="使用&lt; hh:// +5650+ *3* &gt;"></a>使用&lt; hh:// +5650+ *3* &gt;</h5><p>考虑以下 example：</p>
<pre><code>&lt;!-- creates a java.util.Set instance with values loaded from the supplied &#39;sourceSet&#39; --&gt;
&lt;bean id=&quot;emails&quot; class=&quot;org.springframework.beans.factory.config.SetFactoryBean&quot;&gt;
    &lt;property name=&quot;sourceSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
            &lt;value&gt;[emailprotected]&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>前面的 configuration 使用 Spring <code>FactoryBean</code> implementation(<code>SetFactoryBean</code>)来创建一个<code>java.util.Set</code>实例，该实例使用从提供的<code>sourceSet</code>获取的值进行初始化。</p>
<p>以下 example 使用<code>&lt;util:set/&gt;</code>元素来表示更简洁的表示：</p>
<pre><code>&lt;!-- creates a java.util.Set instance with the supplied values --&gt;
&lt;util:set id=&quot;emails&quot;&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
&lt;/util:set&gt;
</code></pre>
<p>您还可以使用<code>&lt;util:set/&gt;</code>元素上的<code>set-class</code>属性显式控制实例化和填充的<code>Set</code>的确切类型。例如，如果我们确实需要实例化<code>java.util.TreeSet</code>，我们可以使用以下 configuration：</p>
<pre><code>&lt;util:set id=&quot;emails&quot; set-class=&quot;java.util.TreeSet&quot;&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
    &lt;value&gt;[emailprotected]&lt;/value&gt;
&lt;/util:set&gt;
</code></pre>
<p>如果未提供<code>set-class</code>属性，则容器将选择<code>Set</code> implementation。</p>
<h4 id="9-1-2-aop-Schema"><a href="#9-1-2-aop-Schema" class="headerlink" title="9.1.2. aop Schema"></a>9.1.2. aop Schema</h4><p><code>aop</code>标签用于配置 Spring 中的所有 AOP，包括使用 AspectJ AOP framework 的 Spring 自己的 proxy-based AOP framework 和 Spring 的 integration。这些标签在题为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources">使用 Spring 进行面向对象编程</a>的章节中全面介绍。</p>
<p>为了完整性，要使用<code>aop</code> schema 中的标记，您需要在 Spring XML configuration 文件的顶部放置以下前导码(片段中的文本引用正确的 schema，以便<code>aop</code>命名空间中的标记为你可以得到)：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!-- bean definitions here --&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="9-1-3-context-Schema"><a href="#9-1-3-context-Schema" class="headerlink" title="9.1.3. context Schema"></a>9.1.3. context Schema</h4><p><code>context</code>标签处理与管道相关的<code>ApplicationContext</code> configuration - 也就是说，通常不是 beans 对 end-user 很重要，而是 beans 在 Spring 中执行很多“咕噜”工作，比如<code>BeanfactoryPostProcessors</code>。以下代码段 references 正确的 schema，以便<code>context</code>命名空间中的元素可供您使用：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- bean definitions here --&gt;
&lt;/beans&gt;
</code></pre>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用<property-placeholder/></h5><p>此元素激活<code>$&#123;…&#125;</code>占位符的替换，这些占位符是针对指定的 properties 文件(作为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">Spring 资源位置</a>)解析的。这个元素是一个方便的机制，为你设置一个<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources">PropertyPlaceholderConfigurer</a>。如果您需要更多地控制<code>PropertyPlaceholderConfigurer</code>，您可以自己明确定义一个。</p>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用<annotation-config/></h5><p>此元素激活 Spring 基础结构以检测 bean classes 中的 annotations：</p>
<ul>
<li>Spring 的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-placeholderconfigurer">@Required</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-required-annotation">@Autowired</a></li>
<li>JSR 250 的<code>@PostConstruct</code>，<code>@PreDestroy</code>和<code>@Resource</code>(如果有的话)</li>
<li>JPA 的<code>@PersistenceContext</code>和<code>@PersistenceUnit</code>(如果可用)。</li>
</ul>
<p>或者，您可以选择为那些注释显式激活单个<code>BeanPostProcessors</code>。</p>
<blockquote>
<p>此元素不会激活 Spring 的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#beans-annotation-config">@Transactional</a> annotation 的处理。您可以将<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative-annotations">&lt; *1* &gt;</a>元素用于此目的。</p>
</blockquote>
<h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用<component-scan/></h5><p>这个元素在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#tx-decl-explained">Annotation-based container configuration</a>中有详细说明。</p>
<h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用<load-time-weaver/></h5><p>这个元素在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config">Load-time 在 Spring Framework 中使用 AspectJ 进行编织</a>中有详细说明。</p>
<h5 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用<spring-configured/></h5><p>这个元素在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">使用 AspectJ 依赖 inject 域 objects 与 Spring</a>中有详细说明。</p>
<h5 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用<mbean-export/></h5><p>这个元素在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#aop-atconfigurable">配置基于 annotation 的 MBean export</a>中有详细说明。</p>
<h4 id="9-1-4-Beans-Schema"><a href="#9-1-4-Beans-Schema" class="headerlink" title="9.1.4. Beans Schema"></a>9.1.4. Beans Schema</h4><p>最后但同样重要的是，我们在<code>beans</code> schema 中有元素。自 framework 出现以来，这些元素一直存在于 Spring 中。这里没有显示<code>beans</code> schema 中各种元素的示例，因为它们在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#jmx-context-mbeanexport">依赖关系和 configuration 详细</a>(实际上，整个<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-properties-detailed">章节</a>)中得到了相当全面的介绍。</p>
<p>请注意，您可以向<code>&lt;bean/&gt;</code> XML 定义添加零个或多个 key-value 对。如果有的话，使用这些额外的元数据完成的工作完全取决于您自己的自定义逻辑(因此，如果您按照标题为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans">XML Schema Authoring</a>的附录中所述编写自己的自定义元素，通常只会使用它。</p>
<p>下面的 example 显示了周围<code>&lt;bean/&gt;</code>的 context 中的<code>&lt;meta/&gt;</code>元素(请注意，没有任何逻辑可以解释它，元数据实际上是无用的)。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;foo&quot; class=&quot;x.y.Foo&quot;&gt;
        &lt;meta key=&quot;cacheName&quot; value=&quot;foo&quot;/&gt; (1)
        &lt;property name=&quot;name&quot; value=&quot;Rick&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>这是 example <code>meta</code>元素</td>
</tr>
</tbody></table>
<p>在前面的 example 的情况下，您可以假设有一些逻辑使用 bean 定义并设置一些使用提供的元数据的缓存基础结构。</p>
<h3 id="9-2-XML-Schema-Authoring"><a href="#9-2-XML-Schema-Authoring" class="headerlink" title="9.2. XML Schema Authoring"></a>9.2. XML Schema Authoring</h3><p>自 version 2.0 以来，Spring 具有一种机制，可以将 schema-based extensions 添加到基本的 Spring XML 格式，以便定义和配置 beans。本节介绍如何编写自己的自定义 XML bean 定义解析器，并将这些解析器集成到 Spring IoC 容器中。</p>
<p>为了便于创作使用 schema-aware XML 编辑器的 configuration files，Spring 的可扩展 XML configuration 机制基于 XML Schema。如果您不熟悉标准 Spring 发行版附带的 Spring 当前的 XML configuration extensions，则应首先阅读标题为[<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xml-custom">xsd-config]</a>的附录。</p>
<p>要创建新的 XML configuration extensions：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-config">作者</a>用于描述自定义 element(s 的 XML schema。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-schema">码</a>自定义<code>NamespaceHandler</code> 实现。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-namespacehandler">码</a>一个或多个<code>BeanDefinitionParser</code> __mplement(这是真正的工作完成的地方)。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-parser">寄存器</a>你的新 artifacts 与 Spring。</li>
</ul>
<p>对于统一的 example，我们创建了一个 XML 扩展(一个自定义 XML 元素)，它允许我们配置<code>SimpleDateFormat</code>类型的 objects(来自<code>java.text</code>包)。完成后，我们将能够定义<code>SimpleDateFormat</code>类型的 bean 定义，如下所示：</p>
<pre><code>&lt;myns:dateformat id=&quot;dateFormat&quot;
    pattern=&quot;yyyy-MM-dd HH:mm&quot;
    lenient=&quot;true&quot;/&gt;
</code></pre>
<p>(我们在本附录中稍后会包含更详细的示例.第一个简单示例的目的是引导您完成制作自定义的基本步骤 extension.)</p>
<h4 id="9-2-1-创作-Schema"><a href="#9-2-1-创作-Schema" class="headerlink" title="9.2.1. 创作 Schema"></a>9.2.1. 创作 Schema</h4><p>创建用于 Spring 的 IoC 容器的 XML configuration 扩展，首先创建一个 XML Schema 来描述扩展。对于我们的 example，我们使用以下 schema 来配置<code>SimpleDateFormat</code> objects：</p>
<pre><code>&lt;!-- myns.xsd (inside package org/springframework/samples/xml) --&gt;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xsd:schema xmlns=&quot;http://www.mycompany.com/schema/myns&quot;
        xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
        xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot;
        targetNamespace=&quot;http://www.mycompany.com/schema/myns&quot;
        elementFormDefault=&quot;qualified&quot;
        attributeFormDefault=&quot;unqualified&quot;&gt;

    &lt;xsd:import namespace=&quot;http://www.springframework.org/schema/beans&quot;/&gt;

    &lt;xsd:element name=&quot;dateformat&quot;&gt;
        &lt;xsd:complexType&gt;
            &lt;xsd:complexContent&gt;
                &lt;xsd:extension base=&quot;beans:identifiedType&quot;&gt; (1)
                    &lt;xsd:attribute name=&quot;lenient&quot; type=&quot;xsd:boolean&quot;/&gt;
                    &lt;xsd:attribute name=&quot;pattern&quot; type=&quot;xsd:string&quot; use=&quot;required&quot;/&gt;
                &lt;/xsd:extension&gt;
            &lt;/xsd:complexContent&gt;
        &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
&lt;/xsd:schema&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>指示的 line 包含所有可识别标记的扩展名基础(意味着它们具有<code>id</code>属性，我们可以将其用作容器中的 bean 标识符)。我们可以使用此属性，因为我们导入了 Spring-provided <code>beans</code>命名空间。</td>
</tr>
</tbody></table>
<p>前面的 schema 允许我们使用<code>&lt;myns:dateformat/&gt;</code>元素直接在 XML application context 文件中配置<code>SimpleDateFormat</code> objects，如下面的 example 所示：</p>
<pre><code>&lt;myns:dateformat id=&quot;dateFormat&quot;
    pattern=&quot;yyyy-MM-dd HH:mm&quot;
    lenient=&quot;true&quot;/&gt;
</code></pre>
<p>请注意，在我们创建了基础结构 classes 之后，前面的 XML 代码段基本上与以下 XML 代码段相同：</p>
<pre><code>&lt;bean id=&quot;dateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt;
    &lt;constructor-arg value=&quot;yyyy-HH-dd HH:mm&quot;/&gt;
    &lt;property name=&quot;lenient&quot; value=&quot;true&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>前两个片段中的第二个在容器中创建 bean(由<code>SimpleDateFormat</code>类型的 name <code>dateFormat</code>标识)，并设置了几个 properties。</p>
<blockquote>
<p>方法 creating configuration 格式允许使用具有 schema-aware XML 编辑器的 IDE 进行紧密整合。通过使用正确创作的 schema，您可以使用自动完成功能让用户在枚举中定义的几个 configuration 选项之间进行选择。</p>
</blockquote>
<h4 id="9-2-2-编码-NamespaceHandler"><a href="#9-2-2-编码-NamespaceHandler" class="headerlink" title="9.2.2. 编码 NamespaceHandler"></a>9.2.2. 编码 NamespaceHandler</h4><p>除了 schema 之外，我们还需要一个<code>NamespaceHandler</code>来解析 Spring 在解析 configuration files 时遇到的这个特定命名空间的所有元素。对于这个例子，<code>NamespaceHandler</code>应该处理<code>myns:dateformat</code>元素的解析。</p>
<p><code>NamespaceHandler</code>接口 features 有三种方法：</p>
<ul>
<li><code>init()</code>：允许初始化<code>NamespaceHandler</code>，并在使用处理程序之前由 Spring 调用。</li>
<li><code>BeanDefinition parse(Element, ParserContext)</code>：Spring 遇到 top-level 元素时调用(不嵌套在 bean 定义或不同的命名空间内)。此方法本身可以注册 bean 定义，return bean 定义，或两者。</li>
<li><code>BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)</code>：当 Spring 遇到不同命名空间的属性或嵌套元素时调用。使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-registration">Spring 支持的范围</a>(对于 example)使用一个或多个 bean 定义的修饰。我们首先突出显示一个简单的 example，不使用装饰，之后我们在一个更高级的 example 中显示装饰。</li>
</ul>
<p>虽然您可以为整个命名空间编码自己的<code>NamespaceHandler</code>(因此提供解析命名空间中每个元素的 code)，但通常情况是 Spring XML configuration 文件中的每个 top-level XML 元素都会产生一个 bean 定义(就像在我们的例子中，单个<code>&lt;myns:dateformat/&gt;</code>元素导致单个<code>SimpleDateFormat</code> bean 定义)。 Spring features 支持这种情况的许多便利 classes。在下面的示例中，我们使用<code>NamespaceHandlerSupport</code> class：</p>
<pre><code>package org.springframework.samples.xml;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class MyNamespaceHandler extends NamespaceHandlerSupport &#123;

    public void init() &#123;
        registerBeanDefinitionParser(&quot;dateformat&quot;, new SimpleDateFormatBeanDefinitionParser());
    &#125;

&#125;
</code></pre>
<p>你可能会注意到这个 class 中实际上并没有很多解析逻辑。实际上，<code>NamespaceHandlerSupport</code> class 有一个 built-in 授权概念。它支持在需要解析其名称空间中的元素时注册任意数量的<code>BeanDefinitionParser</code>实例。这种干净的关注分离让<code>NamespaceHandler</code>处理其命名空间中所有自定义元素的解析编排，同时委托<code>BeanDefinitionParsers</code>来完成 XML 解析的繁重工作。这意味着每个<code>BeanDefinitionParser</code>只包含解析单个自定义元素的逻辑，我们可以在下一个 step 中看到。</p>
<h4 id="9-2-3-使用-BeanDefinitionParser"><a href="#9-2-3-使用-BeanDefinitionParser" class="headerlink" title="9.2.3. 使用 BeanDefinitionParser"></a>9.2.3. 使用 BeanDefinitionParser</h4><p>如果<code>NamespaceHandler</code>遇到已映射到特定 bean 定义解析器的类型的 XML 元素(在本例中为<code>dateformat</code>)，则使用<code>BeanDefinitionParser</code>。换句话说，<code>BeanDefinitionParser</code>负责解析 schema 中定义的一个不同的 top-level XML 元素。在解析器中，我们可以访问 XML 元素(以及它的子元素)，以便我们可以解析自定义 XML 内容，如下面的示例所示：</p>
<pre><code>package org.springframework.samples.xml;

import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.util.StringUtils;
import org.w3c.dom.Element;

import java.text.SimpleDateFormat;

public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser &#123; (1)

    protected Class getBeanClass(Element element) &#123;
        return SimpleDateFormat.class; (2)
    &#125;

    protected void doParse(Element element, BeanDefinitionBuilder bean) &#123;
        // this will never be null since the schema explicitly requires that a value be supplied
        String pattern = element.getAttribute(&quot;pattern&quot;);
        bean.addConstructorArg(pattern);

        // this however is an optional property
        String lenient = element.getAttribute(&quot;lenient&quot;);
        if (StringUtils.hasText(lenient)) &#123;
            bean.addPropertyValue(&quot;lenient&quot;, Boolean.valueOf(lenient));
        &#125;
    &#125;

&#125;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>我们使用 Spring-provided <code>AbstractSingleBeanDefinitionParser</code>来处理 creating 单个<code>BeanDefinition</code>的许多基本 grunt 工作。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>我们为<code>AbstractSingleBeanDefinitionParser</code>超类提供单个<code>BeanDefinition</code>所代表的类型。</td>
</tr>
</tbody></table>
<p>在这个简单的例子中，这就是我们需要做的一切。我们的单个<code>BeanDefinition</code>的创建由<code>AbstractSingleBeanDefinitionParser</code>超类处理，bean 定义的唯一标识符的提取和设置也是如此。</p>
<h4 id="9-2-4-注册-Handler-和-Schema"><a href="#9-2-4-注册-Handler-和-Schema" class="headerlink" title="9.2.4. 注册 Handler 和 Schema"></a>9.2.4. 注册 Handler 和 Schema</h4><p>编码完成。剩下要做的就是让 Spring XML 解析基础架构了解我们的自定义元素。我们通过在两个 special-purpose properties files 中注册我们的自定义<code>namespaceHandler</code>和自定义 XSD 文件来实现。这些 properties files 都放在 application 的<code>META-INF</code>目录中，对于 example，可以与 JAR 文件中的二进制 class 一起分发。 Spring XML 解析基础架构通过 consuming 这些特殊的 properties files 自动选择你的新扩展，其格式将在接下来的两节中详细介绍。</p>
<h5 id="写作-META-INF-spring-handlers"><a href="#写作-META-INF-spring-handlers" class="headerlink" title="写作 META-INF/spring.handlers"></a>写作 META-INF/spring.handlers</h5><p>名为<code>spring.handlers</code>的 properties 文件包含 XML Schema URI 到名称空间处理程序 classes 的映射。对于我们的 example，我们需要编写以下内容：</p>
<pre><code>http\://www.mycompany.com/schema/myns=org.springframework.samples.xml.MyNamespaceHandler
</code></pre>
<p>(<code>:</code>字符是 Java properties 格式的有效分隔符，因此 URI 中的<code>:</code>字符需要使用 backslash.)进行转义</p>
<p>key-value 对的第一部分(key)是与自定义命名空间扩展相关联的 URI，需要完全匹配<code>targetNamespace</code>属性的 value，如自定义 XSD schema 中指定的那样。</p>
<h5 id="写’META-INF-spring-schemas’"><a href="#写’META-INF-spring-schemas’" class="headerlink" title="写’META-INF/spring.schemas’"></a>写’META-INF/spring.schemas’</h5><p>名为<code>spring.schemas</code>的 properties 文件包含 XML Schema 位置的映射(与 schema 声明一起使用 schema 作为<code>xsi:schemaLocation</code>属性的一部分的 XML files)与 classpath 资源的映射。需要此文件来防止 Spring 绝对必须使用需要 Internet 访问权限的默认<code>EntityResolver</code>才能检索 schema 文件。如果在此 properties 文件中指定映射，Spring 将在 classpath 上搜索 schema(在本例中为<code>org.springframework.samples.xml</code>包中的<code>myns.xsd</code>)。以下代码段显示了我们需要为自定义 schema 添加的 line：</p>
<pre><code>http\://www.mycompany.com/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd
</code></pre>
<p>(请记住，<code>:</code>字符必须是 escaped.)</p>
<p>建议您在 classpath 上的<code>NamespaceHandler</code>和<code>BeanDefinitionParser</code> classes 旁边部署 XSD 文件(或 files)。</p>
<h4 id="9-2-5-在-Spring-XML-Configuration-中使用自定义扩展"><a href="#9-2-5-在-Spring-XML-Configuration-中使用自定义扩展" class="headerlink" title="9.2.5. 在 Spring XML Configuration 中使用自定义扩展"></a>9.2.5. 在 Spring XML Configuration 中使用自定义扩展</h4><p>使用自己实现的自定义扩展与使用 Spring 提供的“自定义”extensions 没有什么不同。以下 example 使用 Spring XML configuration 文件中前面步骤中开发的自定义<code>&lt;dateformat/&gt;</code>元素：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:myns=&quot;http://www.mycompany.com/schema/myns&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.mycompany.com/schema/myns http://www.mycompany.com/schema/myns/myns.xsd&quot;&gt;

    &lt;!-- as a top-level bean --&gt;
    &lt;myns:dateformat id=&quot;defaultDateFormat&quot; pattern=&quot;yyyy-MM-dd HH:mm&quot; lenient=&quot;true&quot;/&gt; (1)

    &lt;bean id=&quot;jobDetailTemplate&quot; abstract=&quot;true&quot;&gt;
        &lt;property name=&quot;dateFormat&quot;&gt;
            &lt;!-- as an inner bean --&gt;
            &lt;myns:dateformat pattern=&quot;HH:mm MM-dd-yyyy&quot;/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>我们的自定义 bean。</td>
</tr>
</tbody></table>
<h4 id="9-2-6-更详细的例子"><a href="#9-2-6-更详细的例子" class="headerlink" title="9.2.6. 更详细的例子"></a>9.2.6. 更详细的例子</h4><p>本节介绍自定义 XML extensions 的一些更详细的示例。</p>
<h5 id="在自定义元素中嵌套自定义元素"><a href="#在自定义元素中嵌套自定义元素" class="headerlink" title="在自定义元素中嵌套自定义元素"></a>在自定义元素中嵌套自定义元素</h5><p>本节中提供的 example 显示了如何编写满足以下 configuration 目标所需的各种 artifact：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:foo=&quot;http://www.foo.com/schema/component&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.foo.com/schema/component http://www.foo.com/schema/component/component.xsd&quot;&gt;

    &lt;foo:component id=&quot;bionic-family&quot; name=&quot;Bionic-1&quot;&gt;
        &lt;foo:component name=&quot;Mother-1&quot;&gt;
            &lt;foo:component name=&quot;Karate-1&quot;/&gt;
            &lt;foo:component name=&quot;Sport-1&quot;/&gt;
        &lt;/foo:component&gt;
        &lt;foo:component name=&quot;Rock-1&quot;/&gt;
    &lt;/foo:component&gt;

&lt;/beans&gt;
</code></pre>
<p>前面的 configuration 将自定义 extensions 嵌套在一起。 <code>&lt;foo:component/&gt;</code>元素实际配置的 class 是<code>Component</code> class(显示在下一个 example 中)。注意<code>Component</code> class 如何不公开<code>components</code> property 的 setter 方法。这使得使用 setter 注入为<code>Component</code> class 配置 bean 定义变得困难(或者更不可能)。以下清单显示了<code>Component</code> class：</p>
<pre><code>package com.foo;

import java.util.ArrayList;
import java.util.List;

public class Component &#123;

    private String name;
    private List&lt;Component&gt; components = new ArrayList&lt;Component&gt; ();

    // mmm, there is no setter method for the &#39;components&#39;
    public void addComponent(Component component) &#123;
        this.components.add(component);
    &#125;

    public List&lt;Component&gt; getComponents() &#123;
        return components;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

&#125;
</code></pre>
<p>此问题的典型解决方案是创建一个自定义<code>FactoryBean</code>，为<code>components</code> property 公开 setter property。以下清单显示了这样的自定义<code>FactoryBean</code>：</p>
<pre><code>package com.foo;

import org.springframework.beans.factory.FactoryBean;

import java.util.List;

public class ComponentFactoryBean implements FactoryBean&lt;Component&gt; &#123;

    private Component parent;
    private List&lt;Component&gt; children;

    public void setParent(Component parent) &#123;
        this.parent = parent;
    &#125;

    public void setChildren(List&lt;Component&gt; children) &#123;
        this.children = children;
    &#125;

    public Component getObject() throws Exception &#123;
        if (this.children != null &amp;&amp; this.children.size() &gt; 0) &#123;
            for (Component child : children) &#123;
                this.parent.addComponent(child);
            &#125;
        &#125;
        return this.parent;
    &#125;

    public Class&lt;Component&gt; getObjectType() &#123;
        return Component.class;
    &#125;

    public boolean isSingleton() &#123;
        return true;
    &#125;

&#125;
</code></pre>
<p>这很好用，但它向最终用户公开了很多 Spring 管道。我们要做的是编写一个自定义扩展，隐藏所有这些 Spring 管道。如果我们坚持<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">前面描述的步骤</a>，我们首先通过创建 XSD schema 来定义自定义标记的结构，如下面的清单所示：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;

&lt;xsd:schema xmlns=&quot;http://www.foo.com/schema/component&quot;
        xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
        targetNamespace=&quot;http://www.foo.com/schema/component&quot;
        elementFormDefault=&quot;qualified&quot;
        attributeFormDefault=&quot;unqualified&quot;&gt;

    &lt;xsd:element name=&quot;component&quot;&gt;
        &lt;xsd:complexType&gt;
            &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
                &lt;xsd:element ref=&quot;component&quot;/&gt;
            &lt;/xsd:choice&gt;
            &lt;xsd:attribute name=&quot;id&quot; type=&quot;xsd:ID&quot;/&gt;
            &lt;xsd:attribute name=&quot;name&quot; use=&quot;required&quot; type=&quot;xsd:string&quot;/&gt;
        &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;

&lt;/xsd:schema&gt;
</code></pre>
<p>再次关注<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-introduction">前面描述的 process</a>，然后我们创建一个自定义<code>NamespaceHandler</code>：</p>
<pre><code>package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class ComponentNamespaceHandler extends NamespaceHandlerSupport &#123;

    public void init() &#123;
        registerBeanDefinitionParser(&quot;component&quot;, new ComponentBeanDefinitionParser());
    &#125;

&#125;
</code></pre>
<p>接下来是自定义<code>BeanDefinitionParser</code>。请记住，我们正在创建描述<code>ComponentFactoryBean</code>的<code>BeanDefinition</code>。以下清单显示了我们的自定义<code>BeanDefinitionParser</code>：</p>
<pre><code>package com.foo;

import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;

import java.util.List;

public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser &#123;

    protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) &#123;
        return parseComponentElement(element);
    &#125;

    private static AbstractBeanDefinition parseComponentElement(Element element) &#123;
        BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);
        factory.addPropertyValue(&quot;parent&quot;, parseComponent(element));

        List&lt;Element&gt; childElements = DomUtils.getChildElementsByTagName(element, &quot;component&quot;);
        if (childElements != null &amp;&amp; childElements.size() &gt; 0) &#123;
            parseChildComponents(childElements, factory);
        &#125;

        return factory.getBeanDefinition();
    &#125;

    private static BeanDefinition parseComponent(Element element) &#123;
        BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);
        component.addPropertyValue(&quot;name&quot;, element.getAttribute(&quot;name&quot;));
        return component.getBeanDefinition();
    &#125;

    private static void parseChildComponents(List&lt;Element&gt; childElements, BeanDefinitionBuilder factory) &#123;
        ManagedList&lt;BeanDefinition&gt; children = new ManagedList&lt;BeanDefinition&gt;(childElements.size());
        for (Element element : childElements) &#123;
            children.add(parseComponentElement(element));
        &#125;
        factory.addPropertyValue(&quot;children&quot;, children);
    &#125;

&#125;
</code></pre>
<p>最后，通过修改<code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code> files，需要在 Spring XML 基础结构中注册各种 artifact，如下所示：</p>
<pre><code># in &#39;META-INF/spring.handlers&#39;
http\://www.foo.com/schema/component=com.foo.ComponentNamespaceHandler
</code></pre>
<pre><code># in &#39;META-INF/spring.schemas&#39;
http\://www.foo.com/schema/component/component.xsd=com/foo/component.xsd
</code></pre>
<h5 id="“普通”元素的自定义属性"><a href="#“普通”元素的自定义属性" class="headerlink" title="“普通”元素的自定义属性"></a>“普通”元素的自定义属性</h5><p>编写自己的自定义解析器和关联的 artifacts 并不难。但是，有时这不是正确的做法。考虑需要向现有 bean 定义添加元数据的场景。在这种情况下，您当然不希望编写自己的整个自定义扩展。相反，您只想在现有的 bean 定义元素中添加其他属性。</p>
<p>通过另一个例子，假设您为服务 object 定义 bean 定义(对它来说是未知的)访问集群<a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=107">JCache</a>，并且您希望确保在周围的 cluster 中急切地启动命名的 JCache 实例。以下清单显示了这样一个定义：</p>
<pre><code>&lt;bean id=&quot;checkingAccountService&quot; class=&quot;com.foo.DefaultCheckingAccountService&quot;
        jcache:cache-name=&quot;checking.account&quot;&gt;
    &lt;!-- other dependencies here... --&gt;
&lt;/bean&gt;
</code></pre>
<p>然后，我们可以在解析<code>&#39;jcache:cache-name&#39;</code>属性时创建另一个<code>BeanDefinition</code>。这个<code>BeanDefinition</code>然后为我们初始化命名的 JCache。我们还可以修改<code>&#39;checkingAccountService&#39;</code>的现有<code>BeanDefinition</code>，以便它依赖于这个新的 JCache-initializing <code>BeanDefinition</code>。以下清单显示了我们的<code>JCacheInitializer</code>：</p>
<pre><code>package com.foo;

public class JCacheInitializer &#123;

    private String name;

    public JCacheInitializer(String name) &#123;
        this.name = name;
    &#125;

    public void initialize() &#123;
        // lots of JCache API calls to initialize the named cache...
    &#125;

&#125;
</code></pre>
<p>现在我们可以转到自定义扩展。首先，我们需要编写描述自定义属性的 XSD schema，如下所示：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;

&lt;xsd:schema xmlns=&quot;http://www.foo.com/schema/jcache&quot;
        xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
        targetNamespace=&quot;http://www.foo.com/schema/jcache&quot;
        elementFormDefault=&quot;qualified&quot;&gt;

    &lt;xsd:attribute name=&quot;cache-name&quot; type=&quot;xsd:string&quot;/&gt;

&lt;/xsd:schema&gt;
</code></pre>
<p>接下来，我们需要创建关联的<code>NamespaceHandler</code>，如下所示：</p>
<pre><code>package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class JCacheNamespaceHandler extends NamespaceHandlerSupport &#123;

    public void init() &#123;
        super.registerBeanDefinitionDecoratorForAttribute(&quot;cache-name&quot;,
            new JCacheInitializingBeanDefinitionDecorator());
    &#125;

&#125;
</code></pre>
<p>接下来，我们需要创建解析器。请注意，在这种情况下，因为我们要解析 XML 属性，所以我们写一个<code>BeanDefinitionDecorator</code>而不是<code>BeanDefinitionParser</code>。以下清单显示了我们的<code>BeanDefinitionDecorator</code>：</p>
<pre><code>package com.foo;

import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.BeanDefinitionDecorator;
import org.springframework.beans.factory.xml.ParserContext;
import org.w3c.dom.Attr;
import org.w3c.dom.Node;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator &#123;

    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder,
            ParserContext ctx) &#123;
        String initializerBeanName = registerJCacheInitializer(source, ctx);
        createDependencyOnJCacheInitializer(holder, initializerBeanName);
        return holder;
    &#125;

    private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder,
            String initializerBeanName) &#123;
        AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());
        String[] dependsOn = definition.getDependsOn();
        if (dependsOn == null) &#123;
            dependsOn = new String[]&#123;initializerBeanName&#125;;
        &#125; else &#123;
            List dependencies = new ArrayList(Arrays.asList(dependsOn));
            dependencies.add(initializerBeanName);
            dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);
        &#125;
        definition.setDependsOn(dependsOn);
    &#125;

    private String registerJCacheInitializer(Node source, ParserContext ctx) &#123;
        String cacheName = ((Attr) source).getValue();
        String beanName = cacheName + &quot;-initializer&quot;;
        if (!ctx.getRegistry().containsBeanDefinition(beanName)) &#123;
            BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);
            initializer.addConstructorArg(cacheName);
            ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());
        &#125;
        return beanName;
    &#125;

&#125;
</code></pre>
<p>最后，我们需要通过修改<code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code> files 向 Spring XML 基础结构注册各种 artifact，如下所示：</p>
<pre><code># in &#39;META-INF/spring.handlers&#39;
http\://www.foo.com/schema/jcache=com.foo.JCacheNamespaceHandler
# in &#39;META-INF/spring.schemas&#39;
http\://www.foo.com/schema/jcache/jcache.xsd=com/foo/jcache.xsd
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/spring/" rel="tag"># spring</a>
              <a href="/tags/IOC/" rel="tag"># IOC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/05/spring-2-IOC/" rel="prev" title="spring#2-IOC和DI">
      <i class="fa fa-chevron-left"></i> spring#2-IOC和DI
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/07/leetcode-1/" rel="next" title="leetcode#1">
      leetcode#1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="nav-text">核心技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-IoC-%E5%AE%B9%E5%99%A8"><span class="nav-text">1. IoC 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Spring-IoC-%E5%AE%B9%E5%99%A8%E5%92%8C-Beans-%E7%AE%80%E4%BB%8B"><span class="nav-text">1.1. Spring IoC 容器和 Beans 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text">1.2. 容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-Configuration-%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">1.2.1. Configuration 元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%B9%E5%99%A8"><span class="nav-text">1.2.2. 实例化容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%92%B0%E5%86%99%E5%9F%BA%E4%BA%8E-XML-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">撰写基于 XML 配置的元数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Groovy-Bean-%E5%AE%9A%E4%B9%89-DSL"><span class="nav-text">Groovy Bean 定义 DSL</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-text">1.2.3. 使用容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Bean-%E6%A6%82%E8%BF%B0"><span class="nav-text">1.3. Bean 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E5%91%BD%E5%90%8D-Beans"><span class="nav-text">1.3.1. 命名 Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8-Bean-%E5%AE%9A%E4%B9%89%E4%B9%8B%E5%A4%96%E5%88%AB%E5%90%8D-Bean"><span class="nav-text">在 Bean 定义之外别名 Bean</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E5%AE%9E%E4%BE%8B%E5%8C%96-Beans"><span class="nav-text">1.3.2. 实例化 Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">使用构造函数实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">使用静态工厂方法实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">使用实例工厂方法实例化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E4%BE%9D%E8%B5%96"><span class="nav-text">1.4. 依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-text">1.4.1. 依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Constructor-based-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-text">Constructor-based 依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-text">构造函数参数解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Setter-based-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-text">Setter-based 依赖注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%80%A7%E8%A7%A3%E5%86%B3-Process"><span class="nav-text">依赖性解决 Process</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="nav-text">依赖注入的示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%92%8C-Configuration"><span class="nav-text">1.4.2. 详细信息中的依赖关系和 Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E7%BA%BF%E5%80%BC-Primitives%EF%BC%8CStrings-%E7%AD%89"><span class="nav-text">直线值(Primitives，Strings 等)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#idref-%E5%85%83%E7%B4%A0"><span class="nav-text">idref 元素</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#References-to-Other-Beans-Collaborators"><span class="nav-text">References to Other Beans(Collaborators)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E9%83%A8-Beans"><span class="nav-text">内部 Beans</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B6%E8%97%8F"><span class="nav-text">收藏</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%90%88%E5%B9%B6"><span class="nav-text">收集合并</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%90%88%E5%B9%B6%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">收集合并的限制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Strongly-typed-%E9%9B%86%E5%90%88"><span class="nav-text">Strongly-typed 集合</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Null-%E5%92%8C-Empty-String-%E5%80%BC"><span class="nav-text">Null 和 Empty String 值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6-p-namespace-%E7%9A%84-XML-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="nav-text">带 p-namespace 的 XML 快捷方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6-c-namespace-%E7%9A%84-XML-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="nav-text">带 c-namespace 的 XML 快捷方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%96%E5%90%88%E7%89%A9%E5%B1%9E%E6%80%A7%E5%90%8D%E7%A7%B0"><span class="nav-text">化合物属性名称</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-%E4%BD%BF%E7%94%A8-depends-on"><span class="nav-text">1.4.3. 使用 depends-on</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-Lazy-initialized-Beans"><span class="nav-text">1.4.4. Lazy-initialized Beans</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-5-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%8F%E4%BD%9C%E8%80%85"><span class="nav-text">1.4.5. 自动化协作者</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E9%99%90%E5%88%B6%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-text">自动装配的限制和缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E4%B8%AD%E6%8E%92%E9%99%A4-Bean"><span class="nav-text">从自动装配中排除 Bean</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-6-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">1.4.6. 方法注入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">查找方法注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2"><span class="nav-text">任意方法替换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Bean-%E8%8C%83%E5%9B%B4"><span class="nav-text">1.5. Bean 范围</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-Singleton-%E8%8C%83%E5%9B%B4"><span class="nav-text">1.5.1. Singleton 范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-%E5%8E%9F%E5%9E%8B%E8%8C%83%E5%9B%B4"><span class="nav-text">1.5.2. 原型范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-Singleton-Beans-with-Prototype-bean-Dependencies"><span class="nav-text">1.5.3. Singleton Beans with Prototype-bean Dependencies</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-4-Request%EF%BC%8CSession%EF%BC%8CApplication-%E5%92%8C-WebSocket-Scopes"><span class="nav-text">1.5.4. Request，Session，Application 和 WebSocket Scopes</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B-Web-Configuration"><span class="nav-text">初始 Web Configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%8C%83%E5%9B%B4"><span class="nav-text">请求范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Session-%E8%8C%83%E5%9B%B4"><span class="nav-text">Session 范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Application-Scope"><span class="nav-text">Application Scope</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Scoped-Beans-as-Dependencies"><span class="nav-text">Scoped Beans as Dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%A6%81%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="nav-text">选择要创建的代理类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4"><span class="nav-text">1.5.5. 自定义范围</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4"><span class="nav-text">创建自定义范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4"><span class="nav-text">使用自定义范围</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E8%87%AA%E5%AE%9A%E4%B9%89-Bean-%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">1.6. 自定义 Bean 的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83"><span class="nav-text">1.6.1. 生命周期回调</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83"><span class="nav-text">初始化回调</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83"><span class="nav-text">销毁回调</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95"><span class="nav-text">默认初始化和销毁方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E5%90%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%88%B6"><span class="nav-text">结合生命周期机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD%E5%9B%9E%E8%B0%83"><span class="nav-text">启动和关闭回调</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8-Non-Web-Applications-%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD-Spring-IoC-%E5%AE%B9%E5%99%A8"><span class="nav-text">在 Non-Web Applications 中优雅地关闭 Spring IoC 容器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-ApplicationContextAware-%E5%92%8C-BeanNameAware"><span class="nav-text">1.6.2. ApplicationContextAware 和 BeanNameAware</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-%E5%85%B6%E4%BB%96%E6%84%9F%E7%9F%A5%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.6.3. 其他感知接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-Bean-%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF"><span class="nav-text">1.7. Bean 定义继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E9%9B%86%E8%A3%85%E7%AE%B1%E6%89%A9%E5%BB%BA%E7%82%B9"><span class="nav-text">1.8. 集装箱扩建点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-1-%E4%BD%BF%E7%94%A8-BeanPostProcessor-%E8%87%AA%E5%AE%9A%E4%B9%89-Beans"><span class="nav-text">1.8.1. 使用 BeanPostProcessor 自定义 Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9AHello-World%EF%BC%8CBeanPostProcessor-style"><span class="nav-text">示例：Hello World，BeanPostProcessor-style</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Example%EF%BC%9ARequiredAnnotationBeanPostProcessor"><span class="nav-text">Example：RequiredAnnotationBeanPostProcessor</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-2-%E4%BD%BF%E7%94%A8-BeanFactoryPostProcessor-%E8%87%AA%E5%AE%9A%E4%B9%89-Configuration-%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">1.8.2. 使用 BeanFactoryPostProcessor 自定义 Configuration 元数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Example%EF%BC%9AClass-Name-Substitution-PropertyPlaceholderConfigurer"><span class="nav-text">Example：Class Name Substitution PropertyPlaceholderConfigurer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Example%EF%BC%9APropertyOverrideConfigurer"><span class="nav-text">Example：PropertyOverrideConfigurer</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-3-%E4%BD%BF%E7%94%A8-FactoryBean-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%80%BB%E8%BE%91"><span class="nav-text">1.8.3. 使用 FactoryBean 自定义实例化逻辑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-Annotation-based-Container-Configuration"><span class="nav-text">1.9. Annotation-based Container Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-1-Required"><span class="nav-text">1.9.1. @Required</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-2-%E4%BD%BF%E7%94%A8-Autowired"><span class="nav-text">1.9.2. 使用 @Autowired</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-3-Fine-tuning-Annotation-based-%E4%BD%BF%E7%94%A8-Primary-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-text">1.9.3. Fine-tuning Annotation-based 使用 @Primary 自动装配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-4-Fine-tuning-Annotation-based-%E4%BD%BF%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-text">1.9.4. Fine-tuning Annotation-based 使用限定符自动装配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-5-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E4%BD%9C%E4%B8%BA%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-text">1.9.5. 使用泛型作为自动装配限定符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-6-%E4%BD%BF%E7%94%A8-CustomAutowireConfigurer"><span class="nav-text">1.9.6. 使用 CustomAutowireConfigurer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-7-%E6%B3%A8%E5%B0%84-Resource"><span class="nav-text">1.9.7. 注射 @Resource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-8-%E4%BD%BF%E7%94%A8-PostConstruct-%E5%92%8C-PreDestroy"><span class="nav-text">1.9.8. 使用 @PostConstruct 和 @PreDestroy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-Classpath-%E6%89%AB%E6%8F%8F%E5%92%8C%E6%89%98%E7%AE%A1%E7%BB%84%E4%BB%B6"><span class="nav-text">1.10. Classpath 扫描和托管组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-1-Component-%E5%92%8C%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E5%88%BB%E6%9D%BF%E5%8D%B0%E8%B1%A1%E6%B3%A8%E9%87%8A"><span class="nav-text">1.10.1. @Component 和进一步的刻板印象注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-2-%E4%BD%BF%E7%94%A8-Meta-annotations-%E5%92%8C-Composed-Annotations"><span class="nav-text">1.10.2. 使用 Meta-annotations 和 Composed Annotations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-3-%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B-Classes-%E5%B9%B6%E6%B3%A8%E5%86%8C-Bean-%E5%AE%9A%E4%B9%89"><span class="nav-text">1.10.3. 自动检测 Classes 并注册 Bean 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-4-%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%AB%E6%8F%8F"><span class="nav-text">1.10.4. 使用过滤器自定义扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-5-%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89-Bean-%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">1.10.5. 在组件中定义 Bean 元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-6-%E5%91%BD%E5%90%8D%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-text">1.10.6. 命名自动检测的组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-7-%E4%B8%BA%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%BB%84%E4%BB%B6%E6%8F%90%E4%BE%9B%E8%8C%83%E5%9B%B4"><span class="nav-text">1.10.7. 为自动检测组件提供范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-8-%E4%BD%BF%E7%94%A8-Annotations-%E6%8F%90%E4%BE%9B%E9%99%90%E5%AE%9A%E7%AC%A6%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">1.10.8. 使用 Annotations 提供限定符元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-9-%E7%94%9F%E6%88%90%E5%80%99%E9%80%89%E7%BB%84%E4%BB%B6%E7%B4%A2%E5%BC%95"><span class="nav-text">1.10.9. 生成候选组件索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-%E4%BD%BF%E7%94%A8-JSR-330-Standard-Annotations"><span class="nav-text">1.11. 使用 JSR 330 Standard Annotations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-1-%E4%BD%BF%E7%94%A8-Inject-%E5%92%8C-Named-%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-text">1.11.1. 使用 @Inject 和 @Named 进行依赖注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-2-Named-%E5%92%8C-ManagedBean%EF%BC%9A-Component-%E6%B3%A8%E9%87%8A%E7%9A%84%E6%A0%87%E5%87%86%E7%AD%89%E4%BB%B7%E7%89%A9"><span class="nav-text">1.11.2. @Named 和@ManagedBean： @Component 注释的标准等价物</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-3-JSR-330-%E6%A0%87%E5%87%86%E6%B3%A8%E9%87%8A%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-text">1.11.3. JSR-330 标准注释的局限性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-Java-based-Container-Configuration"><span class="nav-text">1.12. Java-based Container Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-Bean-%E5%92%8C-Configuration"><span class="nav-text">1.12.1. 基本概念： @Bean 和 @Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-2-%E4%BD%BF%E7%94%A8-AnnotationConfigApplicationContext-%E5%AE%9E%E4%BE%8B%E5%8C%96-Spring-%E5%AE%B9%E5%99%A8"><span class="nav-text">1.12.2. 使用 AnnotationConfigApplicationContext 实例化 Spring 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%9E%84%E9%80%A0"><span class="nav-text">简单构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-register-Class-lt-gt-%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E2%80%A6"><span class="nav-text">使用 register(Class &lt;?&gt;以编程方式构建容器…)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-scan-String-%E5%90%AF%E7%94%A8-Component-%E6%89%AB%E6%8F%8F%E2%80%A6"><span class="nav-text">使用 scan(String 启用 Component 扫描…)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-AnnotationConfigWebApplicationContext-%E6%94%AF%E6%8C%81-Web-Applications"><span class="nav-text">使用 AnnotationConfigWebApplicationContext 支持 Web Applications</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-3-%E4%BD%BF%E7%94%A8-Bean-Annotation"><span class="nav-text">1.12.3. 使用 @Bean Annotation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E-Bean"><span class="nav-text">声明 Bean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bean-%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-text">Bean 依赖项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83"><span class="nav-text">接收生命周期回调</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A-Bean-%E8%8C%83%E5%9B%B4"><span class="nav-text">指定 Bean 范围</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Scope-Annotation"><span class="nav-text">使用 @Scope Annotation</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Scope-%E5%92%8C-scoped-proxy"><span class="nav-text">@Scope 和 scoped-proxy</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Bean-%E5%91%BD%E5%90%8D"><span class="nav-text">自定义 Bean 命名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bean-Aliasing"><span class="nav-text">Bean Aliasing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bean-%E6%8F%8F%E8%BF%B0"><span class="nav-text">Bean 描述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-4-%E4%BD%BF%E7%94%A8-Configuration-annotation"><span class="nav-text">1.12.4. 使用 @Configuration annotation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5-Inter-bean-%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-text">注入 Inter-bean 依赖项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5-1"><span class="nav-text">查找方法注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-Java-based-Configuration-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-text">关于 Java-based Configuration 如何在内部工作的更多信息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-5-%E6%92%B0%E5%86%99-Java-based-%E9%85%8D%E7%BD%AE"><span class="nav-text">1.12.5. 撰写 Java-based 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Import-Annotation"><span class="nav-text">使用 @Import Annotation</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9C%A8%E5%AF%BC%E5%85%A5%E7%9A%84-Bean-%E5%AE%9A%E4%B9%89%E4%B8%8A%E6%B3%A8%E5%85%A5%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-text">在导入的 @Bean 定义上注入依赖项</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E5%8C%85%E5%90%AB-Configuration-Classes-%E6%88%96-Bean-%E6%96%B9%E6%B3%95"><span class="nav-text">有条件地包含 @Configuration Classes 或 @Bean 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E5%90%88-Java-%E5%92%8C-XML-Configuration"><span class="nav-text">结合 Java 和 XML Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#XML-centric-%E4%BD%BF%E7%94%A8-Configuration-Classes"><span class="nav-text">XML-centric 使用 @Configuration Classes</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Configuration-Class-centric-%E5%B0%86-XML-%E4%B8%8E-ImportResource-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-text">@Configuration Class-centric 将 XML 与 @ImportResource 一起使用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-%E7%8E%AF%E5%A2%83%E6%8A%BD%E8%B1%A1"><span class="nav-text">1.13. 环境抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-1-Bean-%E5%AE%9A%E4%B9%89-Profiles"><span class="nav-text">1.13.1. Bean 定义 Profiles</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Profile"><span class="nav-text">使用 @Profile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#XML-Bean-%E5%AE%9A%E4%B9%89-Profiles"><span class="nav-text">XML Bean 定义 Profiles</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BF%80%E6%B4%BB-Profile"><span class="nav-text">激活 Profile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4-Profile"><span class="nav-text">默认 Profile</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-2-PropertySource-%E6%8A%BD%E8%B1%A1"><span class="nav-text">1.13.2. PropertySource 抽象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-3-%E4%BD%BF%E7%94%A8-PropertySource"><span class="nav-text">1.13.3. 使用 @PropertySource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-4-Statements-%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%A7%A3%E6%9E%90"><span class="nav-text">1.13.4. Statements 中的占位符解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-%E6%B3%A8%E5%86%8C-LoadTimeWeaver"><span class="nav-text">1.14. 注册 LoadTimeWeaver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-ApplicationContext-%E7%9A%84%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD"><span class="nav-text">1.15. ApplicationContext 的附加功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-1-%E4%BD%BF%E7%94%A8-MessageSource-%E8%BF%9B%E8%A1%8C%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-text">1.15.1. 使用 MessageSource 进行国际化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-2-%E6%A0%87%E5%87%86%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="nav-text">1.15.2. 标准和自定义事件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Annotation-based-Event-Listeners"><span class="nav-text">Annotation-based Event Listeners</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5-Listeners"><span class="nav-text">异步 Listeners</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Ordering-Listeners"><span class="nav-text">Ordering Listeners</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Generic-Events"><span class="nav-text">Generic Events</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-3-%E6%96%B9%E4%BE%BF%E5%9C%B0%E8%AE%BF%E9%97%AE-Low-level-%E8%B5%84%E6%BA%90"><span class="nav-text">1.15.3. 方便地访问 Low-level 资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-4-%E6%96%B9%E4%BE%BF%E7%9A%84-ApplicationContext-Instantiation-for-Web-Applications"><span class="nav-text">1.15.4. 方便的 ApplicationContext Instantiation for Web Applications</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-5-%E5%B0%86-Spring-ApplicationContext-%E9%83%A8%E7%BD%B2%E4%B8%BA-Java-EE-RAR-%E6%96%87%E4%BB%B6"><span class="nav-text">1.15.5. 将 Spring ApplicationContext 部署为 Java EE RAR 文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-BeanFactory"><span class="nav-text">1.16. BeanFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-16-1-BeanFactory-%E6%88%96-ApplicationContext%EF%BC%9F"><span class="nav-text">1.16.1. BeanFactory 或 ApplicationContext？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%B5%84%E6%BA%90"><span class="nav-text">2.资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">2.1. 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%B5%84%E6%BA%90%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.2. 资源接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Built-in-%E8%B5%84%E6%BA%90-Implementations"><span class="nav-text">2.3. Built-in 资源 Implementations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-UrlResource-%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.3.1. UrlResource 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E4%BD%BF%E7%94%A8-ClassPathResource"><span class="nav-text">2.3.2. 使用 ClassPathResource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E7%9A%84-FileSystemResource"><span class="nav-text">2.3.3. 的 FileSystemResource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-ServletContextResource"><span class="nav-text">2.3.4. ServletContextResource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-%E7%9A%84-InputStreamResource"><span class="nav-text">2.3.5. 的 InputStreamResource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-6-%E4%BD%BF%E7%94%A8-ByteArrayResource"><span class="nav-text">2.3.6. 使用 ByteArrayResource</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-ResourceLoader"><span class="nav-text">2.4. ResourceLoader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-ResourceLoaderAware-%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.5. ResourceLoaderAware 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E8%B5%84%E6%BA%90%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-text">2.6. 资源作为依赖关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-Application-Contexts-%E5%92%8C-Resource-Paths"><span class="nav-text">2.7. Application Contexts 和 Resource Paths</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-%E6%9E%84%E5%BB%BA-Application-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">2.7.1. 构建 Application 上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0-ClassPathXmlApplicationContext-%E5%AE%9E%E4%BE%8B-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="nav-text">构造 ClassPathXmlApplicationContext 实例 - 快捷方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-Application-Context-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B5%84%E6%BA%90-Paths-%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">2.7.2. Application Context 构造函数资源 Paths 中的通配符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Ant-style-%E6%A8%A1%E5%BC%8F"><span class="nav-text">Ant-style 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">对可移植性的影响</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#classpath-%EF%BC%9A%E5%89%8D%E7%BC%80"><span class="nav-text">classpath *：前缀</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9C%89%E5%85%B3%E7%9A%84%E5%85%B6%E4%BB%96%E8%AF%B4%E6%98%8E"><span class="nav-text">与通配符有关的其他说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-3-FileSystemResource-%E8%AD%A6%E5%91%8A"><span class="nav-text">2.7.3. FileSystemResource 警告</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%AA%8C%E8%AF%81%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.验证，数据绑定和类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BD%BF%E7%94%A8-Spring-%E7%9A%84%E9%AA%8C%E8%AF%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81"><span class="nav-text">3.1. 使用 Spring 的验证器接口进行验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%B0%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%BA%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF"><span class="nav-text">3.2. 将代码解析为错误消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Bean-%E6%93%8D%E4%BD%9C%E5%92%8C-BeanWrapper"><span class="nav-text">3.3. Bean 操作和 BeanWrapper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E5%92%8C%E5%B5%8C%E5%A5%97%E7%9A%84-Properties"><span class="nav-text">3.3.1. 设置和获取基本和嵌套的 Properties</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-Built-in-PropertyEditor-Implementations"><span class="nav-text">3.3.2. Built-in PropertyEditor Implementations</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E5%85%B6%E4%BB%96%E8%87%AA%E5%AE%9A%E4%B9%89-PropertyEditor-Implementations"><span class="nav-text">注册其他自定义 PropertyEditor Implementations</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-PropertyEditorRegistrar"><span class="nav-text">使用 PropertyEditorRegistrar</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Spring-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.4. Spring 类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E8%BD%AC%E6%8D%A2%E5%99%A8-SPI"><span class="nav-text">3.4.1. 转换器 SPI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E4%BD%BF%E7%94%A8-ConverterFactory"><span class="nav-text">3.4.2. 使用 ConverterFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E4%BD%BF%E7%94%A8-GenericConverter"><span class="nav-text">3.4.3. 使用 GenericConverter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-ConditionalGenericConverter"><span class="nav-text">使用 ConditionalGenericConverter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-ConversionService-API"><span class="nav-text">3.4.4. ConversionService API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-%E9%85%8D%E7%BD%AE-ConversionService"><span class="nav-text">3.4.5. 配置 ConversionService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-6-%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8-ConversionService"><span class="nav-text">3.4.6. 以编程方式使用 ConversionService</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Spring-%E5%AD%97%E6%AE%B5%E6%A0%BC%E5%BC%8F"><span class="nav-text">3.5. Spring 字段格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-Formatter-SPI"><span class="nav-text">3.5.1. Formatter SPI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-Annotation-driven-%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-text">3.5.2. Annotation-driven 格式化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F-Annotation-API"><span class="nav-text">格式 Annotation API</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-FormatterRegistry-SPI"><span class="nav-text">3.5.3. FormatterRegistry SPI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-FormatterRegistrar-SPI"><span class="nav-text">3.5.4. FormatterRegistrar SPI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-5-%E5%9C%A8-Spring-MVC-%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%A0%BC%E5%BC%8F"><span class="nav-text">3.5.5. 在 Spring MVC 中配置格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E9%85%8D%E7%BD%AE-Global-Date-%E5%92%8C-Time-%E6%A0%BC%E5%BC%8F"><span class="nav-text">3.6. 配置 Global Date 和 Time 格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-Spring-%E9%AA%8C%E8%AF%81"><span class="nav-text">3.7. Spring 验证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1-JSR-303-Bean-Validation-API-%E6%A6%82%E8%BF%B0"><span class="nav-text">3.7.1. JSR-303 Bean Validation API 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-2-%E9%85%8D%E7%BD%AE-Bean-%E9%AA%8C%E8%AF%81%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F"><span class="nav-text">3.7.2. 配置 Bean 验证提供程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5%E9%AA%8C%E8%AF%81%E5%99%A8"><span class="nav-text">注入验证器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%A6%E6%9D%9F"><span class="nav-text">配置自定义约束</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-driven-%E6%96%B9%E6%B3%95%E9%AA%8C%E8%AF%81"><span class="nav-text">Spring-driven 方法验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-Configuration-%E9%80%89%E9%A1%B9"><span class="nav-text">其他 Configuration 选项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-3-%E9%85%8D%E7%BD%AE-DataBinder"><span class="nav-text">3.7.3. 配置 DataBinder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-4-Spring-MVC-3-%E9%AA%8C%E8%AF%81"><span class="nav-text">3.7.4. Spring MVC 3 验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Spring-%E8%A1%A8%E8%BE%BE%E8%AF%AD%E8%A8%80-SpEL"><span class="nav-text">4. Spring 表达语言(SpEL)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Evaluation"><span class="nav-text">4.1. Evaluation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E4%BA%86%E8%A7%A3-EvaluationContext"><span class="nav-text">4.1.1. 了解 EvaluationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">类型转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E8%A7%A3%E6%9E%90%E5%99%A8-Configuration"><span class="nav-text">4.1.2. 解析器 Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-SpEL-%E7%BC%96%E8%AF%91"><span class="nav-text">4.1.3. SpEL 编译</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8-Configuration"><span class="nav-text">编译器 Configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E9%99%90%E5%88%B6"><span class="nav-text">编译器限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Bean-%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">4.2. Bean 定义中的表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-XML-Configuration"><span class="nav-text">4.2.1. XML Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-Annotation-Configuration"><span class="nav-text">4.2.2. Annotation Configuration</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83"><span class="nav-text">4.3. 语言参考</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E6%96%87%E5%AD%97%E8%A1%A8%E8%BE%BE"><span class="nav-text">4.3.1. 文字表达</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-Properties%EF%BC%8CArrays%EF%BC%8CLists%EF%BC%8CMaps-%E5%92%8C-Indexers"><span class="nav-text">4.3.2. Properties，Arrays，Lists，Maps 和 Indexers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E5%86%85%E8%81%94%E5%88%97%E8%A1%A8"><span class="nav-text">4.3.3. 内联列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%E5%86%85%E8%81%94-Maps"><span class="nav-text">4.3.4. 内联 Maps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-5-Array-Construction"><span class="nav-text">4.3.5. Array Construction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-6-%E6%96%B9%E6%B3%95"><span class="nav-text">4.3.6. 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-7-Operators"><span class="nav-text">4.3.7. Operators</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Relational-Operators"><span class="nav-text">Relational Operators</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E5%91%98"><span class="nav-text">逻辑操作员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">数学运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E6%93%8D%E4%BD%9C%E5%91%98"><span class="nav-text">作业操作员</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-8-%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.3.8. 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-9-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">4.3.9. 构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-10-%E5%8F%98%E9%87%8F"><span class="nav-text">4.3.10. 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#this-%E5%92%8C-root-%E5%8F%98%E9%87%8F"><span class="nav-text">#this 和#root 变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-11-%E5%8A%9F%E8%83%BD"><span class="nav-text">4.3.11. 功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-12-Bean-References"><span class="nav-text">4.3.12. Bean References</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-13-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E5%91%98-If-Then-Else"><span class="nav-text">4.3.13. 三元操作员(If-Then-Else)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-14-Elvis-Operator"><span class="nav-text">4.3.14. Elvis Operator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-15-%E5%AE%89%E5%85%A8%E5%AF%BC%E8%88%AA%E6%93%8D%E4%BD%9C%E5%91%98"><span class="nav-text">4.3.15. 安全导航操作员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-16-%E6%94%B6%E8%97%8F%E9%80%89%E6%8B%A9"><span class="nav-text">4.3.16. 收藏选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-17-%E6%94%B6%E9%9B%86%E6%8A%95%E5%BD%B1"><span class="nav-text">4.3.17. 收集投影</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-18-%E8%A1%A8%E8%BE%BE%E6%A8%A1%E6%9D%BF"><span class="nav-text">4.3.18. 表达模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Classes-%E5%9C%A8%E7%A4%BA%E4%BE%8B%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-text">4.4. Classes 在示例中使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8-Spring-%E8%BF%9B%E8%A1%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-text">5.使用 Spring 进行面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-AOP-%E6%A6%82%E5%BF%B5"><span class="nav-text">5.1. AOP 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Spring-AOP-%E8%83%BD%E5%8A%9B%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="nav-text">5.2. Spring AOP 能力和目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-AOP-%E4%BB%A3%E7%90%86"><span class="nav-text">5.3. AOP 代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-AspectJ-%E6%94%AF%E6%8C%81"><span class="nav-text">5.4. @AspectJ 支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-%E5%90%AF%E7%94%A8-AspectJ-%E6%94%AF%E6%8C%81"><span class="nav-text">5.4.1. 启用 @AspectJ 支持</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Java-Configuration-%E5%90%AF%E7%94%A8-AspectJ-%E6%94%AF%E6%8C%81"><span class="nav-text">使用 Java Configuration 启用 @AspectJ 支持</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-XML-Configuration-%E5%90%AF%E7%94%A8-AspectJ-%E6%94%AF%E6%8C%81"><span class="nav-text">使用 XML Configuration 启用 @AspectJ 支持</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-%E5%A3%B0%E6%98%8E-Aspect"><span class="nav-text">5.4.2. 声明 Aspect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3-%E5%A3%B0%E6%98%8E%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">5.4.3. 声明切入点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-text">支持的切入点指示符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">组合切入点表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB-Common-%E5%88%87%E5%85%A5%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">共享 Common 切入点定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-text">例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E5%A5%BD%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">写好切入点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-4-%E5%AE%A3%E5%B8%83%E5%BB%BA%E8%AE%AE"><span class="nav-text">5.4.4. 宣布建议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%BB%BA%E8%AE%AE%E4%B9%8B%E5%89%8D"><span class="nav-text">在建议之前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%BB%BA%E8%AE%AE%E5%90%8E"><span class="nav-text">返回建议后</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%95%E6%8E%B7%E5%BB%BA%E8%AE%AE%E5%90%8E"><span class="nav-text">投掷建议后</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%8B%E5%90%8E-%E6%9C%80%E5%90%8E-%E5%BB%BA%E8%AE%AE"><span class="nav-text">之后(最后)建议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%B4%E7%BB%95%E5%BB%BA%E8%AE%AE"><span class="nav-text">围绕建议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E5%8F%82%E6%95%B0"><span class="nav-text">建议参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%BD%93%E5%89%8D-JoinPoint"><span class="nav-text">访问当前 JoinPoint</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E5%BB%BA%E8%AE%AE"><span class="nav-text">将参数传递给建议</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E5%8F%82%E6%95%B0%E5%92%8C%E6%B3%9B%E5%9E%8B"><span class="nav-text">建议参数和泛型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0"><span class="nav-text">确定参数名称</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%A7%E7%BB%AD-Arguments"><span class="nav-text">继续 Arguments</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E8%AE%A2%E8%B4%AD"><span class="nav-text">建议订购</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-5-%E7%AE%80%E4%BB%8B"><span class="nav-text">5.4.5. 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-6-Aspect-Instantiation-Models"><span class="nav-text">5.4.6. Aspect Instantiation Models</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-7-AOP-Example"><span class="nav-text">5.4.7. AOP Example</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-Schema-based-AOP-%E6%94%AF%E6%8C%81"><span class="nav-text">5.5. Schema-based AOP 支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-1-%E5%A3%B0%E6%98%8E-Aspect"><span class="nav-text">5.5.1. 声明 Aspect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-%E5%A3%B0%E6%98%8E%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">5.5.2. 声明切入点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-3-%E5%AE%A3%E5%B8%83%E5%BB%BA%E8%AE%AE"><span class="nav-text">5.5.3. 宣布建议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%BB%BA%E8%AE%AE%E4%B9%8B%E5%89%8D-1"><span class="nav-text">在建议之前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%BB%BA%E8%AE%AE%E5%90%8E-1"><span class="nav-text">返回建议后</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%95%E6%8E%B7%E5%BB%BA%E8%AE%AE%E5%90%8E-1"><span class="nav-text">投掷建议后</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%8B%E5%90%8E-%E6%9C%80%E5%90%8E-%E5%BB%BA%E8%AE%AE-1"><span class="nav-text">之后(最后)建议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%B4%E7%BB%95%E5%BB%BA%E8%AE%AE-1"><span class="nav-text">围绕建议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E5%8F%82%E6%95%B0-1"><span class="nav-text">建议参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E8%AE%A2%E8%B4%AD-1"><span class="nav-text">建议订购</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-4-%E7%AE%80%E4%BB%8B"><span class="nav-text">5.5.4. 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-5-Aspect-Instantiation-Models"><span class="nav-text">5.5.5. Aspect Instantiation Models</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-6-%E9%A1%BE%E9%97%AE"><span class="nav-text">5.5.6. 顾问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-7-AOP-Schema-Example"><span class="nav-text">5.5.7. AOP Schema Example</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E9%80%89%E6%8B%A9%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84-AOP-%E5%A3%B0%E6%98%8E%E6%A0%B7%E5%BC%8F"><span class="nav-text">5.6. 选择要使用的 AOP 声明样式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-1-Spring-AOP-%E6%88%96-Full-AspectJ%EF%BC%9F"><span class="nav-text">5.6.1. Spring AOP 或 Full AspectJ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-2-AspectJ-%E6%88%96-Spring-AOP-%E7%9A%84-XML%EF%BC%9F"><span class="nav-text">5.6.2. @AspectJ 或 Spring AOP 的 XML？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-%E6%B7%B7%E5%90%88-Aspect-%E7%B1%BB%E5%9E%8B"><span class="nav-text">5.7. 混合 Aspect 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">5.8. 代理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-8-1-%E4%BA%86%E8%A7%A3-AOP-%E4%BB%A3%E7%90%86"><span class="nav-text">5.8.1. 了解 AOP 代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%88%9B%E5%BB%BA-AspectJ-%E4%BB%A3%E7%90%86"><span class="nav-text">5.9. 程序化创建 @AspectJ 代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-10-%E5%B0%86-AspectJ-%E4%B8%8E-Spring-Applications-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-text">5.10. 将 AspectJ 与 Spring Applications 一起使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-10-1-%E4%BD%BF%E7%94%A8-AspectJ-%E4%B8%8E%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB-Inject-Domain-Objects-with-Spring"><span class="nav-text">5.10.1. 使用 AspectJ 与依赖关系 Inject Domain Objects with Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Configurable-Objects"><span class="nav-text">单元测试 @Configurable Objects</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-Application-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">使用多个 Application 上下文</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-10-2-AspectJ-%E7%9A%84%E5%85%B6%E4%BB%96-Spring-%E6%96%B9%E9%9D%A2"><span class="nav-text">5.10.2. AspectJ 的其他 Spring 方面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-10-3-%E4%BD%BF%E7%94%A8-Spring-IoC-%E9%85%8D%E7%BD%AE-AspectJ-%E6%96%B9%E9%9D%A2"><span class="nav-text">5.10.3. 使用 Spring IoC 配置 AspectJ 方面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-10-4-Load-time-%E5%9C%A8-Spring-Framework-%E4%B8%AD%E4%BD%BF%E7%94%A8-AspectJ-%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%BB%87"><span class="nav-text">5.10.4. Load-time 在 Spring Framework 中使用 AspectJ 进行编织</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#A-First-Example"><span class="nav-text">A First Example</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E9%9D%A2"><span class="nav-text">方面</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%80%98META-INF-aop-xml%E2%80%99"><span class="nav-text">‘META-INF&#x2F;aop.xml’</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%85%E9%9C%80-libraries-JARS"><span class="nav-text">必需 libraries(JARS)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-Configuration"><span class="nav-text">Spring Configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Environment-specific-Configuration"><span class="nav-text">Environment-specific Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Tomcat"><span class="nav-text">Tomcat</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#WebLogic%EF%BC%8CWebSphere%EF%BC%8CResin%EF%BC%8CGlassFish-%E5%92%8C-JBoss"><span class="nav-text">WebLogic，WebSphere，Resin，GlassFish 和 JBoss</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Generic-Java-Applications"><span class="nav-text">Generic Java Applications</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-11-%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%BA%90"><span class="nav-text">5.11. 更多资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Spring-AOP-API"><span class="nav-text">6. Spring AOP API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Spring-%E4%B8%AD%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9-API"><span class="nav-text">6.1. Spring 中的切入点 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">6.1.1. 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-%E5%88%87%E5%85%A5%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">6.1.2. 切入点的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-AspectJ-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">6.1.3. AspectJ 表达式切入点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-4-Convenience-Pointcut-Implementations"><span class="nav-text">6.1.4. Convenience Pointcut Implementations</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">静态切入点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">正则表达式切入点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Attribute-driven-%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">Attribute-driven 切入点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">动态切入点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">控制流切入点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-5-%E5%88%87%E5%85%A5%E7%82%B9%E8%B6%85%E7%BA%A7%E8%AF%BE%E7%A8%8B"><span class="nav-text">6.1.5. 切入点超级课程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%87%E5%85%A5%E7%82%B9"><span class="nav-text">6.1.6. 自定义切入点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-Spring-%E4%B8%AD%E7%9A%84%E5%BB%BA%E8%AE%AE-API"><span class="nav-text">6.2. Spring 中的建议 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E5%BB%BA%E8%AE%AE%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">6.2.1. 建议生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-Spring-%E4%B8%AD%E7%9A%84%E5%BB%BA%E8%AE%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">6.2.2. Spring 中的建议类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%B4%E7%BB%95%E5%BB%BA%E8%AE%AE%E6%8B%A6%E6%88%AA"><span class="nav-text">围绕建议拦截</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%BB%BA%E8%AE%AE%E4%B9%8B%E5%89%8D-2"><span class="nav-text">在建议之前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E5%8F%91%E5%BB%BA%E8%AE%AE"><span class="nav-text">引发建议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%BB%BA%E8%AE%AE%E5%90%8E-2"><span class="nav-text">返回建议后</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B%E5%BB%BA%E8%AE%AE"><span class="nav-text">简介建议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-Spring-%E4%B8%AD%E7%9A%84-Advisor-API"><span class="nav-text">6.3. Spring 中的 Advisor API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E4%BD%BF%E7%94%A8-ProxyFactoryBean-%E5%88%9B%E5%BB%BA-AOP-%E4%BB%A3%E7%90%86"><span class="nav-text">6.4. 使用 ProxyFactoryBean 创建 AOP 代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-%E5%9F%BA%E6%9C%AC"><span class="nav-text">6.4.1. 基本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-JavaBean-Properties"><span class="nav-text">6.4.2. JavaBean Properties</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-JDK-%E5%92%8C-CGLIB-based-%E4%BB%A3%E7%90%86"><span class="nav-text">6.4.3. JDK-和 CGLIB-based 代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-4-%E4%BB%A3%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="nav-text">6.4.4. 代理接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-5-%E4%BB%A3%E7%90%86-Classes"><span class="nav-text">6.4.5. 代理 Classes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-6-%E4%BD%BF%E7%94%A8%E2%80%9CGlobal%E2%80%9D%E9%A1%BE%E9%97%AE"><span class="nav-text">6.4.6. 使用“Global”顾问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E7%AE%80%E6%98%8E%E7%9A%84%E4%BB%A3%E7%90%86%E5%AE%9A%E4%B9%89"><span class="nav-text">6.5. 简明的代理定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E4%BD%BF%E7%94%A8-ProxyFactory-%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA-AOP-%E4%BB%A3%E7%90%86"><span class="nav-text">6.6. 使用 ProxyFactory 以编程方式创建 AOP 代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-%E6%93%8D%E7%BA%B5%E5%BB%BA%E8%AE%AE%E7%9A%84-Objects"><span class="nav-text">6.7. 操纵建议的 Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-%E4%BD%BF%E7%94%A8%E2%80%9Cauto-proxy%E2%80%9D%E8%AE%BE%E6%96%BD"><span class="nav-text">6.8. 使用“auto-proxy”设施</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-8-1-Auto-proxy-Bean-%E5%AE%9A%E4%B9%89"><span class="nav-text">6.8.1. Auto-proxy Bean 定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanNameAutoProxyCreator"><span class="nav-text">BeanNameAutoProxyCreator</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DefaultAdvisorAutoProxyCreator"><span class="nav-text">DefaultAdvisorAutoProxyCreator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-%E4%BD%BF%E7%94%A8-TargetSource-Implementations"><span class="nav-text">6.9. 使用 TargetSource Implementations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-1-Hot-swappable-%E7%9B%AE%E6%A0%87%E6%9D%A5%E6%BA%90"><span class="nav-text">6.9.1. Hot-swappable 目标来源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-2-%E6%B1%87%E9%9B%86%E7%9B%AE%E6%A0%87%E6%9D%A5%E6%BA%90"><span class="nav-text">6.9.2. 汇集目标来源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-3-%E5%8E%9F%E5%9E%8B%E7%9B%AE%E6%A0%87%E6%9D%A5%E6%BA%90"><span class="nav-text">6.9.3. 原型目标来源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-4-ThreadLocal-%E7%9B%AE%E6%A0%87%E6%BA%90"><span class="nav-text">6.9.4. ThreadLocal 目标源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-10-%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E5%BB%BA%E8%AE%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">6.10. 定义新的建议类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Null-safety"><span class="nav-text">7. Null-safety</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E7%94%A8%E4%BE%8B"><span class="nav-text">7.1. 用例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-JSR-305-meta-annotations"><span class="nav-text">7.2. JSR 305 meta-annotations</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-text">8.数据缓冲区和编解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-DataBufferFactory"><span class="nav-text">8.1. DataBufferFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E7%9A%84-DataBuffer"><span class="nav-text">8.2. 的 DataBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-PooledDataBuffer"><span class="nav-text">8.3. PooledDataBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-DataBufferUtils"><span class="nav-text">8.4. DataBufferUtils</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-text">8.5. 编解码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-%E4%BD%BF%E7%94%A8-DataBuffer"><span class="nav-text">8.6. 使用 DataBuffer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E9%99%84%E5%BD%95"><span class="nav-text">9.附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-XML-%E6%A8%A1%E5%BC%8F"><span class="nav-text">9.1. XML 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-1-util-Schema"><span class="nav-text">9.1.1. util Schema</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-lt-hh-5534-3-gt"><span class="nav-text">使用&lt; hh:&#x2F;&#x2F; +5534+ *3* &gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%8E%E5%AD%97%E6%AE%B5-Value-%E8%AE%BE%E7%BD%AE-Bean-Property-%E6%88%96-Constructor-%E5%8F%82%E6%95%B0"><span class="nav-text">从字段 Value 设置 Bean Property 或 Constructor 参数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-lt-hh-5572-3-gt"><span class="nav-text">使用&lt; hh:&#x2F;&#x2F; +5572+ *3* &gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-lt-hh-5591-3-gt-%E8%AE%BE%E7%BD%AE-Bean-Property-%E6%88%96-Constructor-Argument"><span class="nav-text">使用&lt; hh:&#x2F;&#x2F; +5591+ *3* &gt;设置 Bean Property 或 Constructor Argument</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-lt-hh-5603-3-gt"><span class="nav-text">使用&lt; hh:&#x2F;&#x2F; +5603+ *3* &gt;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-lt-hh-5614-3-gt"><span class="nav-text">使用&lt; hh:&#x2F;&#x2F; +5614+ *3* &gt;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-lt-hh-5632-3-gt"><span class="nav-text">使用&lt; hh:&#x2F;&#x2F; +5632+ *3* &gt;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-lt-hh-5650-3-gt"><span class="nav-text">使用&lt; hh:&#x2F;&#x2F; +5650+ *3* &gt;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-2-aop-Schema"><span class="nav-text">9.1.2. aop Schema</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-3-context-Schema"><span class="nav-text">9.1.3. context Schema</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-text">使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="nav-text">使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="nav-text">使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-3"><span class="nav-text">使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-4"><span class="nav-text">使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-5"><span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-4-Beans-Schema"><span class="nav-text">9.1.4. Beans Schema</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-XML-Schema-Authoring"><span class="nav-text">9.2. XML Schema Authoring</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-1-%E5%88%9B%E4%BD%9C-Schema"><span class="nav-text">9.2.1. 创作 Schema</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-2-%E7%BC%96%E7%A0%81-NamespaceHandler"><span class="nav-text">9.2.2. 编码 NamespaceHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-3-%E4%BD%BF%E7%94%A8-BeanDefinitionParser"><span class="nav-text">9.2.3. 使用 BeanDefinitionParser</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-4-%E6%B3%A8%E5%86%8C-Handler-%E5%92%8C-Schema"><span class="nav-text">9.2.4. 注册 Handler 和 Schema</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E4%BD%9C-META-INF-spring-handlers"><span class="nav-text">写作 META-INF&#x2F;spring.handlers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E2%80%99META-INF-spring-schemas%E2%80%99"><span class="nav-text">写’META-INF&#x2F;spring.schemas’</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-5-%E5%9C%A8-Spring-XML-Configuration-%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95"><span class="nav-text">9.2.5. 在 Spring XML Configuration 中使用自定义扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-6-%E6%9B%B4%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">9.2.6. 更详细的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0%E4%B8%AD%E5%B5%8C%E5%A5%97%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0"><span class="nav-text">在自定义元素中嵌套自定义元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%80%9C%E6%99%AE%E9%80%9A%E2%80%9D%E5%85%83%E7%B4%A0%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="nav-text">“普通”元素的自定义属性</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
