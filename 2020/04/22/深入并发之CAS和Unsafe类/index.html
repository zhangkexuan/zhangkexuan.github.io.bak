<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="有锁并发的典型代表synchronized关键字，通过该关键字可以控制并发执行过程中有且只有一个线程可以访问共享资源，其原理是通过当前线程持有当前对象锁，从而拥有访问权限，而其他没有持有当前对象锁的线程无法拥有访问权限，也就保证了线程安全。但在本篇中，我们将会详聊另外一种反向而行的并发策略，即无锁并发，即不加锁也能保证并发执行的安全性。本篇的思路是先阐明无锁执行者CAS的核心算法原理然后分析Jav">
<meta property="og:type" content="article">
<meta property="og:title" content="深入并发之CAS和Unsafe类">
<meta property="og:url" content="http://yoursite.com/2020/04/22/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E5%92%8CUnsafe%E7%B1%BB/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="有锁并发的典型代表synchronized关键字，通过该关键字可以控制并发执行过程中有且只有一个线程可以访问共享资源，其原理是通过当前线程持有当前对象锁，从而拥有访问权限，而其他没有持有当前对象锁的线程无法拥有访问权限，也就保证了线程安全。但在本篇中，我们将会详聊另外一种反向而行的并发策略，即无锁并发，即不加锁也能保证并发执行的安全性。本篇的思路是先阐明无锁执行者CAS的核心算法原理然后分析Jav">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/04/22/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E5%92%8CUnsafe%E7%B1%BB/1587888851389.png">
<meta property="og:image" content="http://yoursite.com/2020/04/22/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E5%92%8CUnsafe%E7%B1%BB/1587895282143.png">
<meta property="og:image" content="http://yoursite.com/2020/04/22/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E5%92%8CUnsafe%E7%B1%BB/1587895797628.png">
<meta property="article:published_time" content="2020-04-22T08:08:44.000Z">
<meta property="article:modified_time" content="2021-05-19T02:26:43.922Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="锁">
<meta property="article:tag" content="CSA">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/04/22/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E5%92%8CUnsafe%E7%B1%BB/1587888851389.png">

<link rel="canonical" href="http://yoursite.com/2020/04/22/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E5%92%8CUnsafe%E7%B1%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入并发之CAS和Unsafe类 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E5%92%8CUnsafe%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入并发之CAS和Unsafe类
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-22 16:08:44" itemprop="dateCreated datePublished" datetime="2020-04-22T16:08:44+08:00">2020-04-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">深入并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>有锁并发的典型代表synchronized关键字，通过该关键字可以控制并发执行过程中有且只有一个线程可以访问共享资源，其原理是通过当前线程持有当前对象锁，从而拥有访问权限，而其他没有持有当前对象锁的线程无法拥有访问权限，也就保证了线程安全。但在本篇中，我们将会详聊另外一种反向而行的并发策略，即无锁并发，即不加锁也能保证并发执行的安全性。<br>本篇的思路是先阐明无锁执行者CAS的核心算法原理然后分析Java执行CAS的实践者Unsafe类，该类中的方法都是native修饰的，因此我们会以说明方法作用为主介绍Unsafe类，最后再介绍并发包中的Atomic系统使用CAS原理实现的并发类。</p>
<span id="more"></span>

<h1 id="无锁的概念"><a href="#无锁的概念" class="headerlink" title="无锁的概念"></a>无锁的概念</h1><p>在谈论无锁概念时，总会关联起乐观派与悲观派，对于乐观派而言，他们认为事情总会往好的方向发展，总是认为坏的情况发生的概率特别小，可以无所顾忌地做事，但对于悲观派而已，他们总会认为发展事态如果不及时控制，以后就无法挽回了，即使无法挽回的局面几乎不可能发生。这两种派系映射到并发编程中就如同加锁与无锁的策略，即加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程序来说，它们总是认为每次访问共享资源时总会发生冲突，因此必须对每一次数据操作实施加锁策略。而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，这项CAS技术就是无锁策略实现的关键，下面我们进一步了解CAS技术的奇妙之处。</p>
<h1 id="无锁的执行者-CAS"><a href="#无锁的执行者-CAS" class="headerlink" title="无锁的执行者-CAS"></a>无锁的执行者-CAS</h1><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下</p>
<blockquote>
<p>执行函数：CAS(V,E,N)<br>其包含3个参数</p>
<ul>
<li>V表示要更新的变量</li>
<li>E表示预期值</li>
<li>N表示新值</li>
</ul>
</blockquote>
<p>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作，原理图如下<br><img src="1587888851389.png" alt="1587888851389"></p>
<p>由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。同时从这点也可以看出，由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说无锁操作天生免疫死锁。</p>
<h2 id="CPU指令对CAS的支持"><a href="#CPU指令对CAS的支持" class="headerlink" title="CPU指令对CAS的支持"></a>CPU指令对CAS的支持</h2><p>或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p>
<h1 id="鲜为人知的指针-Unsafe类"><a href="#鲜为人知的指针-Unsafe类" class="headerlink" title="鲜为人知的指针: Unsafe类"></a>鲜为人知的指针: Unsafe类</h1><p>Unsafe类存在于<code>sun.misc</code>包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，据说Oracle正在计划从Java 9中去掉Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务，关于Unsafe类的主要功能点如下：</p>
<ul>
<li><p>内存管理，Unsafe类中存在直接操作内存的方法</p>
<pre><code class="JAVA">//分配内存指定大小的内存
public native long allocateMemory(long bytes);
//根据给定的内存地址address设置重新分配指定大小的内存
public native long reallocateMemory(long address, long bytes);
//用于释放allocateMemory和reallocateMemory申请的内存
public native void freeMemory(long address);
//将指定对象的给定offset偏移量内存块中的所有字节设置为固定值
public native void setMemory(Object o, long offset, long bytes, byte value);
//设置给定内存地址的值
public native void putAddress(long address, long x);
//获取指定内存地址的值
public native long getAddress(long address);

//设置给定内存地址的long值
public native void putLong(long address, long x);
//获取指定内存地址的long值
public native long getLong(long address);
//设置或获取指定内存的byte值
public native byte  getByte(long address);
public native void  putByte(long address, byte x);
//其他基本数据类型(long,char,float,double,short等)的操作与putByte及getByte相同

//操作系统的内存页大小
public native int pageSize();
</code></pre>
</li>
<li><p>提供实例对象新途径</p>
<pre><code class="JAVA">//传入一个对象的class并创建该实例对象，但不会调用构造方法
public native Object allocateInstance(Class cls) throws InstantiationException;
</code></pre>
</li>
<li><p>类和实例对象以及变量的操作</p>
<pre><code class="JAVA">//获取字段f在实例对象中的偏移量
public native long objectFieldOffset(Field f);
//静态属性的偏移量，用于在对应的Class对象中读写静态属性
public native long staticFieldOffset(Field f);
//返回值就是f.getDeclaringClass()
public native Object staticFieldBase(Field f);


//获得给定对象偏移量上的int值，所谓的偏移量可以简单理解为指针指向该变量的内存地址，
//通过偏移量便可得到该对象的变量，进行各种操作
public native int getInt(Object o, long offset);
//设置给定对象上偏移量的int值
public native void putInt(Object o, long offset, int x);

//获得给定对象偏移量上的引用类型的值
public native Object getObject(Object o, long offset);
//设置给定对象偏移量上的引用类型的值
public native void putObject(Object o, long offset, Object x);
//其他基本数据类型(long,char,byte,float,double)的操作与getInthe及putInt相同

//设置给定对象的int值，使用volatile语义，即设置后立马更新到内存对其他线程可见
public native void  putIntVolatile(Object o, long offset, int x);
//获得给定对象的指定偏移量offset的int值，使用volatile语义，总能获取到最新的int值。
public native int getIntVolatile(Object o, long offset);

//其他基本数据类型(long,char,byte,float,double)的操作与putIntVolatile及getIntVolatile相同，引用类型putObjectVolatile也一样。

//与putIntVolatile一样，但要求被操作字段必须有volatile修饰
public native void putOrderedInt(Object o,long offset,int x);
</code></pre>
</li>
</ul>
<p>下面通过一个简单的Demo来演示上述的一些方法以便加深对Unsafe类的理解</p>
<pre><code class="JAVA">public class UnSafeDemo &#123;

    public  static  void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;
        // 通过反射得到theUnsafe对应的Field对象
        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
        // 设置该Field为可访问
        field.setAccessible(true);
        // 通过Field得到该Field对应的具体对象，传入null是因为该Field为static的
        Unsafe unsafe = (Unsafe) field.get(null);
        System.out.println(unsafe);

        //通过allocateInstance直接创建对象
        User user = (User) unsafe.allocateInstance(User.class);

        Class userClass = user.getClass();
        Field name = userClass.getDeclaredField(&quot;name&quot;);
        Field age = userClass.getDeclaredField(&quot;age&quot;);
        Field id = userClass.getDeclaredField(&quot;id&quot;);

        //获取实例变量name和age在对象内存中的偏移量并设置值
        unsafe.putInt(user,unsafe.objectFieldOffset(age),18);
        unsafe.putObject(user,unsafe.objectFieldOffset(name),&quot;android TV&quot;);

        // 这里返回 User.class，
        Object staticBase = unsafe.staticFieldBase(id);
        System.out.println(&quot;staticBase:&quot;+staticBase);

        //获取静态变量id的偏移量staticOffset
        long staticOffset = unsafe.staticFieldOffset(userClass.getDeclaredField(&quot;id&quot;));
        //获取静态变量的值
        System.out.println(&quot;设置前的ID:&quot;+unsafe.getObject(staticBase,staticOffset));
        //设置值
        unsafe.putObject(staticBase,staticOffset,&quot;SSSSSSSS&quot;);
        //获取静态变量的值
        System.out.println(&quot;设置前的ID:&quot;+unsafe.getObject(staticBase,staticOffset));
        //输出USER
        System.out.println(&quot;输出USER:&quot;+user.toString());

        long data = 1000;
        byte size = 1;//单位字节

        //调用allocateMemory分配内存,并获取内存地址memoryAddress
        long memoryAddress = unsafe.allocateMemory(size);
        //直接往内存写入数据
        unsafe.putAddress(memoryAddress, data);
        //获取指定内存地址的数据
        long addrData=unsafe.getAddress(memoryAddress);
        System.out.println(&quot;addrData:&quot;+addrData);

        /**
         * 输出结果:
         sun.misc.Unsafe@6f94fa3e
         staticBase:class geym.conc.ch4.atomic.User
         设置前的ID:USER_ID
         设置前的ID:SSSSSSSS
         输出USER:User&#123;name=&#39;android TV&#39;, age=18&#39;, id=SSSSSSSS&#39;&#125;
         addrData:1000
         */

    &#125;
&#125;

class User&#123;
    public User()&#123;
        System.out.println(&quot;user 构造方法被调用&quot;);
    &#125;
    private String name;
    private int age;
    private static String id=&quot;USER_ID&quot;;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
            &quot;, age=&quot; + age +&#39;\&#39;&#39; +
            &quot;, id=&quot; + id +&#39;\&#39;&#39; +
            &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>虽然在Unsafe类中存在getUnsafe()方法，但该方法只提供给高级的Bootstrap类加载器使用，普通用户调用将抛出异常，所以我们在Demo中使用了反射技术获取了Unsafe实例对象并进行相关操作。</p>
<pre><code class="java">public static Unsafe getUnsafe() &#123;
      Class cc = sun.reflect.Reflection.getCallerClass(2);
      if (cc.getClassLoader() != null)
          throw new SecurityException(&quot;Unsafe&quot;);
      return theUnsafe;
  &#125;
</code></pre>
<ul>
<li><p>数组操作</p>
<pre><code class="java">//获取数组第一个元素的偏移地址
public native int arrayBaseOffset(Class arrayClass);
//数组中一个元素占据的内存空间,arrayBaseOffset与arrayIndexScale配合使用，可定位数组中每个元素在内存中的位置
public native int arrayIndexScale(Class arrayClass);
</code></pre>
</li>
<li><p>CAS 操作相关</p>
<p>CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作CAS基于以下3个方法实现，在稍后讲解Atomic系列内部方法是基于下述方法的实现的。</p>
<pre><code class="java">//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，
//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。
public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);                                                                                                  

public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);

public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x);
</code></pre>
<p>这里还需介绍Unsafe类中JDK 1.8新增的几个方法，它们的实现是基于上述的CAS方法，如下</p>
<pre><code class="java">
 //1.8新增，给定对象o，根据获取内存偏移量指向的字段，将其增加delta，
 //这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值
 public final int getAndAddInt(Object o, long offset, int delta) &#123;
     int v;
     do &#123;
         //获取内存中最新值
         v = getIntVolatile(o, offset);
       //通过CAS操作
     &#125; while (!compareAndSwapInt(o, offset, v, v + delta));
     return v;
 &#125;

//1.8新增，方法作用同上，只不过这里操作的long类型数据
 public final long getAndAddLong(Object o, long offset, long delta) &#123;
     long v;
     do &#123;
         v = getLongVolatile(o, offset);
     &#125; while (!compareAndSwapLong(o, offset, v, v + delta));
     return v;
 &#125;

 //1.8新增，给定对象o，根据获取内存偏移量对于字段，将其 设置为新值newValue，
 //这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值
 public final int getAndSetInt(Object o, long offset, int newValue) &#123;
     int v;
     do &#123;
         v = getIntVolatile(o, offset);
     &#125; while (!compareAndSwapInt(o, offset, v, newValue));
     return v;
 &#125;

// 1.8新增，同上，操作的是long类型
 public final long getAndSetLong(Object o, long offset, long newValue) &#123;
     long v;
     do &#123;
         v = getLongVolatile(o, offset);
     &#125; while (!compareAndSwapLong(o, offset, v, newValue));
     return v;
 &#125;

 //1.8新增，同上，操作的是引用类型数据
 public final Object getAndSetObject(Object o, long offset, Object newValue) &#123;
     Object v;
     do &#123;
         v = getObjectVolatile(o, offset);
     &#125; while (!compareAndSwapObject(o, offset, v, newValue));
     return v;
 &#125;
</code></pre>
</li>
<li><p>挂起与恢复 </p>
<p>将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。Java对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，其底层实现最终还是使用Unsafe.park()方法和Unsafe.unpark()方法</p>
<pre><code class="java">//线程调用该方法，线程将一直阻塞直到超时，或者是中断条件出现。  
public native void park(boolean isAbsolute, long time);  

//终止挂起的线程，恢复正常.java.util.concurrent包中挂起操作都是在LockSupport类实现的，其底层正是使用这两个方法，  
public native void unpark(Object thread); 
</code></pre>
</li>
<li><p>内存屏障</p>
<p>这里主要包括了loadFence、storeFence、fullFence等方法，这些方法是在Java 8新引入的，用于定义内存屏障，避免代码重排序，与Java内存模型相关。</p>
<pre><code class="java">//在该方法之前的所有读操作，一定在load屏障之前执行完成
public native void loadFence();
//在该方法之前的所有写操作，一定在store屏障之前执行完成
public native void storeFence();
//在该方法之前的所有读写操作，一定在full屏障之前执行完成，这个内存屏障相当于上面两个的合体功能
public native void fullFence();
</code></pre>
</li>
<li><p>其他操作</p>
<pre><code class="java">//获取持有锁，已不建议使用
@Deprecated
public native void monitorEnter(Object var1);
//释放锁，已不建议使用
@Deprecated
public native void monitorExit(Object var1);
//尝试获取锁，已不建议使用
@Deprecated
public native boolean tryMonitorEnter(Object var1);

//获取本机内存的页数，这个值永远都是2的幂次方  
public native int pageSize();  

//告诉虚拟机定义了一个没有安全检查的类，默认情况下这个类加载器和保护域来着调用者类  
public native Class defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);  

//加载一个匿名类
public native Class defineAnonymousClass(Class hostClass, byte[] data, Object[] cpPatches);
//判断是否需要加载一个类
public native boolean shouldBeInitialized(Class&lt;?&gt; c);
//确保类一定被加载 
public native  void ensureClassInitialized(Class&lt;?&gt; c)
</code></pre>
</li>
</ul>
<h1 id="并发包中的原子操作类-Atomic系列"><a href="#并发包中的原子操作类-Atomic系列" class="headerlink" title="并发包中的原子操作类(Atomic系列)"></a>并发包中的原子操作类(Atomic系列)</h1><p>通过前面的分析我们已基本理解了无锁CAS的原理并对Java中的指针类Unsafe类有了比较全面的认识，下面进一步分析CAS在Java中的应用，即并发包中的原子操作类(Atomic系列)，从JDK 1.5开始提供了java.util.concurrent.atomic包，在该包中提供了许多基于CAS实现的原子操作类，用法方便，性能高效，主要分以下4种类型。</p>
<h2 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h2><p>原子更新基本类型主要包括3个类：</p>
<ul>
<li>AtomicBoolean：原子更新布尔类型</li>
<li>AtomicInteger：原子更新整型</li>
<li>AtomicLong：原子更新长整型</li>
</ul>
<p>这3个类的实现原理和使用方式几乎是一样的，这里我们以AtomicInteger为例进行分析，AtomicInteger主要是针对int类型的数据执行原子操作，它提供了原子自增方法、原子自减方法以及原子赋值方法等，鉴于AtomicInteger的源码不多，我们直接看源码</p>
<pre><code class="java">public class AtomicInteger extends Number implements java.io.Serializable &#123;
    private static final long serialVersionUID = 6214790243416807050L;

    // 获取指针类Unsafe
    private static final Unsafe unsafe = Unsafe.getUnsafe();

    //下述变量value在AtomicInteger实例对象内的内存偏移量
    private static final long valueOffset;

    static &#123;
        try &#123;
           //通过unsafe类的objectFieldOffset()方法，获取value变量在对象内存中的偏移
           //通过该偏移量valueOffset，unsafe类的内部方法可以获取到变量value对其进行取值或赋值操作
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;
    &#125;
   //当前AtomicInteger封装的int变量value
    private volatile int value;

    public AtomicInteger(int initialValue) &#123;
        value = initialValue;
    &#125;
    public AtomicInteger() &#123;
    &#125;
   //获取当前最新值，
    public final int get() &#123;
        return value;
    &#125;
    //设置当前值，具备volatile效果，方法用final修饰是为了更进一步的保证线程安全。
    public final void set(int newValue) &#123;
        value = newValue;
    &#125;
    //最终会设置成newValue，使用该方法后可能导致其他线程在之后的一小段时间内可以获取到旧值，有点类似于延迟加载
    public final void lazySet(int newValue) &#123;
        unsafe.putOrderedInt(this, valueOffset, newValue);
    &#125;
   //设置新值并获取旧值，底层调用的是CAS操作即unsafe.compareAndSwapInt()方法
    public final int getAndSet(int newValue) &#123;
        return unsafe.getAndSetInt(this, valueOffset, newValue);
    &#125;
   //如果当前值为expect，则设置为update(当前值指的是value变量)
    public final boolean compareAndSet(int expect, int update) &#123;
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    &#125;
    //当前值加1返回旧值，底层CAS操作
    public final int getAndIncrement() &#123;
        return unsafe.getAndAddInt(this, valueOffset, 1);
    &#125;
    //当前值减1，返回旧值，底层CAS操作
    public final int getAndDecrement() &#123;
        return unsafe.getAndAddInt(this, valueOffset, -1);
    &#125;
   //当前值增加delta，返回旧值，底层CAS操作
    public final int getAndAdd(int delta) &#123;
        return unsafe.getAndAddInt(this, valueOffset, delta);
    &#125;
    //当前值加1，返回新值，底层CAS操作
    public final int incrementAndGet() &#123;
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    &#125;
    //当前值减1，返回新值，底层CAS操作
    public final int decrementAndGet() &#123;
        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;
    &#125;
   //当前值增加delta，返回新值，底层CAS操作
    public final int addAndGet(int delta) &#123;
        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;
    &#125;
   //省略一些不常用的方法....
&#125;
</code></pre>
<p>通过上述的分析，可以发现AtomicInteger原子类的内部几乎是基于前面分析过Unsafe类中的CAS相关操作的方法实现的，这也同时证明AtomicInteger是基于无锁实现的，这里重点分析自增操作实现过程，其他方法自增实现原理一样。</p>
<pre><code class="java">//当前值加1，返回新值，底层CAS操作
public final int incrementAndGet() &#123;
     return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
 &#125;
</code></pre>
<p>我们发现AtomicInteger类中所有自增或自减的方法都间接调用Unsafe类中的getAndAddInt()方法实现了CAS操作，从而保证了线程安全，关于getAndAddInt其实前面已分析过，它是Unsafe类中1.8新增的方法，源码如下</p>
<pre><code class="java">//Unsafe类中的getAndAddInt方法
public final int getAndAddInt(Object o, long offset, int delta) &#123;
        int v;
        do &#123;
            v = getIntVolatile(o, offset);
        &#125; while (!compareAndSwapInt(o, offset, v, v + delta));
        return v;
    &#125;
</code></pre>
<p>可看出getAndAddInt通过一个while循环不断的重试更新要设置的值，直到成功为止，调用的是Unsafe类中的compareAndSwapInt方法，是一个CAS操作方法。这里需要注意的是，上述源码分析是基于JDK1.8的，如果是1.8之前的方法，AtomicInteger源码实现有所不同，是基于for死循环的，如下</p>
<pre><code class="java">//JDK 1.7的源码，由for的死循环实现，并且直接在AtomicInteger实现该方法，
//JDK1.8后，该方法实现已移动到Unsafe类中，直接调用getAndAddInt方法即可
public final int incrementAndGet() &#123;
    for (;;) &#123;
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    &#125;
&#125;
</code></pre>
<p>ok~,下面简单看个Demo，感受一下AtomicInteger使用方式</p>
<pre><code class="java">import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerDemo &#123;
    //创建AtomicInteger,用于自增操作
    static AtomicInteger i=new AtomicInteger();

    public static class AddThread implements Runnable&#123;
        @Override
        public void run()&#123;
            for(int k=0;k&lt;10000;k++) &#123;
                System.out.println(i.incrementAndGet());
            &#125;
        &#125;

    &#125;
    public static void main(String[] args) throws InterruptedException &#123;
        Thread[] ts=new Thread[10];
        //开启10条线程同时执行i的自增操作
        for(int k=0;k&lt;10;k++)&#123;
            ts[k]=new Thread(new AddThread());
        &#125;
        //启动线程
        for(int k=0;k&lt;10;k++)&#123;ts[k].start();&#125;

        for(int k=0;k&lt;10;k++)&#123;ts[k].join();&#125;

    &#125;
&#125;
</code></pre>
<p>在Demo中，使用原子类型AtomicInteger替换普通int类型执行自增的原子操作，保证了线程安全。至于AtomicBoolean和AtomicLong的使用方式以及实现原理是一样，大家可以自行查阅源码。</p>
<h2 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h2><p> 原子更新引用类型可以同时更新引用类型，这里主要分析一下AtomicReference原子类，即原子更新引用类型。先看看其使用方式，如下</p>
<pre><code class="java">public class AtomicReferenceDemo2 &#123;

    public static AtomicReference&lt;User&gt; atomicUserRef = new AtomicReference&lt;User&gt;();

    public static void main(String[] args) &#123;
        User user = new User(&quot;zhangkx&quot;, 18);
        atomicUserRef.set(user);
        User updateUser = new User(&quot;zhax&quot;, 25);
        atomicUserRef.compareAndSet(user, updateUser);
        //执行结果:User&#123;name=&#39;zhanx&#39;, age=25&#125;
              System.out.println(atomicUserRef.get().toString());  
    &#125;

    static class User &#123;
        public String name;
        private int age;

        public User(String name, int age) &#123;
            this.name = name;
            this.age = age;
        &#125;

        public String getName() &#123;
            return name;
        &#125;

        @Override
        public String toString() &#123;
            return &quot;User&#123;&quot; +
                    &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                    &quot;, age=&quot; + age +
                    &#39;&#125;&#39;;
        &#125;
    &#125;
&#125;
</code></pre>
<p>那么AtomicReference原子类内部是如何实现CAS操作的呢？</p>
<pre><code class="java">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static &#123;
        try &#123;
            valueOffset = unsafe.objectFieldOffset
                (AtomicReference.class.getDeclaredField(&quot;value&quot;));
        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;
    &#125;
    //内部变量value，Unsafe类通过valueOffset内存偏移量即可获取该变量
    private volatile V value;

//CAS方法，间接调用unsafe.compareAndSwapObject(),它是一个
//实现了CAS操作的native方法
public final boolean compareAndSet(V expect, V update) &#123;
        return unsafe.compareAndSwapObject(this, valueOffset, expect, update);
&#125;

//设置并获取旧值
public final V getAndSet(V newValue) &#123;
        return (V)unsafe.getAndSetObject(this, valueOffset, newValue);
    &#125;
    //省略其他代码......
&#125;

//Unsafe类中的getAndSetObject方法，实际调用还是CAS操作
public final Object getAndSetObject(Object o, long offset, Object newValue) &#123;
      Object v;
      do &#123;
          v = getObjectVolatile(o, offset);
      &#125; while (!compareAndSwapObject(o, offset, v, newValue));
      return v;
  &#125;
</code></pre>
<p>从源码看来，AtomicReference与AtomicInteger的实现原理基本是一样的，最终执行的还是Unsafe类，关于AtomicReference的其他方法也是一样的，如下</p>
<p> <img src="1587895282143.png" alt="1587895282143"></p>
<p>红框内的方法是Java8新增的，可以基于Lambda表达式对传递进来的期望值或要更新的值进行其他操作后再进行CAS操作，说白了就是对期望值或要更新的值进行额外修改后再执行CAS更新，在所有的Atomic原子类中几乎都存在这几个方法。</p>
<h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p> 子更新数组指的是通过原子的方式更新数组里的某个元素，主要有以下3个类</p>
<ul>
<li>AtomicIntegerArray：原子更新整数数组里的元素</li>
<li>AtomicLongArray：原子更新长整数数组里的元素</li>
<li>AtomicReferenceArray：原子更新引用类型数组里的元素</li>
</ul>
<p>这里以AtomicIntegerArray为例进行分析，其余两个使用方式和实现原理基本一样，简单案例如下，</p>
<pre><code class="java">public class AtomicIntegerArrayDemo &#123;
   static AtomicIntegerArray arr = new AtomicIntegerArray(10);

   public static class AddThread implements Runnable&#123;
       public void run()&#123;
          for(int k=0;k&lt;10000;k++)
              //执行数组中元素自增操作,参数为index,即数组下标
              arr.getAndIncrement(k%arr.length());
       &#125;
   &#125;
   public static void main(String[] args) throws InterruptedException &#123;

       Thread[] ts=new Thread[10];
       //创建10条线程
       for(int k=0;k&lt;10;k++)&#123;
           ts[k]=new Thread(new AddThread());
       &#125;
       //启动10条线程
       for(int k=0;k&lt;10;k++)&#123;ts[k].start();&#125;
       for(int k=0;k&lt;10;k++)&#123;ts[k].join();&#125;
       //执行结果
       //[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]
       System.out.println(arr);
   &#125;
&#125;
</code></pre>
<p>启动10条线程对数组中的元素进行自增操作，执行结果符合预期。使用方式比较简单，接着看看AtomicIntegerArray内部是如何实现，先看看部分源码</p>
<pre><code class="java">public class AtomicIntegerArray implements java.io.Serializable &#123;
    //获取unsafe类的实例对象
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    //获取数组的第一个元素内存起始地址
    private static final int base = unsafe.arrayBaseOffset(int[].class);

    private static final int shift;
    //内部数组
    private final int[] array;

    static &#123;
        //获取数组中一个元素占据的内存空间
        int scale = unsafe.arrayIndexScale(int[].class);
        //判断是否为2的次幂，一般为2的次幂否则抛异常
        if ((scale &amp; (scale - 1)) != 0)
            throw new Error(&quot;data type scale not a power of two&quot;);
        //
        shift = 31 - Integer.numberOfLeadingZeros(scale);
    &#125;

    private long checkedByteOffset(int i) &#123;
        if (i &lt; 0 || i &gt;= array.length)
            throw new IndexOutOfBoundsException(&quot;index &quot; + i);

        return byteOffset(i);
    &#125;
    //计算数组中每个元素的的内存地址
    private static long byteOffset(int i) &#123;
        return ((long) i &lt;&lt; shift) + base;
    &#125;
    //省略其他代码......
&#125;
</code></pre>
<p>通过前面对Unsafe类的分析，我们知道arrayBaseOffset方法可以获取数组的第一个元素起始地址，而arrayIndexScale方法可以获取每个数组元素占用的内存空间，由于这里是Int类型，而Java中一个int类型占用4个字节，也就是scale的值为4，那么如何根据数组下标值计算每个元素的内存地址呢？显然应该是</p>
<blockquote>
<p>每个数组元素的内存地址=起始地址+元素下标 * 每个元素所占用的内存空间</p>
</blockquote>
<p>与该方法原理相同</p>
<pre><code class="java">//计算数组中每个元素的的内存地址
private static long byteOffset(int i) &#123;
     return ((long) i &lt;&lt; shift) + base;
 &#125;
</code></pre>
<p>这是为什么，首先来计算出shift的值</p>
<pre><code class="java"> shift = 31 - Integer.numberOfLeadingZeros(scale);
</code></pre>
<p>其中Integer.numberOfLeadingZeros(scale)是计算出scale的前导零个数(必须是连续的)，scale=4，转成二进制为<code>00000000 00000000 00000000 00000100</code>即前导零数为29，也就是shift=2，然后利用shift来定位数组中的内存位置，在数组不越界时，计算出前3个数组元素内存地址</p>
<pre><code class="java">//第一个数组元素，index=0 ， 其中base为起始地址，4代表int类型占用的字节数 
address = base + 0 * 4 即address= base + 0 &lt;&lt; 2
//第二个数组元素，index=1
address = base + 1 * 4 即address= base + 1 &lt;&lt; 2
//第三个数组元素，index=2
address = base + 2 * 4 即address= base + 2 &lt;&lt; 2
//........
</code></pre>
<p>显然shift=2，替换去就是</p>
<pre><code>address= base + i &lt;&lt; shift
</code></pre>
<p>这就是 byteOffset(int i) 方法的计算原理。因此byteOffset(int)方法可以根据数组下标计算出每个元素的内存地址。至于其他方法就比较简单了，都是间接调用Unsafe类的CAS原子操作方法，如下简单看其中几个常用方法</p>
<pre><code class="java">//执行自增操作，返回旧值，i是指数组元素下标
public final int getAndIncrement(int i) &#123;
      return getAndAdd(i, 1);
&#125;
//指定下标元素执行自增操作，并返回新值
public final int incrementAndGet(int i) &#123;
    return getAndAdd(i, 1) + 1;
&#125;

//指定下标元素执行自减操作，并返回新值
public final int decrementAndGet(int i) &#123;
    return getAndAdd(i, -1) - 1;
&#125;
//间接调用unsafe.getAndAddInt()方法
public final int getAndAdd(int i, int delta) &#123;
    return unsafe.getAndAddInt(array, checkedByteOffset(i), delta);
&#125;

//Unsafe类中的getAndAddInt方法，执行CAS操作
public final int getAndAddInt(Object o, long offset, int delta) &#123;
        int v;
        do &#123;
            v = getIntVolatile(o, offset);
        &#125; while (!compareAndSwapInt(o, offset, v, v + delta));
        return v;
    &#125;
</code></pre>
<p>至于AtomicLongArray和AtomicReferenceArray原子类，使用方式和实现原理基本一样。</p>
<h2 id="原子更新属性"><a href="#原子更新属性" class="headerlink" title="原子更新属性"></a>原子更新属性</h2><p>  如果我们只需要某个类里的某个字段，也就是说让普通的变量也享受原子操作，可以使用原子更新字段类，如在某些时候由于项目前期考虑不周全，项目需求又发生变化，使得某个类中的变量需要执行多线程操作，由于该变量多处使用，改动起来比较麻烦，而且原来使用的地方无需使用线程安全，只要求新场景需要使用时，可以借助原子更新器处理这种场景，Atomic并发包提供了以下三个类：</p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li>
</ul>
<p>请注意原子更新器的使用存在比较苛刻的条件如下</p>
<ul>
<li>操作的字段不能是static类型。</li>
<li>操作的字段不能是final类型的，因为final根本没法修改。</li>
<li>字段必须是volatile修饰的，也就是数据本身是读一致的。</li>
</ul>
<p>属性必须对当前的Updater所在的区域是可见的，如果不是当前类内部进行原子更新器操作不能使用private，protected子类操作父类时修饰符必须是protect权限及以上，如果在同一个package下则必须是default权限及以上，也就是说无论何时都应该保证操作类与被操作类间的可见性。</p>
<p>下面看看AtomicIntegerFieldUpdater和AtomicReferenceFieldUpdater的简单使用方式</p>
<pre><code class="java">public class AtomicIntegerFieldUpdaterDemo &#123;
    public static class Candidate&#123;
        int id;
        volatile int score;
    &#125;

    public static class Game&#123;
        int id;
        volatile String name;

        public Game(int id, String name) &#123;
            this.id = id;
            this.name = name;
        &#125;

        @Override
        public String toString() &#123;
            return &quot;Game&#123;&quot; +
                    &quot;id=&quot; + id +
                    &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                    &#39;&#125;&#39;;
        &#125;
    &#125;

    static AtomicIntegerFieldUpdater&lt;Candidate&gt; atIntegerUpdater
        = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, &quot;score&quot;);

    static AtomicReferenceFieldUpdater&lt;Game,String&gt; atRefUpdate =
            AtomicReferenceFieldUpdater.newUpdater(Game.class,String.class,&quot;name&quot;);


    //用于验证分数是否正确
    public static AtomicInteger allScore=new AtomicInteger(0);


    public static void main(String[] args) throws InterruptedException &#123;
        final Candidate stu=new Candidate();
        Thread[] t=new Thread[10000];
        //开启10000个线程
        for(int i = 0 ; i &lt; 10000 ; i++) &#123;
            t[i]=new Thread() &#123;
                public void run() &#123;
                    if(Math.random()&gt;0.4)&#123;
                        atIntegerUpdater.incrementAndGet(stu);
                        allScore.incrementAndGet();
                    &#125;
                &#125;
            &#125;;
            t[i].start();
        &#125;

        for(int i = 0 ; i &lt; 10000 ; i++) &#123;  t[i].join();&#125;
        System.out.println(&quot;最终分数score=&quot;+stu.score);
        System.out.println(&quot;校验分数allScore=&quot;+allScore);

        //AtomicReferenceFieldUpdater 简单的使用
        Game game = new Game(2,&quot;zh&quot;);
        atRefUpdate.compareAndSet(game,game.name,&quot;JAVA-HHH&quot;);
        System.out.println(game.toString());

        /**
         * 输出结果:
         * 最终分数score=5976
           校验分数allScore=5976
           Game&#123;id=2, name=&#39;JAVA-HHH&#39;&#125;
         */
    &#125;
&#125;
</code></pre>
<p>我们使用AtomicIntegerFieldUpdater更新候选人(Candidate)的分数score，开启了10000条线程投票，当随机值大于0.4时算一票，分数自增一次，其中allScore用于验证分数是否正确(其实用于验证AtomicIntegerFieldUpdater更新的字段是否线程安全)，当allScore与score相同时，则说明投票结果无误，也代表AtomicIntegerFieldUpdater能正确更新字段score的值，是线程安全的。对于AtomicReferenceFieldUpdater，我们在代码中简单演示了其使用方式，注意在AtomicReferenceFieldUpdater注明泛型时需要两个泛型参数，一个是修改的类类型，一个修改字段的类型。至于AtomicLongFieldUpdater则与AtomicIntegerFieldUpdater类似，不再介绍。接着简单了解一下AtomicIntegerFieldUpdater的实现原理，实际就是反射和Unsafe类结合，AtomicIntegerFieldUpdater是个抽象类，实际实现类为AtomicIntegerFieldUpdaterImpl</p>
<pre><code class="java">public abstract class AtomicIntegerFieldUpdater&lt;T&gt; &#123;

    public static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass,
                                                              String fieldName) &#123;
         //实际实现类AtomicIntegerFieldUpdaterImpl                                          
        return new AtomicIntegerFieldUpdaterImpl&lt;U&gt;
            (tclass, fieldName, Reflection.getCallerClass());
    &#125;
 &#125;
</code></pre>
<p>看看AtomicIntegerFieldUpdaterImpl</p>
<pre><code class="java">private static class AtomicIntegerFieldUpdaterImpl&lt;T&gt;
            extends AtomicIntegerFieldUpdater&lt;T&gt; &#123;
        private static final Unsafe unsafe = Unsafe.getUnsafe();
        private final long offset;//内存偏移量
        private final Class&lt;T&gt; tclass;
        private final Class&lt;?&gt; cclass;

        AtomicIntegerFieldUpdaterImpl(final Class&lt;T&gt; tclass,
                                      final String fieldName,
                                      final Class&lt;?&gt; caller) &#123;
            final Field field;//要修改的字段
            final int modifiers;//字段修饰符
            try &#123;
                field = AccessController.doPrivileged(
                    new PrivilegedExceptionAction&lt;Field&gt;() &#123;
                        public Field run() throws NoSuchFieldException &#123;
                            return tclass.getDeclaredField(fieldName);//反射获取字段对象
                        &#125;
                    &#125;);
                    //获取字段修饰符
                modifiers = field.getModifiers();
            //对字段的访问权限进行检查,不在访问范围内抛异常
                sun.reflect.misc.ReflectUtil.ensureMemberAccess(
                    caller, tclass, null, modifiers);
                ClassLoader cl = tclass.getClassLoader();
                ClassLoader ccl = caller.getClassLoader();
                if ((ccl != null) &amp;&amp; (ccl != cl) &amp;&amp;
                    ((cl == null) || !isAncestor(cl, ccl))) &#123;
              sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);
                &#125;
            &#125; catch (PrivilegedActionException pae) &#123;
                throw new RuntimeException(pae.getException());
            &#125; catch (Exception ex) &#123;
                throw new RuntimeException(ex);
            &#125;

            Class&lt;?&gt; fieldt = field.getType();
            //判断是否为int类型
            if (fieldt != int.class)
                throw new IllegalArgumentException(&quot;Must be integer type&quot;);
            //判断是否被volatile修饰
            if (!Modifier.isVolatile(modifiers))
                throw new IllegalArgumentException(&quot;Must be volatile type&quot;);

            this.cclass = (Modifier.isProtected(modifiers) &amp;&amp;
                           caller != tclass) ? caller : null;
            this.tclass = tclass;
            //获取该字段的在对象内存的偏移量，通过内存偏移量可以获取或者修改该字段的值
            offset = unsafe.objectFieldOffset(field);
        &#125;
        &#125;
</code></pre>
<p>从AtomicIntegerFieldUpdaterImpl的构造器也可以看出更新器为什么会有这么多限制条件了，当然最终其CAS操作肯定是通过unsafe完成的，简单看一个方法</p>
<pre><code class="java">public int incrementAndGet(T obj) &#123;
        int prev, next;
        do &#123;
            prev = get(obj);
            next = prev + 1;
            //CAS操作
        &#125; while (!compareAndSet(obj, prev, next));
        return next;
&#125;

//最终调用的还是unsafe.compareAndSwapInt()方法
public boolean compareAndSet(T obj, int expect, int update) &#123;
            if (obj == null || obj.getClass() != tclass || cclass != null) fullCheck(obj);
            return unsafe.compareAndSwapInt(obj, offset, expect, update);
        &#125;
</code></pre>
<h1 id="CAS的ABA问题及其解决方案"><a href="#CAS的ABA问题及其解决方案" class="headerlink" title="CAS的ABA问题及其解决方案"></a>CAS的ABA问题及其解决方案</h1><p>假设这样一种场景，当第一个线程执行CAS(V,E,U)操作，在获取到当前变量V，准备修改为新值U前，另外两个线程已连续修改了两次变量V的值，使得该值又恢复为旧值，这样的话，我们就无法正确判断这个变量是否已被修改过，如下图</p>
<p>  <img src="1587895797628.png" alt="1587895797628"></p>
<p>这就是典型的CAS的ABA问题，一般情况这种情况发现的概率比较小，可能发生了也不会造成什么问题，比如说我们对某个做加减法，不关心数字的过程，那么发生ABA问题也没啥关系。但是在某些情况下还是需要防止的，那么该如何解决呢？在Java中解决ABA问题，我们可以使用以下两个原子类</p>
<ul>
<li>AtomicStampedReference</li>
</ul>
<p>AtomicStampedReference原子类是一个带有时间戳的对象引用，在每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境，测试demo如下</p>
<pre><code class="java">public class ABADemo &#123;

    static AtomicInteger atIn = new AtomicInteger(100);

    //初始化时需要传入一个初始值和初始时间
    static AtomicStampedReference&lt;Integer&gt; atomicStampedR =
            new AtomicStampedReference&lt;Integer&gt;(200,0);


    static Thread t1 = new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;
            //更新为200
            atIn.compareAndSet(100, 200);
            //更新为100
            atIn.compareAndSet(200, 100);
        &#125;
    &#125;);


    static Thread t2 = new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            boolean flag=atIn.compareAndSet(100,500);
            System.out.println(&quot;flag:&quot;+flag+&quot;,newValue:&quot;+atIn);
        &#125;
    &#125;);


    static Thread t3 = new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;
            int time=atomicStampedR.getStamp();
            //更新为200
            atomicStampedR.compareAndSet(100, 200,time,time+1);
            //更新为100
            int time2=atomicStampedR.getStamp();
            atomicStampedR.compareAndSet(200, 100,time2,time2+1);
        &#125;
    &#125;);


    static Thread t4 = new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;
            int time = atomicStampedR.getStamp();
            System.out.println(&quot;sleep 前 t4 time:&quot;+time);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            boolean flag=atomicStampedR.compareAndSet(100,500,time,time+1);
            System.out.println(&quot;flag:&quot;+flag+&quot;,newValue:&quot;+atomicStampedR.getReference());
        &#125;
    &#125;);

    public static  void  main(String[] args) throws InterruptedException &#123;
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        t3.start();
        t4.start();
        /**
         * 输出结果:
         flag:true,newValue:500
         sleep 前 t4 time:0
         flag:false,newValue:200
         */
    &#125;
&#125;
</code></pre>
<p>对比输出结果可知，AtomicStampedReference类确实解决了ABA的问题，下面我们简单看看其内部实现原理</p>
<pre><code class="java">public class AtomicStampedReference&lt;V&gt; &#123;
    //通过Pair内部类存储数据和时间戳
    private static class Pair&lt;T&gt; &#123;
        final T reference;
        final int stamp;
        private Pair(T reference, int stamp) &#123;
            this.reference = reference;
            this.stamp = stamp;
        &#125;
        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;
            return new Pair&lt;T&gt;(reference, stamp);
        &#125;
    &#125;
    //存储数值和时间的内部类
    private volatile Pair&lt;V&gt; pair;

    //构造器，创建时需传入初始值和时间初始值
    public AtomicStampedReference(V initialRef, int initialStamp) &#123;
        pair = Pair.of(initialRef, initialStamp);
    &#125;
&#125;
</code></pre>
<p>接着看看其compareAndSet方法的实现：</p>
<pre><code class="java">public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) &#123;
        Pair&lt;V&gt; current = pair;
        return
            expectedReference == current.reference &amp;&amp;
            expectedStamp == current.stamp &amp;&amp;
            ((newReference == current.reference &amp;&amp;
              newStamp == current.stamp) ||
             casPair(current, Pair.of(newReference, newStamp)));
    &#125;
</code></pre>
<p>同时对当前数据和当前时间进行比较，只有两者都相等是才会执行casPair()方法，单从该方法的名称就可知是一个CAS方法，最终调用的还是Unsafe类中的compareAndSwapObject方法</p>
<pre><code class="java">   private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123;
        return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);
    &#125;
</code></pre>
<p>到这我们就很清晰AtomicStampedReference的内部实现思想了，通过一个键值对Pair存储数据和时间戳，在更新时对数据和时间戳进行比较，只有两者都符合预期才会调用Unsafe的compareAndSwapObject方法执行数值和时间戳替换，也就避免了ABA的问题。</p>
<ul>
<li>AtomicMarkableReference类</li>
</ul>
<p>AtomicMarkableReference与AtomicStampedReference不同的是，AtomicMarkableReference维护的是一个boolean值的标识，也就是说至于true和false两种切换状态，经过测试，这种方式并不能完全防止ABA问题的发生，只能减少ABA问题发生的概率。</p>
<pre><code class="java">public class ABADemo &#123;
    static AtomicMarkableReference&lt;Integer&gt; atMarkRef =
              new AtomicMarkableReference&lt;Integer&gt;(100,false);

 static Thread t5 = new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;
            boolean mark=atMarkRef.isMarked();
            System.out.println(&quot;mark:&quot;+mark);
            //更新为200
            System.out.println(&quot;t5 result:&quot;+atMarkRef.compareAndSet(atMarkRef.getReference(), 200,mark,!mark));
        &#125;
    &#125;);

    static Thread t6 = new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;
            boolean mark2=atMarkRef.isMarked();
            System.out.println(&quot;mark2:&quot;+mark2);
            System.out.println(&quot;t6 result:&quot;+atMarkRef.compareAndSet(atMarkRef.getReference(), 100,mark2,!mark2));
        &#125;
    &#125;);

    static Thread t7 = new Thread(new Runnable() &#123;
        @Override
        public void run() &#123;
            boolean mark=atMarkRef.isMarked();
            System.out.println(&quot;sleep 前 t7 mark:&quot;+mark);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            boolean flag=atMarkRef.compareAndSet(100,500,mark,!mark);
            System.out.println(&quot;flag:&quot;+flag+&quot;,newValue:&quot;+atMarkRef.getReference());
        &#125;
    &#125;);

    public static  void  main(String[] args) throws InterruptedException &#123;        
        t5.start();t5.join();
        t6.start();t6.join();
        t7.start();

        /**
         * 输出结果:
         mark:false
         t5 result:true
         mark2:true
         t6 result:true
         sleep 前 t5 mark:false
         flag:true,newValue:500 ----&gt;成功了.....说明还是发生ABA问题
         */
    &#125;
&#125;
</code></pre>
<p>AtomicMarkableReference的实现原理与AtomicStampedReference类似，这里不再介绍。到此，我们也明白了如果要完全杜绝ABA问题的发生，我们应该使用AtomicStampedReference原子类更新对象，而对于AtomicMarkableReference来说只能减少ABA问题的发生概率，并不能杜绝。</p>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p> 自旋锁是一种假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这种方式确实也是可以提升效率的。但问题是当线程越来越多竞争很激烈时，占用CPU的时间变长会导致性能急剧下降，因此Java虚拟机内部一般对于自旋锁有一定的次数限制，可能是50或者100次循环后就放弃，直接挂起线程，让出CPU资源。如下通过AtomicReference可实现简单的自旋锁。</p>
<pre><code class="java">public class SpinLock &#123;
  private AtomicReference&lt;Thread&gt; sign =new AtomicReference&lt;&gt;();

  public void lock()&#123;
    Thread current = Thread.currentThread();
    while(!sign .compareAndSet(null, current))&#123;
    &#125;
  &#125;

  public void unlock ()&#123;
    Thread current = Thread.currentThread();
    sign .compareAndSet(current, null);
  &#125;
&#125;
</code></pre>
<p>使用CAS原子操作作为底层实现，lock()方法将要更新的值设置为当前线程，并将预期值设置为null。unlock()函数将要更新的值设置为null，并预期值设置为当前线程。然后我们通过lock()和unlock来控制自旋锁的开启与关闭，注意这是一种非公平锁。事实上AtomicInteger(或者AtomicLong)原子类内部的CAS操作也是通过不断的自循环(while循环)实现，不过这种循环的结束条件是线程成功更新对于的值，但也是自旋锁的一种。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%94%81/" rel="tag"># 锁</a>
              <a href="/tags/CSA/" rel="tag"># CSA</a>
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/21/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91%E4%B9%8Bsynchronized/" rel="prev" title="深入并发之synchronized">
      <i class="fa fa-chevron-left"></i> 深入并发之synchronized
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/23/springMVC-3-%E5%93%8D%E5%BA%94%E4%BA%A4%E4%BA%92&%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0&%E5%BC%82%E5%B8%B8/" rel="next" title="springMVC#3-响应交互&文件上传&异常">
      springMVC#3-响应交互&文件上传&异常 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">无锁的概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%94%81%E7%9A%84%E6%89%A7%E8%A1%8C%E8%80%85-CAS"><span class="nav-text">无锁的执行者-CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS"><span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E6%8C%87%E4%BB%A4%E5%AF%B9CAS%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-text">CPU指令对CAS的支持</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%B2%9C%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E6%8C%87%E9%92%88-Unsafe%E7%B1%BB"><span class="nav-text">鲜为人知的指针: Unsafe类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB-Atomic%E7%B3%BB%E5%88%97"><span class="nav-text">并发包中的原子操作类(Atomic系列)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-text">原子更新基本类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8"><span class="nav-text">原子更新引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84"><span class="nav-text">原子更新数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%B1%9E%E6%80%A7"><span class="nav-text">原子更新属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">CAS的ABA问题及其解决方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-text">自旋锁</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
