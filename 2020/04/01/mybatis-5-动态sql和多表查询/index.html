<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Mybatis 的映射文件中,有些时候业务逻辑复杂时,我们就需要用到动态sql语句结合多表查询的技巧。">
<meta property="og:type" content="article">
<meta property="og:title" content="mybatis#5-动态sql和多表查询">
<meta property="og:url" content="http://yoursite.com/2020/04/01/mybatis-5-%E5%8A%A8%E6%80%81sql%E5%92%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="Mybatis 的映射文件中,有些时候业务逻辑复杂时,我们就需要用到动态sql语句结合多表查询的技巧。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/04/01/mybatis-5-%E5%8A%A8%E6%80%81sql%E5%92%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1586019468058.png">
<meta property="og:image" content="http://yoursite.com/2020/04/01/mybatis-5-%E5%8A%A8%E6%80%81sql%E5%92%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1586073028839.png">
<meta property="og:image" content="http://yoursite.com/2020/04/01/mybatis-5-%E5%8A%A8%E6%80%81sql%E5%92%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1586078292221.png">
<meta property="article:published_time" content="2020-04-01T01:34:33.000Z">
<meta property="article:modified_time" content="2021-05-19T02:14:27.596Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="java">
<meta property="article:tag" content="mybatis">
<meta property="article:tag" content="sql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/04/01/mybatis-5-%E5%8A%A8%E6%80%81sql%E5%92%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/1586019468058.png">

<link rel="canonical" href="http://yoursite.com/2020/04/01/mybatis-5-%E5%8A%A8%E6%80%81sql%E5%92%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>mybatis#5-动态sql和多表查询 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/01/mybatis-5-%E5%8A%A8%E6%80%81sql%E5%92%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mybatis#5-动态sql和多表查询
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-01 09:34:33" itemprop="dateCreated datePublished" datetime="2020-04-01T09:34:33+08:00">2020-04-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mybatis/" itemprop="url" rel="index"><span itemprop="name">mybatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Mybatis 的映射文件中,有些时候业务逻辑复杂时,我们就需要用到动态sql语句结合多表查询的技巧。</p>
<span id="more"></span>

<h1 id="Mybatis-的动态-SQL-语句"><a href="#Mybatis-的动态-SQL-语句" class="headerlink" title="Mybatis 的动态 SQL 语句"></a>Mybatis 的动态 SQL 语句</h1><p>Mybatis 的映射文件中,前面我们的 SQL 都是比较简单的,有些时候业务逻辑复杂时,我们的 SQL 是动态变化的,此时在前面的学习中我们的 SQL 就不能满足要求了。</p>
<p>参考的官方文档,描述如下:</p>
<p><img src="1586019468058.png" alt="1586019468058"></p>
<h2 id="动态-SQL-之-lt-if-gt-标签"><a href="#动态-SQL-之-lt-if-gt-标签" class="headerlink" title="动态 SQL 之&lt;if&gt;标签"></a>动态 SQL 之&lt;if&gt;标签</h2><p>我们根据实体类的不同取值,使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询,如果 username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p>
<h3 id="持久层-Dao-接口"><a href="#持久层-Dao-接口" class="headerlink" title="持久层 Dao 接口"></a>持久层 Dao 接口</h3><pre><code class="java">/**
* 根据用户信息,查询用户列表
* @param user
* @return
*/
List&lt;User&gt; findByUser(User user);
</code></pre>
<h3 id="持久层-Dao-映射配置"><a href="#持久层-Dao-映射配置" class="headerlink" title="持久层 Dao 映射配置"></a>持久层 Dao 映射配置</h3><pre><code class="xml">&lt;select id=&quot;findByUser&quot; resultType=&quot;user&quot; parameterType=&quot;user&quot;&gt;
    select * from user where 1=1
    &lt;if test=&quot;username!=null and username != &#39;&#39; &quot;&gt;
        and username like #&#123;username&#125;
    &lt;/if&gt;
    &lt;if test=&quot;address != null&quot;&gt;
        and address like #&#123;address&#125;
    &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<p>注意:&lt;if&gt;标签的 test 属性中写的是对象的属性名,如果是包装类的对象要使用 OGNL 表达式的写法。<br>另外要注意 where 1=1 的作用~!</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="java">@Test
public void testFindByUser() &#123;
    User u = new User();
    u.setUsername(&quot;%王%&quot;);
    u.setAddress(&quot;%顺义%&quot;);
    //6.执行操作
    List&lt;User&gt; users = userDao.findByUser(u);
    for(User user : users) &#123;
        System.out.println(user);
    &#125;
&#125;
</code></pre>
<h2 id="动态-SQL-之-lt-where-gt-标签"><a href="#动态-SQL-之-lt-where-gt-标签" class="headerlink" title="动态 SQL 之&lt;where&gt;标签"></a>动态 SQL 之&lt;where&gt;标签</h2><p>为了简化上面 where 1=1 的条件拼装,我们可以采用&lt;where&gt;标签来简化开发。</p>
<h3 id="持久层-Dao-映射配置-1"><a href="#持久层-Dao-映射配置-1" class="headerlink" title="持久层 Dao 映射配置"></a>持久层 Dao 映射配置</h3><pre><code class="xml">    &lt;sql id=&quot;defaultSql&quot;&gt;
        select * from user;
    &lt;/sql&gt;
&lt;!-- 根据用户信息查询 --&gt;
&lt;select id=&quot;findByUser&quot; resultType=&quot;user&quot; parameterType=&quot;user&quot;&gt;
    &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt;
    &lt;where&gt;
        &lt;if test=&quot;username!=null and username != &#39;&#39; &quot;&gt;
            and username like #&#123;username&#125;
        &lt;/if&gt;
        &lt;if test=&quot;address != null&quot;&gt;
            and address like #&#123;address&#125;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<h2 id="动态标签之-lt-foreach-gt-标签"><a href="#动态标签之-lt-foreach-gt-标签" class="headerlink" title="动态标签之&lt;foreach&gt;标签"></a>动态标签之&lt;foreach&gt;标签</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>传入多个 id 查询用户信息,用下边两个 sql 实现:<br><code>SELECT * FROM USERS WHERE username LIKE &#39;%张%&#39; AND (id =10 OR id =89 OR id=16)</code><br><code>SELECT * FROM USERS WHERE username LIKE &#39;%张%&#39; AND id IN (10,89,16)</code><br>这样我们在进行范围查询时,就要将一个集合中的值,作为参数动态添加进来。<br>这样我们将如何进行参数的传递?</p>
<h3 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h3><p>在 QueryVo 中加入一个 List 集合用于封装参数</p>
<pre><code class="java">/**
*
* &lt;p&gt;Title: QueryVo&lt;/p&gt;
* &lt;p&gt;Description: 查询的条件&lt;/p&gt;
*/
public class QueryVo implements Serializable &#123;
    private List&lt;Integer&gt; ids;
    public List&lt;Integer&gt; getIds() &#123;
        return ids;
    &#125;
    public void setIds(List&lt;Integer&gt; ids) &#123;
        this.ids = ids;
    &#125;
&#125;
</code></pre>
<h3 id="持久层-Dao-接口-1"><a href="#持久层-Dao-接口-1" class="headerlink" title="持久层 Dao 接口"></a>持久层 Dao 接口</h3><pre><code class="java">/**
* 根据 id 集合查询用户
* @param vo
* @return
*/
List&lt;User&gt; findInIds(QueryVo vo);
</code></pre>
<h3 id="持久层-Dao-映射配置-2"><a href="#持久层-Dao-映射配置-2" class="headerlink" title="持久层 Dao 映射配置"></a>持久层 Dao 映射配置</h3><pre><code class="xml">&lt;!-- 查询所有用户在 id 的集合之中 --&gt;
&lt;select id=&quot;findInIds&quot; resultType=&quot;user&quot; parameterType=&quot;queryvo&quot;&gt;
    &lt;!--
 select * from user where id in (1,2,3,4,5); --&gt;
    &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt;
    &lt;where&gt;
        &lt;if test=&quot;ids != null and ids.size() &gt; 0&quot;&gt;
            &lt;foreach collection=&quot;ids&quot; open=&quot;id in(&quot;  close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt;
                #&#123;uid&#125;
            &lt;/foreach&gt;
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>&lt;foreach&gt;标签用于遍历集合,它的属性:</p>
<ul>
<li>collection:代表要遍历的集合元素,注意编写时不要写#{}</li>
<li>open:代表语句的开始部分</li>
<li>close:代表结束部分</li>
<li>item:代表遍历集合的每个元素,生成的变量名</li>
<li>sperator:代表分隔符</li>
</ul>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><pre><code class="java">@Test
public void testFindInIds() &#123;
    QueryVo vo = new QueryVo();
    List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();
    ids.add(41);
    ids.add(42);
    ids.add(43);
    ids.add(46);
    ids.add(57);
    vo.setIds(ids);
    //6.执行操作
    List&lt;User&gt; users = userDao.findInIds(vo);
    for(User user : users) &#123;
        System.out.println(user);
    &#125;
&#125;
</code></pre>
<h2 id="Mybatis-中简化编写的-SQL-片段"><a href="#Mybatis-中简化编写的-SQL-片段" class="headerlink" title="Mybatis 中简化编写的 SQL 片段"></a>Mybatis 中简化编写的 SQL 片段</h2><p>Sql 中可将重复的 sql 提取出来,使用时用 include 引用即可,最终达到 sql重用的目的。</p>
<h3 id="定义代码片段"><a href="#定义代码片段" class="headerlink" title="定义代码片段"></a>定义代码片段</h3><pre><code class="xml">&lt;!-- 抽取重复的语句代码片段 --&gt;
&lt;sql id=&quot;defaultSql&quot;&gt;
    select * from user
&lt;/sql&gt;
</code></pre>
<h3 id="引用代码片段"><a href="#引用代码片段" class="headerlink" title="引用代码片段"></a>引用代码片段</h3><pre><code class="xml">&lt;!-- 配置查询所有操作 --&gt;
&lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
    &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt;
&lt;/select&gt;
&lt;!-- 根据 id 查询 --&gt;
&lt;select id=&quot;findById&quot; resultType=&quot;UsEr&quot; parameterType=&quot;int&quot;&gt;
    &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt;
    where id = #&#123;uid&#125;
&lt;/select&gt;
</code></pre>
<h1 id="Mybatis-多表查询之一对多"><a href="#Mybatis-多表查询之一对多" class="headerlink" title="Mybatis 多表查询之一对多"></a>Mybatis 多表查询之一对多</h1><p>本次案例主要以最为简单的用户和账户的模型来分析 Mybatis 多表关系。用户为 User表,账户为 Account表。一个用户(User)可以有多个账户(Account)。具体关系如下:</p>
<p><img src="1586073028839.png" alt="1586073028839"></p>
<h2 id="一对一查询-多对一"><a href="#一对一查询-多对一" class="headerlink" title="一对一查询(多对一)"></a>一对一查询(多对一)</h2><p><strong>需求:</strong><br>查询所有账户信息,关联查询下单用户信息。<br><strong>注意:</strong><br>因为一个账户信息只能供某个用户使用,所以从查询账户信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的账户信息则为一对多查询,因为一个用户可以有多个账户。</p>
<h3 id="方式一：使用pojo"><a href="#方式一：使用pojo" class="headerlink" title="方式一：使用pojo"></a>方式一：使用pojo</h3><p><strong>实体类：</strong></p>
<pre><code class="java">/**
*
* &lt;p&gt;Title: Account&lt;/p&gt;
* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;
*/
public class Account implements Serializable &#123;
    private Integer id;
    private Integer uid;
    private Double money;
    public Integer getId() &#123;
        return id;
    &#125;
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    public Integer getUid() &#123;
        return uid;
    &#125;
    public void setUid(Integer uid) &#123;
        this.uid = uid;
    &#125;
    public Double getMoney() &#123;
        return money;
    &#125;
    public void setMoney(Double money) &#123;
        this.money = money;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Account [id=&quot; + id + &quot;, uid=&quot; + uid + &quot;, money=&quot; + money + &quot;]&quot;;
    &#125;
&#125;
</code></pre>
<p><strong>Sql 语句：</strong></p>
<p>实现查询账户信息时,也要查询账户所对应的用户信息。</p>
<pre><code class="sql">SELECT
account.*,
user.username,
user.address
FROM
account,
user
WHERE account.uid = user.id
</code></pre>
<p><strong>定义 AccountUser 类：</strong></p>
<p>为了能够封装上面 SQL 语句的查询结果,定义 <code>AccountCustomer </code>类中要包含账户信息同时还要包含用户信息,所以我们要在定义 <code>AccountUser </code>类时可以继承 <code>User </code>类。</p>
<pre><code class="java">/**
*
* &lt;p&gt;Title: AccountUser&lt;/p&gt;
* &lt;p&gt;Description: 它是 account 的子类&lt;/p&gt;
*/
public class AccountUser extends Account implements Serializable &#123;
    private String username;
    private String address;
    public String getUsername() &#123;
        return username;
    &#125;
    public void setUsername(String username) &#123;
        this.username = username;
    &#125;
    public String getAddress() &#123;
        return address;
    &#125;
    public void setAddress(String address) &#123;
        this.address = address;
    &#125;
    @Override
    public String toString() &#123;
        return super.toString() + &quot;
            AccountUser [username=&quot; + username + &quot;,
                         address=&quot; + address + &quot;]&quot;;
    &#125;
&#125;
</code></pre>
<p><strong>定义账户的持久层 Dao 接口：</strong></p>
<pre><code class="java">/**
*
* &lt;p&gt;Title: IAccountDao&lt;/p&gt;
* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;
*/
public interface IAccountDao &#123;
    /**
* 查询所有账户,同时获取账户的所属用户名称以及它的地址信息
* @return
*/
    List&lt;AccountUser&gt; findAll();
&#125;
</code></pre>
<p><strong>定义 AccountDao.xml 文件中的查询配置信息：</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;uestc.zhangkx.dao.IAccountDao&quot;&gt;
    &lt;!-- 配置查询所有操作--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;accountuser&quot;&gt;
        select a.*,u.username,u.address from account a,user u where a.uid =u.id;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>注意:因为上面查询的结果中包含了账户信息同时还包含了用户信息,所以我们的返回值类型 <code>returnType</code>的值设置为<code>AccountUser</code>类型,这样就可以接收账户信息和用户信息了。</p>
<p><strong>创建 AccountTest 测试类：</strong></p>
<pre><code class="java">/**
*
* &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;
* &lt;p&gt;Description: 一对多账户的操作&lt;/p&gt;
*/
public class AccountTest &#123;
    private InputStream in ;
    private SqlSessionFactory factory;
    private SqlSession session;
    private IAccountDao accountDao;
    @Test
    public void testFindAll() &#123;
        //6.执行操作
        List&lt;AccountUser&gt; accountusers = accountDao.findAll();
        for(AccountUser au : accountusers) &#123;
            System.out.println(au);
        &#125;
    &#125;
    @Before//在测试方法执行之前执行
    public void init()throws Exception &#123;
        //1.读取配置文件
        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        //2.创建构建者对象
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        //3.创建 SqlSession 工厂对象
        factory = builder.build(in);
        //4.创建 SqlSession 对象
        session = factory.openSession();
        //5.创建 Dao 的代理对象
        accountDao = session.getMapper(IAccountDao.class);
    &#125;
    @After//在测试方法执行完成之后执行
    public void destroy() throws Exception&#123;
        session.commit();
        //7.释放资源
        session.close();
        in.close();
    &#125;
&#125;
</code></pre>
<p><strong>小结:</strong></p>
<p>定义专门的 po 类作为输出类型,其中定义了 sql 查询结果集所有的字段。此方法较为简单,企业中使用普遍。</p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用 resultMap,定义专门的 resultMap 用于映射一对一查询结果。<br>通过面向对象的(has a)关系可以得知,我们可以在 Account 类中加入一个 User 类的对象来代表这个账户是哪个用户的。</p>
<p><strong>修改 Account 类：</strong></p>
<pre><code class="java">/**
*
* &lt;p&gt;Title: Account&lt;/p&gt;
* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;
*/
public class Account implements Serializable &#123;
    private Integer id;
    private Integer uid;
    private Double money;
    private User user;
    public User getUser() &#123;
        return user;
    &#125;
    public void setUser(User user) &#123;
        this.user = user;
    &#125;
    public Integer getId() &#123;
        return id;
    &#125;
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    public Integer getUid() &#123;
        return uid;
    &#125;
    public void setUid(Integer uid) &#123;
        this.uid = uid;
    &#125;
    public Double getMoney() &#123;
        return money;
    &#125;
    public void setMoney(Double money) &#123;
        this.money = money;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Account [id=&quot; + id + &quot;, uid=&quot; + uid + &quot;, money=&quot; + money + &quot;]&quot;;
    &#125;
&#125;
</code></pre>
<p><strong>修改 AccountDao 接口中的方法:</strong></p>
<pre><code class="java">/**
*
* &lt;p&gt;Title: IAccountDao&lt;/p&gt;
* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;
*/
public interface IAccountDao &#123;
    /**
* 查询所有账户,同时获取账户的所属用户名称以及它的地址信息
* @return
*/
    List&lt;Account&gt; findAll();
&#125;
</code></pre>
<p>注意:第二种方式,将返回值改 为了 Account 类型。<br>因为 Account 类中包含了一个 User 类的对象,它可以封装账户所对应的用户信息。</p>
<p><strong>重新定义 AccountDao.xml 文件:</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;uestc.zhangkx.dao.IAccountDao&quot;&gt;
    &lt;!-- 建立对应关系 --&gt;
    &lt;resultMap type=&quot;account&quot; id=&quot;accountMap&quot;&gt;
        &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt;
        &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;
        &lt;!-- 它是用于指定从表方的引用实体属性的 --&gt;
        &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt;
            &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
            &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
            &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
            &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;accountMap&quot;&gt;
        select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid =u.id;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><strong>在 AccountTest 类中加入测试方法:</strong></p>
<pre><code class="java">@Test
public void testFindAll()
&#123;
    List&lt;Account&gt; accounts = accountDao.findAll();
    for(Account au : accounts) &#123;
        System.out.println(au);
        System.out.println(au.getUser());
    &#125;
&#125;
</code></pre>
<h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><p>需求:<br>查询所有用户信息及用户关联的账户信息。<br>分析:<br>用户信息和他的账户信息为一对多关系,并且查询过程中如果用户没有账户信息,此时也要将用户信息查询出来,我们想到了左外连接查询比较合适。</p>
<p><strong>编写 SQL 语句:</strong></p>
<pre><code class="sql">SELECT
u.*, acc.id id,
acc.uid,
acc.money
FROM
user u
LEFT JOIN account acc ON u.id = acc.uid
</code></pre>
<p> <strong>User 类加入 List&lt;Account&gt;</strong></p>
<pre><code class="java">/**
*
* &lt;p&gt;Title: User&lt;/p&gt;
* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;
*/
public class User implements Serializable &#123;
    private Integer id;
    private String username;
    private Date birthday;
    private String sex;
    private String address;
    private List&lt;Account&gt; accounts;
    public List&lt;Account&gt; getAccounts() &#123;
        return accounts;
    &#125;
    public void setAccounts(List&lt;Account&gt; accounts) &#123;
        this.accounts = accounts;
    &#125;
    public Integer getId() &#123;
        return id;
    &#125;
    public void setId(Integer id) &#123;
        this.id = id;
    &#125;
    public String getUsername() &#123;
        return username;
    &#125;
    public void setUsername(String username) &#123;
        this.username = username;
    &#125;
    public Date getBirthday() &#123;
        return birthday;
    &#125;
    public void setBirthday(Date birthday) &#123;
        this.birthday = birthday;
    &#125;
    public String getSex() &#123;
        return sex;
    &#125;
    public void setSex(String sex) &#123;
        this.sex = sex;
    &#125;
    public String getAddress() &#123;
        return address;
    &#125;
    public void setAddress(String address) &#123;
        this.address = address;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, birthday=&quot; + birthday
            + &quot;, sex=&quot; + sex + &quot;, address=&quot;
            + address + &quot;]&quot;;
    &#125;
&#125;
</code></pre>
<p><strong>用户持久层 Dao 接口中加入查询方法</strong></p>
<pre><code class="java">    /**
    * 查询所有用户,同时获取出每个用户下的所有账户信息
    * @return
    */
    List&lt;User&gt; findAll();
</code></pre>
<p><strong>用户持久层 Dao 映射文件配置</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;uestc.zhangkx.dao.IUserDao&quot;&gt;
    &lt;resultMap type=&quot;user&quot; id=&quot;userMap&quot;&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
        &lt;!-- collection 是用于建立一对多中集合属性的对应关系
ofType 用于指定集合元素的数据类型--&gt;
        &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt;
            &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt;
            &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt;
            &lt;result column=&quot;money&quot; property=&quot;money&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;!-- 配置查询所有操作 --&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
        select u.*,a.id as aid ,a.uid,a.money from user u left outer join account
        a on u.id =a.uid
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>collection<br>    部分定义了用户关联的账户信息。表示关联查询结果集<br>property=”accList”:<br>    关联查询的结果集存储在 User 对象的上哪个属性。<br>ofType=”account”:<br>    指定关联查询的结果集中的对象类型即 List 中的对象类型。此处可以使用别名,也可以使用全限定名。</p>
<p><strong>测试方法</strong></p>
<pre><code class="java">/**
*
* &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;
* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;
* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;
*/
public class UserTest &#123;
    private InputStream in ;
    private SqlSessionFactory factory;
    private SqlSession session;
    private IUserDao userDao;
    @Test
    public void testFindAll() &#123;
        //6.执行操作
        List&lt;User&gt; users = userDao.findAll();
        for(User user : users) &#123;
            System.out.println(&quot;-------每个用户的内容---------&quot;);
            System.out.println(user);
            System.out.println(user.getAccounts());
        &#125;
    &#125;
    @Before//在测试方法执行之前执行
    public void init()throws Exception &#123;
        //1.读取配置文件
        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        //2.创建构建者对象
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        //3.创建 SqlSession 工厂对象
        factory = builder.build(in);
        //4.创建 SqlSession 对象
        session = factory.openSession();
        //5.创建 Dao 的代理对象
        userDao = session.getMapper(IUserDao.class);
    &#125;

    @After//在测试方法执行完成之后执行
    public void destroy() throws Exception&#123;
        session.commit();
        //7.释放资源
        session.close();
        in.close();
    &#125;
&#125;
</code></pre>
<h1 id="Mybatis-多表查询之多对多"><a href="#Mybatis-多表查询之多对多" class="headerlink" title="Mybatis 多表查询之多对多"></a>Mybatis 多表查询之多对多</h1><h2 id="实现-Role-到-User-多对多"><a href="#实现-Role-到-User-多对多" class="headerlink" title="实现 Role 到 User 多对多"></a>实现 Role 到 User 多对多</h2><p>通过前面的学习,我们使用 Mybatis 实现一对多关系的维护。多对多关系其实我们看成是双向的一对多关系。</p>
<p>用户与角色的多对多关系模型如下:</p>
<p><img src="1586078292221.png" alt="1586078292221"></p>
<h2 id="业务要求及实现-SQL"><a href="#业务要求及实现-SQL" class="headerlink" title="业务要求及实现 SQL"></a>业务要求及实现 SQL</h2><p>需求:<br>实现查询所有对象并且加载它所分配的用户信息。<br>分析:<br>查询角色我们需要用到 Role 表,但角色分配的用户的信息我们并不能直接找到用户信息,而是要通过中间表(USER_ROLE 表)才能关联到用户信息。<br>下面是实现的 SQL 语句:</p>
<pre><code class="sql">SELECT
r.*,u.id uid,
u.username username,
u.birthday birthday,
u.sex sex,
u.address address
FROM
ROLE r
INNER JOIN
USER_ROLE ur
ON ( r.id = ur.rid)
INNER JOIN
USER u
ON (ur.uid = u.id);
</code></pre>
<h2 id="编写角色实体类"><a href="#编写角色实体类" class="headerlink" title="编写角色实体类"></a>编写角色实体类</h2><pre><code class="java">public class Role implements Serializable &#123;
    private Integer roleId;
    private String roleName;
    private String roleDesc;
    //多对多的关系映射:一个角色可以赋予多个用户
    private List&lt;User&gt; users;
    public List&lt;User&gt; getUsers() &#123;
        return users;
    &#125;
    public void setUsers(List&lt;User&gt; users) &#123;
        this.users = users;
    &#125;
    public Integer getRoleId() &#123;
        return roleId;
    &#125;
    public void setRoleId(Integer roleId) &#123;
        this.roleId = roleId;
    &#125;
    public String getRoleName() &#123;
        return roleName;
    &#125;
    public void setRoleName(String roleName) &#123;
        this.roleName = roleName;
    &#125;
    public String getRoleDesc() &#123;
        return roleDesc;
    &#125;
    public void setRoleDesc(String roleDesc) &#123;
        this.roleDesc = roleDesc;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Role&#123;&quot; +
            &quot;roleId=&quot; + roleId +
            &quot;, roleName=&#39;&quot; + roleName + &#39;\&#39;&#39; +
            &quot;, roleDesc=&#39;&quot; + roleDesc + &#39;\&#39;&#39; +
            &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h2 id="编写-Role-持久层接口"><a href="#编写-Role-持久层接口" class="headerlink" title="编写 Role 持久层接口"></a>编写 Role 持久层接口</h2><pre><code class="java">public interface IRoleDao &#123;
    /**
* 查询所有角色
* @return
*/
    List&lt;Role&gt; findAll();
&#125;
</code></pre>
<h2 id="编写映射文件"><a href="#编写映射文件" class="headerlink" title="编写映射文件"></a>编写映射文件</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;uestc.zhangkx.dao.IRoleDao&quot;&gt;
    &lt;!--定义 role 表的 ResultMap--&gt;
    &lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt;
        &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt;
        &lt;collection property=&quot;users&quot; ofType=&quot;user&quot;&gt;
            &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
            &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;address&quot; property=&quot;address&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;!--查询所有--&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt;
        select u.*,r.id as rid,r.role_name,r.role_desc from role r
        left outer join user_role ur
        on r.id = ur.rid
        left outer join user u on u.id = ur.uid
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><pre><code class="java">public class RoleTest &#123;
    private InputStream in;
    private SqlSession sqlSession;
    private IRoleDao roleDao;
    @Before//用于在测试方法执行之前执行
    public void init()throws Exception&#123;
        //1.读取配置文件,生成字节输入流
        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        //2.获取 SqlSessionFactory
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.获取 SqlSession 对象
        sqlSession = factory.openSession(true);
        //4.获取 dao 的代理对象
        roleDao = sqlSession.getMapper(IRoleDao.class);
    &#125;
    @After//用于在测试方法执行之后执行
    public void destroy()throws Exception&#123;
        //提交事务
        // sqlSession.commit();
        //6.释放资源
        sqlSession.close();
        in.close();
    &#125;
    /**
* 测试查询所有
*/
    @Test
    public void testFindAll()&#123;
        List&lt;Role&gt; roles = roleDao.findAll();
        for(Role role : roles)&#123;
            System.out.println(&quot;---每个角色的信息----&quot;);
            System.out.println(role);
            System.out.println(role.getUsers());
        &#125;
    &#125;
&#125;
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/mybatis/" rel="tag"># mybatis</a>
              <a href="/tags/sql/" rel="tag"># sql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/31/java%E5%9F%BA%E7%A1%80-roundOne/" rel="prev" title="java基础_roundOne">
      <i class="fa fa-chevron-left"></i> java基础_roundOne
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/02/mybatis-6-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BC%93%E5%AD%98/" rel="next" title="mybatis#6-延迟加载和缓存">
      mybatis#6-延迟加载和缓存 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Mybatis-%E7%9A%84%E5%8A%A8%E6%80%81-SQL-%E8%AF%AD%E5%8F%A5"><span class="nav-text">Mybatis 的动态 SQL 语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81-SQL-%E4%B9%8B-lt-if-gt-%E6%A0%87%E7%AD%BE"><span class="nav-text">动态 SQL 之&lt;if&gt;标签</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%B1%82-Dao-%E6%8E%A5%E5%8F%A3"><span class="nav-text">持久层 Dao 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%B1%82-Dao-%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE"><span class="nav-text">持久层 Dao 映射配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81-SQL-%E4%B9%8B-lt-where-gt-%E6%A0%87%E7%AD%BE"><span class="nav-text">动态 SQL 之&lt;where&gt;标签</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%B1%82-Dao-%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE-1"><span class="nav-text">持久层 Dao 映射配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%A0%87%E7%AD%BE%E4%B9%8B-lt-foreach-gt-%E6%A0%87%E7%AD%BE"><span class="nav-text">动态标签之&lt;foreach&gt;标签</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E6%B1%82"><span class="nav-text">需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POJO"><span class="nav-text">POJO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%B1%82-Dao-%E6%8E%A5%E5%8F%A3-1"><span class="nav-text">持久层 Dao 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%B1%82-Dao-%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE-2"><span class="nav-text">持久层 Dao 映射配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="nav-text">测试方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis-%E4%B8%AD%E7%AE%80%E5%8C%96%E7%BC%96%E5%86%99%E7%9A%84-SQL-%E7%89%87%E6%AE%B5"><span class="nav-text">Mybatis 中简化编写的 SQL 片段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5"><span class="nav-text">定义代码片段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5"><span class="nav-text">引用代码片段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mybatis-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="nav-text">Mybatis 多表查询之一对多</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2-%E5%A4%9A%E5%AF%B9%E4%B8%80"><span class="nav-text">一对一查询(多对一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8pojo"><span class="nav-text">方式一：使用pojo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="nav-text">方式二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2"><span class="nav-text">一对多查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mybatis-%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B9%8B%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="nav-text">Mybatis 多表查询之多对多</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Role-%E5%88%B0-User-%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="nav-text">实现 Role 到 User 多对多</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E8%A6%81%E6%B1%82%E5%8F%8A%E5%AE%9E%E7%8E%B0-SQL"><span class="nav-text">业务要求及实现 SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E8%A7%92%E8%89%B2%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="nav-text">编写角色实体类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99-Role-%E6%8C%81%E4%B9%85%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="nav-text">编写 Role 持久层接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-text">编写映射文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="nav-text">编写测试类</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
