<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="常用的 SQL 数据库的数据都是存在磁盘中的，虽然在数据库底层也做了对应的缓存来减少数据库的 IO 压力。 由于数据库的缓存一般是针对查询的内容，而且粒度也比较小，一般只有表中的数据没有发生变动的时候，数据库的缓存才会产生作用。 但这并不能减少业务逻辑对数据库的增删改操作的 IO 压力，因此缓存技术应运而生，该技术实现了对热点数据的高速缓存，可以大大缓解后端数据库的压力。">
<meta property="og:type" content="article">
<meta property="og:title" content="redis基础">
<meta property="og:url" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="常用的 SQL 数据库的数据都是存在磁盘中的，虽然在数据库底层也做了对应的缓存来减少数据库的 IO 压力。 由于数据库的缓存一般是针对查询的内容，而且粒度也比较小，一般只有表中的数据没有发生变动的时候，数据库的缓存才会产生作用。 但这并不能减少业务逻辑对数据库的增删改操作的 IO 压力，因此缓存技术应运而生，该技术实现了对热点数据的高速缓存，可以大大缓解后端数据库的压力。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906211708612.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906212139442.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906212157175.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906212823654.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906212921143.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906212938707.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906221353239.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906221725348.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906222124371.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906222405718.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906222616198.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906224720635.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/573911-20180926153018997-127891810.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906230635766.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906230950151.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906231524276.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906231538437.png">
<meta property="og:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906231553173.png">
<meta property="article:published_time" content="2020-08-05T01:34:33.000Z">
<meta property="article:modified_time" content="2021-05-19T02:17:15.789Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/image-20200906211708612.png">

<link rel="canonical" href="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>redis基础 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/redis%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-05 09:34:33" itemprop="dateCreated datePublished" datetime="2020-08-05T09:34:33+08:00">2020-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>常用的 SQL 数据库的数据都是存在磁盘中的，虽然在数据库底层也做了对应的缓存来减少数据库的 IO 压力。</p>
<p>由于数据库的缓存一般是针对查询的内容，而且粒度也比较小，一般只有表中的数据没有发生变动的时候，数据库的缓存才会产生作用。</p>
<p>但这并不能减少业务逻辑对数据库的增删改操作的 IO 压力，因此缓存技术应运而生，该技术实现了对热点数据的高速缓存，可以大大缓解后端数据库的压力。</p>
<span id="more"></span>

<h1 id="主流应用架构"><a href="#主流应用架构" class="headerlink" title="主流应用架构"></a>主流应用架构</h1><p><img src="image-20200906211708612.png" alt="image-20200906211708612"></p>
<p>客户端在对数据库发起请求时，先到缓存层查看是否有所需的数据，如果缓存层存有客户端所需的数据，则直接从缓存层返回，否则进行穿透查询，对数据库进行查询。</p>
<p>如果在数据库中查询到该数据，则将该数据回写到缓存层，以便下次客户端再次查询能够直接从缓存层获取数据。</p>
<h2 id="缓存中间件-Memcache-和-Redis-的区别"><a href="#缓存中间件-Memcache-和-Redis-的区别" class="headerlink" title="缓存中间件 Memcache 和 Redis 的区别"></a>缓存中间件 Memcache 和 Redis 的区别</h2><p><strong>Memcache 的代码层类似 Hash，特点如下：</strong></p>
<ul>
<li>支持简单数据类型</li>
<li>不支持数据持久化存储</li>
<li>不支持主从</li>
<li>不支持分片</li>
</ul>
<p><strong>Redis 特点如下：</strong></p>
<ul>
<li>数据类型丰富</li>
<li>支持数据磁盘持久化存储</li>
<li>支持主从</li>
<li>支持分片</li>
</ul>
<h2 id="为什么-Redis-能这么快"><a href="#为什么-Redis-能这么快" class="headerlink" title="为什么 Redis 能这么快"></a>为什么 Redis 能这么快</h2><p><strong>Redis 的效率很高，官方给出的数据是 100000+QPS，这是因为：</strong></p>
<ul>
<li><p>Redis 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高。</p>
</li>
<li><p>Redis 使用单进程单线程模型的（K，V）数据库，将数据存储在内存中，存取均不会受到硬盘 IO 的限制，因此其执行速度极快。</p>
<p>另外单线程也能处理高并发请求，还可以避免频繁上下文切换和锁的竞争，如果想要多核运行也可以启动多个实例。</p>
</li>
<li><p>数据结构简单，对数据操作也简单，Redis 不使用表，不会强制用户对各个关系进行关联，不会有复杂的关系限制，其存储结构就是键值对，类似于 HashMap，HashMap 最大的优点就是存取的时间复杂度为 O(1)。</p>
</li>
<li><p>Redis 使用多路 I/O 复用模型，为非阻塞 IO。</p>
</li>
</ul>
<p>注：Redis 采用的 I/O 多路复用函数：epoll/kqueue/evport/select。</p>
<p><strong>选用策略：</strong></p>
<ul>
<li>因地制宜，优先选择时间复杂度为 O(1) 的 I/O 多路复用函数作为底层实现。</li>
<li>由于 Select 要遍历每一个 IO，所以其时间复杂度为 O(n)，通常被作为保底方案。</li>
<li>基于 React 设计模式监听 I/O 事件。</li>
</ul>
<h1 id="Redis-的数据类型"><a href="#Redis-的数据类型" class="headerlink" title="Redis 的数据类型"></a>Redis 的数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h2><p>最基本的数据类型，其值最大可存储 512M，二进制安全（Redis 的 String 可以包含任何二进制数据，包含 jpg 对象等）。</p>
<p><img src="image-20200906212139442.png" alt="image-20200906212139442"></p>
<p><strong>注：如果重复写入 key 相同的键值对，后写入的会将之前写入的覆盖。</strong></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a><strong>Hash</strong></h2><p>String 元素组成的字典，适用于存储对象。</p>
<p><img src="image-20200906212157175.png" alt="image-20200906212157175"></p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h2><p>列表，按照 String 元素插入顺序排序。其顺序为后进先出。由于其具有栈的特性，所以可以实现如“最新消息排行榜”这类的功能。</p>
<p><img src="image-20200906212823654.png" alt="image-20200906212823654"></p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h2><p>String 元素组成的无序集合，通过哈希表实现（增删改查时间复杂度为 O(1)），不允许重复。</p>
<p><img src="image-20200906212921143.png" alt="image-20200906212921143"></p>
<p>另外，当我们使用 Smembers 遍历 Set 中的元素时，其顺序也是不确定的，是通过 Hash 运算过后的结果。</p>
<p>Redis 还对集合提供了求交集、并集、差集等操作，可以实现如同共同关注，共同好友等功能。</p>
<h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p>通过分数来为集合中的成员进行从小到大的排序。</p>
<p><img src="image-20200906212938707.png" alt="image-20200906212938707"></p>
<h2 id="更高级的-Redis-类型"><a href="#更高级的-Redis-类型" class="headerlink" title="更高级的 Redis 类型"></a><strong>更高级的 Redis 类型</strong></h2><p>用于计数的 HyperLogLog、用于支持存储地理位置信息的 Geo。</p>
<p>从海量 Key 里查询出某一个固定前缀的 Key</p>
<h1 id="REDIS函数常见问题"><a href="#REDIS函数常见问题" class="headerlink" title="REDIS函数常见问题"></a>REDIS函数常见问题</h1><h2 id="假设-Redis-中有十亿条-Key，如何从这么多-Key-中找到固定前缀的-Key？"><a href="#假设-Redis-中有十亿条-Key，如何从这么多-Key-中找到固定前缀的-Key？" class="headerlink" title="假设 Redis 中有十亿条 Key，如何从这么多 Key 中找到固定前缀的 Key？"></a>假设 Redis 中有十亿条 Key，如何从这么多 Key 中找到固定前缀的 Key？</h2><p><strong>方法 1：</strong>使用 Keys [pattern]：查找所有符合给定模式 Pattern 的 Key</p>
<p>使用 Keys [pattern] 指令可以找到所有符合 Pattern 条件的 Key，但是 Keys 会一次性返回所有符合条件的 Key，所以会造成 Redis 的卡顿。</p>
<p>假设 Redis 此时正在生产环境下，使用该命令就会造成隐患，另外如果一次性返回所有 Key，对内存的消耗在某些条件下也是巨大的。</p>
<p>例：</p>
<pre><code class="c">keys test* //返回所有以test为前缀的key
</code></pre>
<p><strong>方法 2：</strong>使用 SCAN cursor [MATCH pattern] [COUNT count]</p>
<p>注：</p>
<ul>
<li>cursor：游标</li>
<li>MATCH pattern：查询 Key 的条件</li>
<li>Count：返回的条数</li>
</ul>
<p>SCAN 是一个基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程。</p>
<p>SCAN 以 0 作为游标，开始一次新的迭代，直到命令返回游标 0 完成一次遍历。</p>
<p>此命令并不保证每次执行都返回某个给定数量的元素，甚至会返回 0 个元素，但只要游标不是 0，程序都不会认为 SCAN 命令结束，但是返回的元素数量大概率符合 Count 参数。另外，SCAN 支持模糊查询。</p>
<p>例：</p>
<pre><code class="c">SCAN 0 MATCH test* COUNT 10 //每次返回10条以test为前缀的key
</code></pre>
<h2 id="如何通过-Redis-实现分布式锁"><a href="#如何通过-Redis-实现分布式锁" class="headerlink" title="如何通过 Redis 实现分布式锁?"></a>如何通过 Redis 实现分布式锁?</h2><blockquote>
<p>分布式锁</p>
<p>分布式锁是控制分布式系统之间共同访问共享资源的一种锁的实现。如果一个系统，或者不同系统的不同主机之间共享某个资源时，往往需要互斥，来排除干扰，满足数据一致性。</p>
<p>分布式锁需要解决的问题如下：</p>
<ul>
<li><p>互斥性：任意时刻只有一个客户端获取到锁，不能有两个客户端同时获取到锁。</p>
</li>
<li><p>安全性：锁只能被持有该锁的客户端删除，不能由其他客户端删除。</p>
</li>
<li><p>死锁：获取锁的客户端因为某些原因而宕机继而无法释放锁，其他客户端再也无法获取锁而导致死锁，此时需要有特殊机制来避免死锁。</p>
</li>
<li><p>容错：当各个节点，如某个 Redis 节点宕机的时候，客户端仍然能够获取锁或释放锁。</p>
</li>
</ul>
</blockquote>
<p><strong>使用 SETNX 实现，</strong>SETNX key value：如果 Key 不存在，则创建并赋值。</p>
<p> 该命令时间复杂度为 O(1)，如果设置成功，则返回 1，否则返回 0。</p>
<p><img src="image-20200906221353239.png" alt="image-20200906221353239"></p>
<p>由于 SETNX 指令操作简单，且是原子性的，所以初期的时候经常被人们作为分布式锁，我们在应用的时候，可以在某个共享资源区之前先使用 SETNX 指令，查看是否设置成功。</p>
<p>如果设置成功则说明前方没有客户端正在访问该资源，如果设置失败则说明有客户端正在访问该资源，那么当前客户端就需要等待。</p>
<p>但是如果真的这么做，就会存在一个问题，因为 SETNX 是长久存在的，所以假设一个客户端正在访问资源，并且上锁，那么当这个客户端结束访问时，该锁依旧存在，后来者也无法成功获取锁，这个该如何解决呢？</p>
<p>由于 SETNX 并不支持传入 EXPIRE 参数，所以我们可以直接使用 EXPIRE 指令来对特定的 Key 来设置过期时间。</p>
<p>用法：</p>
<pre><code>EXPIRE key seconds
</code></pre>
<p><img src="image-20200906221725348.png" alt="image-20200906221725348"></p>
<p>程序：</p>
<pre><code class="java">RedisService redisService = SpringUtils.getBean(RedisService.class);
long status = redisService.setnx(key,&quot;1&quot;);
if(status == 1)&#123;
  redisService.expire(key,expire);
  doOcuppiedWork();
&#125;
</code></pre>
<p>这段程序存在的问题：假设程序运行到第二行出现异常，那么程序来不及设置过期时间就结束了，则 Key 会一直存在，等同于锁一直被持有无法释放。</p>
<p>出现此问题的根本原因为：原子性得不到满足。</p>
<p><strong>解决：</strong>从 Redis 2.6.12 版本开始，我们就可以使用 Set 操作，将 SETNX 和 EXPIRE 融合在一起执行，具体做法如下：</p>
<ul>
<li><strong>EX second：</strong>设置键的过期时间为 Second 秒。</li>
<li><strong>PX millisecond：</strong>设置键的过期时间为 MilliSecond 毫秒。</li>
<li><strong>NX：</strong>只在键不存在时，才对键进行设置操作。 </li>
<li><strong>XX：</strong>只在键已经存在时，才对键进行设置操作。</li>
</ul>
<pre><code>SET KEY value [EX seconds] [PX milliseconds] [NX|XX]
</code></pre>
<p>注：SET 操作成功完成时才会返回 OK，否则返回 nil。</p>
<p>有了 SET 我们就可以在程序中使用类似下面的代码实现分布式锁了：</p>
<pre><code class="java">RedisService redisService = SpringUtils.getBean(RedisService.class);
String result = redisService.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);
if(&quot;OK.equals(result)&quot;)&#123;
    doOcuppiredWork();
&#125;
</code></pre>
<h2 id="如何实现异步队列"><a href="#如何实现异步队列" class="headerlink" title="如何实现异步队列?"></a>如何实现异步队列?</h2><p><strong>①使用 Redis 中的 List 作为队列</strong></p>
<p>使用上文所说的 Redis 的数据结构中的 List 作为队列 Rpush 生产消息，LPOP 消费消息。</p>
<p><img src="image-20200906222124371.png" alt="image-20200906222124371"></p>
<p>此时我们可以看到，该队列是使用 Rpush 生产队列，使用 LPOP 消费队列。</p>
<p>在这个生产者-消费者队列里，当 LPOP 没有消息时，证明该队列中没有元素，并且生产者还没有来得及生产新的数据。</p>
<p><strong>缺点：</strong>LPOP 不会等待队列中有值之后再消费，而是直接进行消费。</p>
<p><strong>弥补：</strong>可以通过在应用层引入 Sleep 机制去调用 LPOP 重试。</p>
<p><strong>②使用 BLPOP key [key…] timeout</strong></p>
<p>BLPOP key [key …] timeout：阻塞直到队列有消息或者超时。</p>
<p><img src="image-20200906222405718.png" alt="image-20200906222405718"></p>
<p><strong>缺点：</strong>按照此种方法，我们生产后的数据只能提供给各个单一消费者消费。能否实现生产一次就能让多个消费者消费呢？</p>
<p><strong>③Pub/Sub：主题订阅者模式</strong></p>
<p>发送者（Pub）发送消息，订阅者（Sub）接收消息。订阅者可以订阅任意数量的频道。</p>
<p><img src="image-20200906222616198.png" alt="image-20200906222616198"></p>
<p><strong>Pub/Sub模式的缺点：</strong>消息的发布是无状态的，无法保证可达。对于发布者来说，消息是“即发即失”的。</p>
<p>此时如果某个消费者在生产者发布消息时下线，重新上线之后，是无法接收该消息的，要解决该问题需要使用专业的消息队列，如 Kafka…此处不再赘述。</p>
<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><blockquote>
<p><strong>什么是持久化</strong></p>
<p>持久化，即将数据持久存储，而不因断电或其他各种复杂外部环境影响数据的完整性。</p>
</blockquote>
<p>由于 Redis 将数据存储在内存而不是磁盘中，所以内存一旦断电，Redis 中存储的数据也随即消失，这往往是用户不期望的，所以Redis 有持久化机制来保证数据的安全性。</p>
<p><strong>Redis 如何做持久化</strong></p>
<p>Redis 目前有两种持久化方式，即 RDB 和 AOF，RDB 是通过保存某个时间点的全量数据快照实现数据的持久化，当恢复数据时，直接通过 RDB 文件中的快照，将数据恢复。</p>
<h2 id="RDB（快照）持久化"><a href="#RDB（快照）持久化" class="headerlink" title="RDB（快照）持久化"></a><strong>RDB（快照）持久化</strong></h2><p><strong>RDB持久化会在某个特定的间隔保存那个时间点的全量数据的快照。</strong></p>
<p>RDB 配置文件，redis.conf：</p>
<pre><code>  save 900 1 #在900s内如果有1条数据被写入，则产生一次快照。
  save 300 10 #在300s内如果有10条数据被写入，则产生一次快照
  save 60 10000 #在60s内如果有10000条数据被写入，则产生一次快照
  stop-writes-on-bgsave-error yes 
  #stop-writes-on-bgsave-error ：
  如果为yes则表示，当备份进程出错的时候，
  主进程就停止进行接受新的写入操作，这样是为了保护持久化的数据一致性的问题。
</code></pre>
<h3 id="RDB-的创建与载入"><a href="#RDB-的创建与载入" class="headerlink" title="RDB 的创建与载入"></a>RDB 的创建与载入</h3><p><strong>SAVE：</strong>阻塞 Redis 的服务器进程，直到 RDB 文件被创建完毕。SAVE 命令很少被使用，因为其会阻塞主线程来保证快照的写入，由于 Redis 是使用一个主线程来接收所有客户端请求，这样会阻塞所有客户端请求。</p>
<p><strong>BGSAVE：</strong>该指令会 Fork 出一个子进程来创建 RDB 文件，不阻塞服务器进程，子进程接收请求并创建 RDB 快照，父进程继续接收客户端的请求。</p>
<p>子进程在完成文件的创建时会向父进程发送信号，父进程在接收客户端请求的过程中，在一定的时间间隔通过轮询来接收子进程的信号。</p>
<p>我们也可以通过使用 lastsave 指令来查看 BGSAVE 是否执行成功，lastsave 可以返回最后一次执行成功 BGSAVE 的时间。</p>
<h3 id="自动化触发-RDB-持久化的方式"><a href="#自动化触发-RDB-持久化的方式" class="headerlink" title="自动化触发 RDB 持久化的方式"></a>自动化触发 RDB 持久化的方式</h3><p><strong>自动化触发RDB持久化的方式如下：</strong></p>
<ul>
<li>根据 redis.conf 配置里的 SAVE m n 定时触发（实际上使用的是 BGSAVE）。</li>
<li>主从复制时，主节点自动触发。</li>
<li>执行 Debug Reload。</li>
<li>执行 Shutdown 且没有开启 AOF 持久化。</li>
</ul>
<h3 id="BGSAVE-的原理"><a href="#BGSAVE-的原理" class="headerlink" title="BGSAVE 的原理"></a>BGSAVE 的原理</h3><p><img src="image-20200906224720635.png" alt="image-20200906224720635"></p>
<p>启动：</p>
<ul>
<li>检查是否存在子进程正在执行 AOF 或者 RDB 的持久化任务。如果有则返回 false。</li>
<li>调用 Redis 源码中的 rdbSaveBackground 方法，方法中执行 fork() 产生子进程执行 RDB 操作。</li>
<li>关于 fork() 中的 Copy-On-Write。</li>
</ul>
<p>fork() 在 Linux 中创建子进程采用 Copy-On-Write（写时拷贝技术），即如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储）。</p>
<p>他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<h3 id="RDB-持久化方式的缺点"><a href="#RDB-持久化方式的缺点" class="headerlink" title="RDB 持久化方式的缺点"></a>RDB 持久化方式的缺点</h3><p><strong>RDB 持久化方式的缺点如下：</strong></p>
<ul>
<li>内存数据全量同步，数据量大的状况下，会由于 I/O 而严重影响性能。</li>
<li>可能会因为 Redis 宕机而丢失从当前至最近一次快照期间的数据。</li>
</ul>
<h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><h3 id="保存写状态"><a href="#保存写状态" class="headerlink" title="保存写状态"></a>保存写状态</h3><p>AOF 持久化是通过保存 Redis 的写状态来记录数据库的。</p>
<p>相对 RDB 来说，RDB 持久化是通过备份数据库的状态来记录数据库，而 AOF 持久化是备份数据库接收到的指令：</p>
<ul>
<li>AOF 记录除了查询以外的所有变更数据库状态的指令。</li>
<li>以增量的形式追加保存到 AOF 文件中。</li>
</ul>
<h3 id="开启-AOF-持久化"><a href="#开启-AOF-持久化" class="headerlink" title="开启 AOF 持久化"></a><strong>开启 AOF 持久化</strong></h3><p>①打开 redis.conf 配置文件，将 appendonly 属性改为 yes。</p>
<p>②修改 appendfsync 属性，该属性可以接收三种参数，分别是 always，everysec，no。</p>
<p>always 表示总是即时将缓冲区内容写入 AOF 文件当中，everysec 表示每隔一秒将缓冲区内容写入 AOF 文件，no 表示将写入文件操作交由操作系统决定。</p>
<p>一般来说，操作系统考虑效率问题，会等待缓冲区被填满再将缓冲区数据写入 AOF 文件中。</p>
<pre><code>  appendonly yes

  #appendsync always
  appendfsync everysec
  # appendfsync no
</code></pre>
<p><strong>日志重写解决 AOF 文件不断增大</strong></p>
<p>随着写操作的不断增加，AOF 文件会越来越大。假设递增一个计数器 100 次，如果使用 RDB 持久化方式，我们只要保存最终结果 100 即可。</p>
<p>而 AOF 持久化方式需要记录下这 100 次递增操作的指令，而事实上要恢复这条记录，只需要执行一条命令就行，所以那一百条命令实际可以精简为一条。</p>
<p>Redis 支持这样的功能，在不中断前台服务的情况下，可以重写 AOF 文件，同样使用到了 COW（写时拷贝）。</p>
<p>重写过程如下：</p>
<ul>
<li>调用 fork()，创建一个子进程。</li>
<li>子进程把新的 AOF 写到一个临时文件里，不依赖原来的 AOF 文件。</li>
<li>主进程持续将新的变动同时写到内存和原来的 AOF 里。</li>
<li>主进程获取子进程重写 AOF 的完成信号，往新 AOF 同步增量变动。</li>
<li>使用新的 AOF 文件替换掉旧的 AOF 文件。</li>
</ul>
<h3 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h3><ul>
<li><code>aof_rewrite</code>函数可以创建新的AOF文件，但是这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间的阻塞，因为Redis服务器使用单线程来处理命令请求；所以如果直接是服务器进程调用<code>AOF_REWRITE</code>函数的话，那么重写AOF期间，服务器将无法处理客户端发送来的命令请求；</li>
<li>Redis不希望AOF重写会造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程（后台）里执行。这样处理的最大好处是：<ul>
<li>子进程进行AOF重写期间，主进程可以继续处理命令请求；</li>
<li><strong>子进程带有主进程的数据副本</strong>，使用子进程而不是线程，可以避免在锁的情况下，<strong>保证数据的安全性</strong>。</li>
</ul>
</li>
</ul>
<h4 id="使用子进程进行AOF重写的问题"><a href="#使用子进程进行AOF重写的问题" class="headerlink" title="使用子进程进行AOF重写的问题"></a>使用子进程进行AOF重写的问题</h4><ul>
<li>子进程在进行AOF重写期间，服务器进程还要继续处理命令请求，而新的命令可能对现有的数据进行修改，这会让当前数据库的数据和重写后的AOF文件中的数据不一致。</li>
</ul>
<h4 id="如何修正"><a href="#如何修正" class="headerlink" title="如何修正"></a>如何修正</h4><ul>
<li>为了解决这种数据不一致的问题，Redis增加了一个AOF重写缓存，这个缓存在fork出子进程之后开始启用，Redis服务器主进程在执行完写命令之后，会同时将这个写命令追加到AOF缓冲区和AOF重写缓冲区</li>
<li>即子进程在执行AOF重写时，主进程需要执行以下三个工作：<ul>
<li>执行client发来的命令请求；</li>
<li>将写命令追加到现有的AOF文件中；</li>
<li>将写命令追加到AOF重写缓存中。</li>
</ul>
</li>
</ul>
<p><img src="573911-20180926153018997-127891810.png" alt="img"></p>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><ul>
<li>可以保证：<ul>
<li>AOF缓冲区的内容会定期被写入和同步到AOF文件中，对现有的AOF文件的处理工作会正常进行</li>
<li>从创建子进程开始，服务器执行的所有写操作都会被记录到AOF重写缓冲区中；</li>
</ul>
</li>
</ul>
<h4 id="完成AOF重写之后"><a href="#完成AOF重写之后" class="headerlink" title="完成AOF重写之后"></a>完成AOF重写之后</h4><ul>
<li>当子进程完成对AOF文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：<ul>
<li>将AOF重写缓存中的内容全部写入到新的AOF文件中；这个时候新的AOF文件所保存的数据库状态和服务器当前的数据库状态一致；</li>
<li>对新的AOF文件进行改名，原子的覆盖原有的AOF文件；完成新旧两个AOF文件的替换。</li>
</ul>
</li>
<li>当这个信号处理函数执行完毕之后，主进程就可以继续像往常一样接收命令请求了。在整个AOF后台重写过程中，只有最后的“主进程写入命令到AOF缓存”和“对新的AOF文件进行改名，覆盖原有的AOF文件。”这两个步骤（信号处理函数执行期间）会造成主进程阻塞，在其他时候，AOF后台重写都不会对主进程造成阻塞，这将AOF重写对性能造成的影响降到最低。</li>
</ul>
<h4 id="触发AOF后台重写的条件"><a href="#触发AOF后台重写的条件" class="headerlink" title="触发AOF后台重写的条件"></a>触发AOF后台重写的条件</h4><ul>
<li>AOF重写可以由用户通过调用<code>BGREWRITEAOF</code>手动触发。</li>
<li>服务器在AOF功能开启的情况下，会维持以下三个变量：<ul>
<li>记录当前AOF文件大小的变量<code>aof_current_size</code>。</li>
<li>记录最后一次AOF重写之后，AOF文件大小的变量<code>aof_rewrite_base_size</code>。</li>
<li>增长百分比变量<code>aof_rewrite_perc</code>。</li>
</ul>
</li>
<li>每次当<code>serverCron</code>（服务器周期性操作函数）函数执行时，它会检查以下条件是否全部满足，如果全部满足的话，就触发自动的AOF重写操作：<ul>
<li>没有BGSAVE命令（RDB持久化）/AOF持久化在执行；</li>
<li>没有BGREWRITEAOF在进行；</li>
<li>当前AOF文件大小要大于<code>server.aof_rewrite_min_size</code>（默认为1MB），或者在<code>redis.conf</code>配置了<code>auto-aof-rewrite-min-size</code>大小；</li>
<li>当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比（在配置文件设置了<code>auto-aof-rewrite-percentage</code>参数，不设置默认为100%）</li>
</ul>
</li>
</ul>
<p>如果前面三个条件都满足，并且当前AOF文件大小比最后一次AOF重写时的大小要大于指定的百分比，那么触发自动AOF重写。 </p>
<h2 id="AOF-和-RDB-的优缺点"><a href="#AOF-和-RDB-的优缺点" class="headerlink" title="AOF 和 RDB 的优缺点"></a><strong>AOF 和 RDB 的优缺点</strong></h2><p><strong>AOF 和 RDB 的优缺点如下</strong></p>
<ul>
<li><strong>RDB 优点：</strong>全量数据快照，文件小，恢复快。</li>
<li><strong>RDB 缺点：</strong>无法保存最近一次快照之后的数据。</li>
<li><strong>AOF 优点：</strong>可读性高，适合保存增量数据，数据不易丢失。</li>
<li><strong>AOF 缺点：</strong>文件体积大，恢复时间长。</li>
</ul>
<p><strong>RDB-AOF 混合持久化方式</strong></p>
<p>Redis 4.0 之后推出了此种持久化方式，RDB 作为全量备份，AOF 作为增量备份，并且将此种方式作为默认方式使用。</p>
<p>在上述两种方式中，RDB 方式是将全量数据写入 RDB 文件，这样写入的特点是文件小，恢复快，但无法保存最近一次快照之后的数据，AOF 则将 Redis 指令存入文件中，这样又会造成文件体积大，恢复时间长等弱点。</p>
<p>在 RDB-AOF 方式下，持久化策略首先将缓存中数据以 RDB 方式全量写入文件，再将写入后新增的数据以 AOF 的方式追加在 RDB 数据的后面，在下一次做 RDB 持久化的时候将 AOF 的数据重新以 RDB 的形式写入文件。</p>
<p>这种方式既可以提高读写和恢复效率，也可以减少文件大小，同时可以保证数据的完整性。</p>
<p>在此种策略的持久化过程中，子进程会通过管道从父进程读取增量数据，在以 RDB 格式保存全量数据时，也会通过管道读取数据，同时不会造成管道阻塞。</p>
<p>可以说，在此种方式下的持久化文件，前半段是 RDB 格式的全量数据，后半段是 AOF 格式的增量数据。此种方式是目前较为推荐的一种持久化方式。</p>
<h2 id="Redis-数据的恢复"><a href="#Redis-数据的恢复" class="headerlink" title="Redis 数据的恢复"></a>Redis 数据的恢复</h2><p>RDB 和 AOF 文件共存情况下的恢复流程如下图：</p>
<p><img src="image-20200906230635766.png" alt="image-20200906230635766"></p>
<p>从图可知，Redis 启动时会先检查 AOF 是否存在，如果 AOF 存在则直接加载 AOF，如果不存在 AOF，则直接加载 RDB 文件。</p>
<h1 id="Pineline"><a href="#Pineline" class="headerlink" title="Pineline"></a>Pineline</h1><p>Pipeline 和 Linux 的管道类似，它可以让 Redis 批量执行指令。</p>
<p>Redis 基于请求/响应模型，单个请求处理需要一一应答。如果需要同时执行大量命令，则每条命令都需要等待上一条命令执行完毕后才能继续执行，这中间不仅仅多了 RTT，还多次使用了系统 IO。</p>
<p>Pipeline 由于可以批量执行指令，所以可以节省多次 IO 和请求响应往返的时间。但是如果指令之间存在依赖关系，则建议分批发送指令。</p>
<h1 id="Redis-的同步机制"><a href="#Redis-的同步机制" class="headerlink" title="Redis 的同步机制"></a>Redis 的同步机制</h1><p><strong>主从同步原理</strong></p>
<p>Redis 一般是使用一个 <strong>Master 节点来进行写操作</strong>，而若干个 <strong>Slave 节点进行读操作</strong>，Master 和 Slave 分别代表了一个个不同的Redis Server 实例。</p>
<p>另外定期的<strong>数据备份操作也是单独选择一个 Slave 去完成</strong>，这样可以最大程度发挥 Redis 的性能，为的是保证数据的弱一致性和最终一致性。</p>
<p>另外，Master 和 Slave 的数据不是一定要即时同步的，但是在一段时间后 Master 和 Slave 的数据是趋于同步的，这就是最终一致性。</p>
<p><img src="image-20200906230950151.png" alt="image-20200906230950151"></p>
<h4 id="全同步过程"><a href="#全同步过程" class="headerlink" title="全同步过程"></a>全同步过程</h4><ul>
<li>Slave 发送 Sync 命令到 Master。</li>
<li>Master 启动一个后台进程，将 Redis 中的数据快照保存到文件中。</li>
<li>Master 将保存数据快照期间接收到的写命令缓存起来。</li>
<li>Master 完成写文件操作后，将该文件发送给 Slave。</li>
<li>使用新的 AOF 文件替换掉旧的 AOF 文件。</li>
<li>Master 将这期间收集的增量写命令发送给 Slave 端。</li>
</ul>
<h4 id="增量同步过程"><a href="#增量同步过程" class="headerlink" title="增量同步过程"></a>增量同步过程</h4><ul>
<li>Master 接收到用户的操作指令，判断是否需要传播到 Slave。</li>
<li>将操作记录追加到 AOF 文件。</li>
<li>将操作传播到其他 Slave：对齐主从库；往响应缓存写入指令。</li>
<li>将缓存中的数据发送给 Slave。</li>
</ul>
<h2 id="Redis-Sentinel（哨兵）"><a href="#Redis-Sentinel（哨兵）" class="headerlink" title="Redis Sentinel（哨兵）"></a><strong>Redis Sentinel（哨兵）</strong></h2><p>主从模式弊端：当 Master 宕机后，Redis 集群将不能对外提供写入操作。Redis Sentinel 可解决这一问题。</p>
<p>解决主从同步 Master 宕机后的主从切换问题：</p>
<ul>
<li><strong>监控：</strong>检查主从服务器是否运行正常。</li>
<li><strong>提醒：</strong>通过 API 向管理员或者其它应用程序发送故障通知。</li>
<li><strong>自动故障迁移：</strong>主从切换（在 Master 宕机后，将其中一个 Slave 转为 Master，其他的 Slave 从该节点同步数据）。</li>
</ul>
<h1 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h1><h2 id="如何从海量数据里快速找到所需？"><a href="#如何从海量数据里快速找到所需？" class="headerlink" title="如何从海量数据里快速找到所需？"></a><strong>如何从海量数据里快速找到所需？</strong></h2><h4 id="①分片"><a href="#①分片" class="headerlink" title="①分片"></a><strong>①分片</strong></h4><p>按照某种规则去划分数据，分散存储在多个节点上。通过将数据分到多个 Redis 服务器上，来减轻单个 Redis 服务器的压力。</p>
<h4 id="②一致性-Hash-算法"><a href="#②一致性-Hash-算法" class="headerlink" title="②一致性 Hash 算法"></a><strong>②一致性 Hash 算法</strong></h4><p>既然要将数据进行分片，那么通常的做法就是获取节点的 Hash 值，然后根据节点数求模。</p>
<p>但这样的方法有明显的弊端，当 Redis 节点数需要动态增加或减少的时候，会造成大量的 Key 无法被命中。所以 Redis 中引入了一致性 Hash 算法。</p>
<p>该算法对 2^32 取模，将 Hash 值空间组成虚拟的圆环，整个圆环按顺时针方向组织，每个节点依次为 0、1、2…2^32-1。</p>
<p>之后将每个服务器进行 Hash 运算，确定服务器在这个 Hash 环上的地址，确定了服务器地址后，对数据使用同样的 Hash 算法，将数据定位到特定的 Redis 服务器上。</p>
<p>如果定位到的地方没有 Redis 服务器实例，则继续顺时针寻找，找到的第一台服务器即该数据最终的服务器位置。</p>
<p><img src="image-20200906231524276.png" alt="image-20200906231524276"></p>
<h3 id="③Hash-环的数据倾斜问题"><a href="#③Hash-环的数据倾斜问题" class="headerlink" title="③Hash 环的数据倾斜问题"></a><strong>③Hash 环的数据倾斜问题</strong></h3><p>Hash 环在服务器节点很少的时候，容易遇到服务器节点不均匀的问题，这会造成数据倾斜，数据倾斜指的是被缓存的对象大部分集中在 Redis 集群的其中一台或几台服务器上。</p>
<p><img src="image-20200906231538437.png" alt="image-20200906231538437"></p>
<p>如上图，一致性 Hash 算法运算后的数据大部分被存放在 A 节点上，而 B 节点只存放了少量的数据，久而久之 A 节点将被撑爆。</p>
<p>针对这一问题，可以引入虚拟节点解决。简单地说，就是为每一个服务器节点计算多个 Hash，每个计算结果位置都放置一个此服务器节点，称为虚拟节点，可以在服务器 IP 或者主机名后放置一个编号实现。</p>
<p><img src="image-20200906231553173.png" alt="image-20200906231553173"></p>
<p>例如上图：将 NodeA 和 NodeB 两个节点分为 Node A#1-A#3，NodeB#1-B#3。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
              <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag"># 中间件</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/04/MYSQL%E4%B8%AD%E7%9A%84B+%E7%B4%A2%E5%BC%95%E6%A0%91/" rel="prev" title="MYSQL中的B+索引树">
      <i class="fa fa-chevron-left"></i> MYSQL中的B+索引树
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/06/redis%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C/" rel="next" title="redis使用操作">
      redis使用操作 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E6%B5%81%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84"><span class="nav-text">主流应用架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6-Memcache-%E5%92%8C-Redis-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">缓存中间件 Memcache 和 Redis 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E8%83%BD%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="nav-text">为什么 Redis 能这么快</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">Redis 的数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-text">String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash"><span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-text">List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-text">Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sorted-Set"><span class="nav-text">Sorted Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84-Redis-%E7%B1%BB%E5%9E%8B"><span class="nav-text">更高级的 Redis 类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#REDIS%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-text">REDIS函数常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%87%E8%AE%BE-Redis-%E4%B8%AD%E6%9C%89%E5%8D%81%E4%BA%BF%E6%9D%A1-Key%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BB%8E%E8%BF%99%E4%B9%88%E5%A4%9A-Key-%E4%B8%AD%E6%89%BE%E5%88%B0%E5%9B%BA%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84-Key%EF%BC%9F"><span class="nav-text">假设 Redis 中有十亿条 Key，如何从这么多 Key 中找到固定前缀的 Key？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">如何通过 Redis 实现分布式锁?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97"><span class="nav-text">如何实现异步队列?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">Redis 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB%EF%BC%88%E5%BF%AB%E7%85%A7%EF%BC%89%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">RDB（快照）持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BD%BD%E5%85%A5"><span class="nav-text">RDB 的创建与载入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%A6%E5%8F%91-RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">自动化触发 RDB 持久化的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BGSAVE-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">BGSAVE 的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-text">RDB 持久化方式的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">AOF 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E5%86%99%E7%8A%B6%E6%80%81"><span class="nav-text">保存写状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AF-AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">开启 AOF 持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99"><span class="nav-text">AOF后台重写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8CAOF%E9%87%8D%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">使用子进程进行AOF重写的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%AD%A3"><span class="nav-text">如何修正</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%88%E6%9E%9C"><span class="nav-text">效果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%88%90AOF%E9%87%8D%E5%86%99%E4%B9%8B%E5%90%8E"><span class="nav-text">完成AOF重写之后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91AOF%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">触发AOF后台重写的条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF-%E5%92%8C-RDB-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">AOF 和 RDB 的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-text">Redis 数据的恢复</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pineline"><span class="nav-text">Pineline</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-text">Redis 的同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">全同步过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B"><span class="nav-text">增量同步过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-Sentinel%EF%BC%88%E5%93%A8%E5%85%B5%EF%BC%89"><span class="nav-text">Redis Sentinel（哨兵）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E9%9B%86%E7%BE%A4"><span class="nav-text">Redis 集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%87%8C%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%E6%89%80%E9%9C%80%EF%BC%9F"><span class="nav-text">如何从海量数据里快速找到所需？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%88%86%E7%89%87"><span class="nav-text">①分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E4%B8%80%E8%87%B4%E6%80%A7-Hash-%E7%AE%97%E6%B3%95"><span class="nav-text">②一致性 Hash 算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%91%A2Hash-%E7%8E%AF%E7%9A%84%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E9%97%AE%E9%A2%98"><span class="nav-text">③Hash 环的数据倾斜问题</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
