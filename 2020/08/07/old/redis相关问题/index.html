<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="收集有关于redis的相关问题！">
<meta property="og:type" content="article">
<meta property="og:title" content="redis相关问题">
<meta property="og:url" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="收集有关于redis的相关问题！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907105816718.png">
<meta property="og:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907105847319.png">
<meta property="og:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907105952760.png">
<meta property="og:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907110007322.png">
<meta property="og:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907110056455.png">
<meta property="og:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907110133383.png">
<meta property="og:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907110159049.png">
<meta property="og:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907110209115.png">
<meta property="og:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907110332746.png">
<meta property="article:published_time" content="2020-08-07T01:34:33.000Z">
<meta property="article:modified_time" content="2020-08-07T01:34:33.000Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/image-20200907105816718.png">

<link rel="canonical" href="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>redis相关问题 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/07/old/redis%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis相关问题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-07 09:34:33" itemprop="dateCreated datePublished" datetime="2020-08-07T09:34:33+08:00">2020-08-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>收集有关于redis的相关问题！</p>
<a id="more"></a>

<h1 id="1、什么是Redis？"><a href="#1、什么是Redis？" class="headerlink" title="1、什么是Redis？"></a>1、什么是Redis？</h1><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h1 id="2、Redis相比memcached有哪些优势？"><a href="#2、Redis相比memcached有哪些优势？" class="headerlink" title="2、Redis相比memcached有哪些优势？"></a>2、Redis相比memcached有哪些优势？</h1><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p>
<p>(2) redis的速度比memcached快很多</p>
<p>(3) redis可以持久化其数据</p>
<h1 id="3、Redis支持哪几种数据类型？"><a href="#3、Redis支持哪几种数据类型？" class="headerlink" title="3、Redis支持哪几种数据类型？"></a>3、Redis支持哪几种数据类型？</h1><p>String、List、Set、Sorted Set、hashes</p>
<h1 id="4、Redis主要消耗什么物理资源？"><a href="#4、Redis主要消耗什么物理资源？" class="headerlink" title="4、Redis主要消耗什么物理资源？"></a>4、Redis主要消耗什么物理资源？</h1><p>内存。</p>
<h1 id="5、Redis的全称是什么？"><a href="#5、Redis的全称是什么？" class="headerlink" title="5、Redis的全称是什么？"></a>5、Redis的全称是什么？</h1><p>Remote Dictionary Server。</p>
<h1 id="6、Redis有哪几种数据淘汰策略？"><a href="#6、Redis有哪几种数据淘汰策略？" class="headerlink" title="6、Redis有哪几种数据淘汰策略？"></a>6、Redis有哪几种数据淘汰策略？</h1><p>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</p>
<p>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p>
<p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p>
<p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p>
<p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p>
<p>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p>
<h1 id="7、Redis官方为什么不提供Windows版本？"><a href="#7、Redis官方为什么不提供Windows版本？" class="headerlink" title="7、Redis官方为什么不提供Windows版本？"></a>7、Redis官方为什么不提供Windows版本？</h1><p>因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。</p>
<h1 id="8、一个字符串类型的值能存储最大容量是多少？"><a href="#8、一个字符串类型的值能存储最大容量是多少？" class="headerlink" title="8、一个字符串类型的值能存储最大容量是多少？"></a>8、一个字符串类型的值能存储最大容量是多少？</h1><p>512M</p>
<h1 id="9、为什么Redis需要把所有数据放到内存中？"><a href="#9、为什么Redis需要把所有数据放到内存中？" class="headerlink" title="9、为什么Redis需要把所有数据放到内存中？"></a>9、为什么Redis需要把所有数据放到内存中？</h1><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<h1 id="10、Redis集群方案应该怎么做？都有哪些方案？"><a href="#10、Redis集群方案应该怎么做？都有哪些方案？" class="headerlink" title="10、Redis集群方案应该怎么做？都有哪些方案？"></a>10、Redis集群方案应该怎么做？都有哪些方案？</h1><p>1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。 问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p>
<p>2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。</p>
<p>3.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p>
<p>4.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
<h1 id="11、Redis集群方案什么情况下会导致整个集群不可用？"><a href="#11、Redis集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="11、Redis集群方案什么情况下会导致整个集群不可用？"></a>11、Redis集群方案什么情况下会导致整个集群不可用？</h1><p>有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p>
<h1 id="12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"><a href="#12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？" class="headerlink" title="12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"></a>12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</h1><p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h1 id="13、Redis有哪些适合的场景？"><a href="#13、Redis有哪些适合的场景？" class="headerlink" title="13、Redis有哪些适合的场景？"></a>13、Redis有哪些适合的场景？</h1><p>（1）、会话缓存（Session Cache）</p>
<p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p>
<p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p>
<p>（2）、全页缓存（FPC）</p>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p>
<p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p>
<p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>（3）、队列</p>
<p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p>
<p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p>
<p>（4），排行榜/计数器</p>
<p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p>
<p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p>
<p>ZRANGE user_scores 0 10 WITHSCORES</p>
<p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p>
<p>（5）、发布/订阅</p>
<p>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</p>
<h1 id="14、Redis支持的Java客户端都有哪些？官方推荐用哪个？"><a href="#14、Redis支持的Java客户端都有哪些？官方推荐用哪个？" class="headerlink" title="14、Redis支持的Java客户端都有哪些？官方推荐用哪个？"></a>14、Redis支持的Java客户端都有哪些？官方推荐用哪个？</h1><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>
<h1 id="15、Redis和Redisson有什么关系？"><a href="#15、Redis和Redisson有什么关系？" class="headerlink" title="15、Redis和Redisson有什么关系？"></a>15、Redis和Redisson有什么关系？</h1><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
<h1 id="16、Jedis与Redisson对比有什么优缺点？"><a href="#16、Jedis与Redisson对比有什么优缺点？" class="headerlink" title="16、Jedis与Redisson对比有什么优缺点？"></a>16、Jedis与Redisson对比有什么优缺点？</h1><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<h1 id="17、Redis如何设置密码及验证密码？"><a href="#17、Redis如何设置密码及验证密码？" class="headerlink" title="17、Redis如何设置密码及验证密码？"></a>17、Redis如何设置密码及验证密码？</h1><p>设置密码：config set requirepass 123456</p>
<p>授权密码：auth 123456</p>
<h1 id="18、说说Redis哈希槽的概念？"><a href="#18、说说Redis哈希槽的概念？" class="headerlink" title="18、说说Redis哈希槽的概念？"></a>18、说说Redis哈希槽的概念？</h1><p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h1 id="19、Redis集群的主从复制模型是怎样的？"><a href="#19、Redis集群的主从复制模型是怎样的？" class="headerlink" title="19、Redis集群的主从复制模型是怎样的？"></a>19、Redis集群的主从复制模型是怎样的？</h1><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p>
<h1 id="20、Redis集群会有写操作丢失吗？为什么？"><a href="#20、Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="20、Redis集群会有写操作丢失吗？为什么？"></a>20、Redis集群会有写操作丢失吗？为什么？</h1><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h1 id="21、Redis集群之间是如何复制的？"><a href="#21、Redis集群之间是如何复制的？" class="headerlink" title="21、Redis集群之间是如何复制的？"></a>21、Redis集群之间是如何复制的？</h1><p>异步复制</p>
<h1 id="22、Redis集群最大节点个数是多少？"><a href="#22、Redis集群最大节点个数是多少？" class="headerlink" title="22、Redis集群最大节点个数是多少？"></a>22、Redis集群最大节点个数是多少？</h1><p>16384个。</p>
<h1 id="23、Redis集群如何选择数据库？"><a href="#23、Redis集群如何选择数据库？" class="headerlink" title="23、Redis集群如何选择数据库？"></a>23、Redis集群如何选择数据库？</h1><p>Redis集群目前无法做数据库选择，默认在0数据库。</p>
<h1 id="24、怎么测试Redis的连通性？"><a href="#24、怎么测试Redis的连通性？" class="headerlink" title="24、怎么测试Redis的连通性？"></a>24、怎么测试Redis的连通性？</h1><p>ping</p>
<h1 id="25、Redis中的管道有什么用？"><a href="#25、Redis中的管道有什么用？" class="headerlink" title="25、Redis中的管道有什么用？"></a>25、Redis中的管道有什么用？</h1><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<h1 id="26、怎么理解Redis事务？"><a href="#26、怎么理解Redis事务？" class="headerlink" title="26、怎么理解Redis事务？"></a>26、怎么理解Redis事务？</h1><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h1 id="27、Redis事务相关的命令有哪几个？"><a href="#27、Redis事务相关的命令有哪几个？" class="headerlink" title="27、Redis事务相关的命令有哪几个？"></a>27、Redis事务相关的命令有哪几个？</h1><p>MULTI、EXEC、DISCARD、WATCH</p>
<h1 id="28、Redis-key的过期时间和永久有效分别怎么设置？"><a href="#28、Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="28、Redis key的过期时间和永久有效分别怎么设置？"></a>28、Redis key的过期时间和永久有效分别怎么设置？</h1><p>EXPIRE和PERSIST命令。</p>
<h1 id="29、Redis如何做内存优化？"><a href="#29、Redis如何做内存优化？" class="headerlink" title="29、Redis如何做内存优化？"></a>29、Redis如何做内存优化？</h1><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.</p>
<h1 id="30、Redis回收进程如何工作的？"><a href="#30、Redis回收进程如何工作的？" class="headerlink" title="30、Redis回收进程如何工作的？"></a>30、Redis回收进程如何工作的？</h1><ol>
<li>一个客户端运行了新的命令，添加了新的数据。</li>
<li>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</li>
<li>一个新的命令被执行，等等。</li>
<li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</li>
</ol>
<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h1 id="31、Redis回收使用的是什么算法？"><a href="#31、Redis回收使用的是什么算法？" class="headerlink" title="31、Redis回收使用的是什么算法？"></a>31、Redis回收使用的是什么算法？</h1><p>LRU算法</p>
<h1 id="32、Redis如何做大量数据插入？"><a href="#32、Redis如何做大量数据插入？" class="headerlink" title="32、Redis如何做大量数据插入？"></a>32、Redis如何做大量数据插入？</h1><p>Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。</p>
<h1 id="33、为什么要做Redis分区？"><a href="#33、为什么要做Redis分区？" class="headerlink" title="33、为什么要做Redis分区？"></a>33、为什么要做Redis分区？</h1><p>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
<h1 id="34、你知道有哪些Redis分区实现方案？"><a href="#34、你知道有哪些Redis分区实现方案？" class="headerlink" title="34、你知道有哪些Redis分区实现方案？"></a>34、你知道有哪些Redis分区实现方案？</h1><ul>
<li>客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li>
<li>代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy</li>
<li>查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。</li>
</ul>
<h1 id="35、Redis分区有什么缺点？"><a href="#35、Redis分区有什么缺点？" class="headerlink" title="35、Redis分区有什么缺点？"></a>35、Redis分区有什么缺点？</h1><ul>
<li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li>
<li>同时操作多个key,则不能使用Redis事务.</li>
<li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.</li>
<li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li>
<li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。</li>
</ul>
<h1 id="36、Redis持久化数据和缓存怎么做扩容？"><a href="#36、Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="36、Redis持久化数据和缓存怎么做扩容？"></a>36、Redis持久化数据和缓存怎么做扩容？</h1><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<h1 id="37、分布式Redis是前期做还是后期规模上来了再做好？为什么？"><a href="#37、分布式Redis是前期做还是后期规模上来了再做好？为什么？" class="headerlink" title="37、分布式Redis是前期做还是后期规模上来了再做好？为什么？"></a>37、分布式Redis是前期做还是后期规模上来了再做好？为什么？</h1><p>既然Redis是如此的轻量（单实例只使用1M内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p>
<h1 id="38、Twemproxy是什么？"><a href="#38、Twemproxy是什么？" class="headerlink" title="38、Twemproxy是什么？"></a>38、Twemproxy是什么？</h1><p>Twemproxy是Twitter维护的（缓存）代理系统，代理Memcached的ASCII协议和Redis协议。它是单线程程序，使用c语言编写，运行起来非常快。它是采用Apache 2.0 license的开源软件。 Twemproxy支持自动分区，如果其代理的其中一个Redis节点不可用时，会自动将该节点排除（这将改变原来的keys-instances的映射关系，所以你应该仅在把Redis当缓存时使用Twemproxy)。 Twemproxy本身不存在单点问题，因为你可以启动多个Twemproxy实例，然后让你的客户端去连接任意一个Twemproxy实例。 Twemproxy是Redis客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。</p>
<h1 id="39、支持一致性哈希的客户端有哪些？"><a href="#39、支持一致性哈希的客户端有哪些？" class="headerlink" title="39、支持一致性哈希的客户端有哪些？"></a>39、支持一致性哈希的客户端有哪些？</h1><p>Redis-rb、Predis等。</p>
<h1 id="40、Redis与其他key-value存储有什么不同？"><a href="#40、Redis与其他key-value存储有什么不同？" class="headerlink" title="40、Redis与其他key-value存储有什么不同？"></a>40、Redis与其他key-value存储有什么不同？</h1><ol>
<li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li>
<li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li>
</ol>
<h1 id="41、Redis的内存占用情况怎么样？"><a href="#41、Redis的内存占用情况怎么样？" class="headerlink" title="41、Redis的内存占用情况怎么样？"></a>41、Redis的内存占用情况怎么样？</h1><p>给你举个例子： 100万个键值对（键是0到999999值是字符串“hello world”）在我的32位的Mac笔记本上 用了100MB。同样的数据放到一个key里只需要16MB， 这是因为键值有一个很大的开销。 在Memcached上执行也是类似的结果，但是相对Redis的开销要小一点点，因为Redis会记录类型信息引用计数等等。</p>
<p>当然，大键值对时两者的比例要好很多。</p>
<p>64位的系统比32位的需要更多的内存开销，尤其是键值对都较小时，这是因为64位的系统里指针占用了8个字节。 但是，当然，64位系统支持更大的内存，所以为了运行大型的Redis服务器或多或少的需要使用64位的系统。</p>
<h1 id="42、都有哪些办法可以降低Redis的内存使用情况呢？"><a href="#42、都有哪些办法可以降低Redis的内存使用情况呢？" class="headerlink" title="42、都有哪些办法可以降低Redis的内存使用情况呢？"></a>42、都有哪些办法可以降低Redis的内存使用情况呢？</h1><p>如果你使用的是32位的Redis实例，可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。</p>
<h1 id="43、查看Redis使用情况及状态信息用什么命令？"><a href="#43、查看Redis使用情况及状态信息用什么命令？" class="headerlink" title="43、查看Redis使用情况及状态信息用什么命令？"></a>43、查看Redis使用情况及状态信息用什么命令？</h1><p>info</p>
<h1 id="44、Redis的内存用完了会发生什么？"><a href="#44、Redis的内存用完了会发生什么？" class="headerlink" title="44、Redis的内存用完了会发生什么？"></a>44、Redis的内存用完了会发生什么？</h1><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h1 id="45、Redis是单线程的，如何提高多核CPU的利用率？"><a href="#45、Redis是单线程的，如何提高多核CPU的利用率？" class="headerlink" title="45、Redis是单线程的，如何提高多核CPU的利用率？"></a>45、Redis是单线程的，如何提高多核CPU的利用率？</h1><p>可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。</p>
<h1 id="46、一个Redis实例最多能存放多少的keys？List、Set、Sorted-Set他们最多能存放多少元素？"><a href="#46、一个Redis实例最多能存放多少的keys？List、Set、Sorted-Set他们最多能存放多少元素？" class="headerlink" title="46、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？"></a>46、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？</h1><p>理论上Redis可以处理多达232的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。</p>
<p>任何list、set、和sorted set都可以放232个元素。</p>
<p>换句话说，Redis的存储极限是系统中的可用内存值。</p>
<h1 id="47、Redis常见性能问题和解决方案？"><a href="#47、Redis常见性能问题和解决方案？" class="headerlink" title="47、Redis常见性能问题和解决方案？"></a>47、Redis常见性能问题和解决方案？</h1><p>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</p>
<p>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p>
<p>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</p>
<p>(4) 尽量避免在压力很大的主库上增加从库</p>
<p>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</p>
<p>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p>
<h1 id="48、Redis提供了哪几种持久化方式？"><a href="#48、Redis提供了哪几种持久化方式？" class="headerlink" title="48、Redis提供了哪几种持久化方式？"></a>48、Redis提供了哪几种持久化方式？</h1><ol>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储.</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</li>
<li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
<li>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始。</li>
</ol>
<h1 id="49、如何选择合适的持久化方式？"><a href="#49、如何选择合适的持久化方式？" class="headerlink" title="49、如何选择合适的持久化方式？"></a>49、如何选择合适的持久化方式？</h1><p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。</p>
<p>有很多用户都只使用AOF持久化，但并不推荐这种方式：因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外， 使用RDB还可以避免之前提到的AOF程序的bug。</p>
<h1 id="50、修改配置不重启Redis会实时生效吗？"><a href="#50、修改配置不重启Redis会实时生效吗？" class="headerlink" title="50、修改配置不重启Redis会实时生效吗？"></a>50、修改配置不重启Redis会实时生效吗？</h1><p>针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。</p>
<p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。</p>
<h1 id="51、为什么Redis能这么快"><a href="#51、为什么Redis能这么快" class="headerlink" title="51、为什么Redis能这么快"></a>51、为什么Redis能这么快</h1><pre><code>1.Redis完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高。
2.Redis使用单进程单线程模型的(K,V)数据库，将数据存储在内存中，存取均不会受到硬盘IO的限制，因此其执行速度极快，另外单线程也能处理高并发请求，还可以避免频繁上下文切换和锁的竞争，同时由于单线程操作，也可以避免各种锁的使用，进一步提高效率
3.数据结构简单，对数据操作也简单，Redis不使用表，不会强制用户对各个关系进行关联，不会有复杂的关系限制，其存储结构就是键值对，类似于HashMap，HashMap最大的优点就是存取的时间复杂度为O(1)
5.C语言编写，效率更高
6.Redis使用多路I/O复用模型，为非阻塞IO
7.有专门设计的RESP协议</code></pre><blockquote>
<p>针对第四点进行说明 -&gt;</p>
<p>常见的IO模型有四种：</p>
<ul>
<li>同步阻塞IO（Blocking IO）：即传统的IO模型。</li>
<li>同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</li>
<li>IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</li>
<li>异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO</li>
</ul>
<p>同步异步，阻塞非阻塞的概念：</p>
<p><img src="image-20200907105816718.png" alt="image-20200907105816718"></p>
<p><img src="image-20200907105847319.png" alt="image-20200907105847319"></p>
<p>假设Redis采用同步阻塞IO：</p>
<p>Redis主程序（服务端 单线程）-&gt; 多个客户端连接（真实情况是如开发人员连接redis，程序 redispool连接redis），这每一个都对应着一个客户端，假设为100个客户端，其中一个进行交互时候，如果采用同步阻塞式，那么剩下的99个都需要原地等待，这势必是不科学的。</p>
<p>IO多路复用</p>
<p>Redis 采用  I/O 多路复用模型</p>
<p>I/O 多路复用模型中，最重要的函数调用就是 <code>select</code>，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，<code>select</code> 方法就会返回可读以及可写的文件描述符个数</p>
<pre><code>注：redis默认使用的是更加优化的算法：epoll</code></pre><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">select</th>
<th align="left">poll</th>
<th align="left">epoll</th>
</tr>
</thead>
<tbody><tr>
<td align="left">操作方式</td>
<td align="left">遍历</td>
<td align="left">遍历</td>
<td align="left">回调</td>
</tr>
<tr>
<td align="left">底层实现</td>
<td align="left">数组</td>
<td align="left">链表</td>
<td align="left">哈希表</td>
</tr>
<tr>
<td align="left">IO效率</td>
<td align="left">每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td align="left">每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td align="left">事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1)</td>
</tr>
<tr>
<td align="left">最大连接数</td>
<td align="left">1024（x86）或2048（x64）</td>
<td align="left">无上限</td>
<td align="left">无上限</td>
</tr>
</tbody></table>
<p>所以我们可以说Redis是这样的：服务端单线程毫无疑问，多客户端连接时候，如果客户端没有发起任何动作，则服务端会把其视为不活跃的IO流，将其挂起，当有真正的动作时，会通过回调的方式执行相应的事件</p>
</blockquote>
<h1 id="52、从海量Key里查询出某一个固定前缀的Key"><a href="#52、从海量Key里查询出某一个固定前缀的Key" class="headerlink" title="52、从海量Key里查询出某一个固定前缀的Key"></a>52、从海量Key里查询出某一个固定前缀的Key</h1><blockquote>
<p>A. 笨办法：KEYS [pattern]  注意key很多的话，这样做肯定会出问题，造成redis崩溃</p>
<p>B. SCAN cursor [MATCH pattern] [COUNT count] 游标方式查找</p>
</blockquote>
<h1 id="53、如何通过Redis实现分布式锁"><a href="#53、如何通过Redis实现分布式锁" class="headerlink" title="53、如何通过Redis实现分布式锁"></a>53、如何通过Redis实现分布式锁</h1><pre><code>见上文</code></pre><h1 id="54、如何实现异步队列"><a href="#54、如何实现异步队列" class="headerlink" title="54、如何实现异步队列"></a>54、如何实现异步队列</h1><pre><code>上文说到利用 redis-list 实现队列
假设场景:A服务生产数据 - B服务消费数据，即可利用此种模型构造-生产消费者模型

1. 使用Redis中的List作为队列
2.使用BLPOP key [key...] timeout  -&gt; LPOP key [key ...] timeout:阻塞直到队列有消息或者超时
（方案二：解决方案一中，拿数据的时，生产者尚未生产的情况）

3.pub/sub：主题订阅者模式
基于reds的终极方案，上文有介绍，基于发布/订阅模式
缺点:消息的发布是无状态的，无法保证可达。对于发布者来说，消息是“即发即失”的，此时如果某个消费者在生产者发布消息时下线，重新上线之后，是无法接收该消息的，要解决该问题需要使用专业的消息队列</code></pre><h1 id="55、Redis支持的数据类型？"><a href="#55、Redis支持的数据类型？" class="headerlink" title="55、Redis支持的数据类型？"></a>55、Redis支持的数据类型？</h1><pre><code>见上文</code></pre><h1 id="56、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"><a href="#56、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？" class="headerlink" title="56、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"></a>56、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</h1><blockquote>
<p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p>Redis 提供了两种持久化方式:RDB（默认） 和AOF</p>
<p><strong>RDB：</strong></p>
<p>rdb是Redis DataBase缩写</p>
<p>功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数</p>
<p><img src="image-20200907105952760.png" alt="image-20200907105952760"></p>
<p>RDB:  把当前进程数据生成快照文件保存到硬盘的过程。分为手动触发和自动触发</p>
<p>手动触发 -&gt;  save (不推荐，阻塞严重)  bgsave -&gt; （save的优化版，微秒级阻塞）</p>
<pre><code>shutdowm 关闭服务时，如果没有配置AOF，则会使用bgsave持久化数据</code></pre><p><strong>bgsave - 工作原理</strong></p>
<p>会从当前父进程fork一个子进程，然后生成rdb文件</p>
<p>缺点：频率低，无法做到实时持久化</p>
<p><strong>AOF:</strong></p>
<p>Aof是Append-only file缩写，AOF文件存储的也是RESP协议</p>
<p><img src="image-20200907110007322.png" alt="image-20200907110007322"></p>
<p>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作</p>
<p>aof写入保存：</p>
<p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件</p>
<p>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p>
<p><strong>存储结构:</strong></p>
<p>内容是redis通讯协议(RESP )格式的命令文本存储</p>
<p><strong>原理：</strong></p>
<p>相当于存储了redis的执行命令(类似mysql的sql语句日志)，数据的完整性和一致性更高</p>
<p><strong>比较</strong>：</p>
<p>1、aof文件比rdb更新频率高</p>
<p>2、aof比rdb更安全</p>
<p>3、rdb性能更好</p>
<p>PS：正确停止redis服务 应该基于连接命令 加再上 shutdown -&gt; 否则数据持久化会出现问题</p>
</blockquote>
<h1 id="57、redis通讯协议-RESP"><a href="#57、redis通讯协议-RESP" class="headerlink" title="57、redis通讯协议(RESP)"></a>57、redis通讯协议(RESP)</h1><blockquote>
<p>Redis 即 REmote Dictionary Server (远程字典服务)；</p>
<p>而Redis的协议规范是 Redis Serialization Protocol (Redis序列化协议)</p>
<p>RESP 是redis客户端和服务端之前使用的一种通讯协议；</p>
<p>RESP 的特点：实现简单、快速解析、可读性好</p>
<p>协议如下：</p>
<p>客户端以规定格式的形式发送命令给服务器</p>
<pre><code>set key value 协议翻译如下：

* 3    -&gt;  表示以下有几组命令

$ 3    -&gt;  表示命令长度是3
SET

$6     -&gt;  表示长度是6
keykey

$5     -&gt;  表示长度是5
value

完整即：
* 3
$ 3
SET
$6
keykey
$5 
value</code></pre><p>服务器在执行最后一条命令后，返回结果，返回格式如下：</p>
<p>For Simple Strings the first byte of the reply is “+” 回复</p>
<p>For Errors the first byte of the reply is “-“ 错误</p>
<p>For Integers the first byte of the reply is “:” 整数</p>
<p>For Bulk Strings the first byte of the reply is “$” 字符串</p>
<p>For Arrays the first byte of the reply is “*” 数组</p>
</blockquote>
<pre><code>// 伪造6379 redis-服务端，监听  jedis发送的协议内容
public class SocketApp {

    /***
     * 监听 6379 传输的数据
     * JVM端口需要进行设置
     */
    public static void main(String[] args)  {
        try {
            ServerSocket serverSocket = new ServerSocket(6379);
            Socket redis = serverSocket.accept();
            byte[] result = new byte[2048];
            redis.getInputStream().read(result);
            System.out.println(new String(result));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

// jedis连接-发送命令
public class App {
    public static void main(String[] args){
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;);
        jedis.set(&quot;key&quot;, &quot;This is value.&quot;);
        jedis.close();
    }
}

// 监听命令内容如下：
*3
$3
SET
$3
key
$14</code></pre><h1 id="58、redis架构有哪些"><a href="#58、redis架构有哪些" class="headerlink" title="58、redis架构有哪些"></a>58、redis架构有哪些</h1><h2 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><pre><code>Master-slave  主从赋值，此种结构可以考虑关闭master的持久化，只让从数据库进行持久化，另外可以通过读写分离，缓解主服务器压力</code></pre><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><pre><code>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：

监控（Monitoring）：    Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。

提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。

自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。

特点：
1、保证高可用
2、监控各个节点
3、自动故障迁移

缺点：主从模式，切换需要时间丢数据
没有解决 master 写的压力</code></pre><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><blockquote>
<p><img src="image-20200907110056455.png" alt="image-20200907110056455"></p>
<p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：</p>
<p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p>
<p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p>
<p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p>
<p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p>
<p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p>
<p>缺点：</p>
<p>1、资源隔离性较差，容易出现相互影响的情况。</p>
<p>2、数据通过异步复制,不保证数据的强一致性</p>
</blockquote>
<h1 id="59、Redis集群-如何从海量数据里快速找到所需？"><a href="#59、Redis集群-如何从海量数据里快速找到所需？" class="headerlink" title="59、Redis集群-如何从海量数据里快速找到所需？"></a>59、Redis集群-如何从海量数据里快速找到所需？</h1><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>按照某种规则去划分数据，分散存储在多个节点上。通过将数据分到多个Redis服务器上，来减轻单个Redis服务器的压力。</p>
<h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h2><p>既然要将数据进行分片，那么通常的做法就是获取节点的Hash值，然后根据节点数求模，但这样的方法有明显的弊端，当Redis节点数需要动态增加或减少的时候，会造成大量的Key无法被命中。所以Redis中引入了<strong>一致性Hash算法</strong>。该算法<strong>对2^32 取模，将Hash值空间组成虚拟的圆环</strong>，整个圆环按<strong>顺时针</strong>方向组织，每个节点依次为0、1、2…2^32-1，之后将每个服务器进行Hash运算，确定服务器在这个Hash环上的地址，确定了服务器地址后，对数据使用同样的Hash算法，将数据定位到特定的Redis服务器上。如果定位到的地方没有Redis服务器实例，则继续顺时针寻找，找到的第一台服务器即该数据最终的服务器位置。</p>
<p><img src="image-20200907110133383.png" alt="image-20200907110133383"></p>
<p>​                                                                                                                        一致性Hash算法</p>
<h2 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h2><p>Hash环在服务器节点很少的时候，容易遇到服务器节点不均匀的问题，这会造成<strong>数据倾斜</strong>，数据倾斜指的是被缓存的对象大部分集中在Redis集群的其中一台或几台服务器上。</p>
<p><img src="image-20200907110159049.png" alt="image-20200907110159049"></p>
<p>如上图，一致性Hash算法运算后的数据大部分被存放在A节点上，而B节点只存放了少量的数据，久而久之A节点将被撑爆。<strong>引入虚拟节点</strong></p>
<p><img src="image-20200907110209115.png" alt="image-20200907110209115"></p>
<p>例如上图：将NodeA和NodeB两个节点分为Node A#1-A#3 NodeB#1-B#3。</p>
<h1 id="60、什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？"><a href="#60、什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？" class="headerlink" title="60、什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？"></a>60、什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？</h1><blockquote>
<p>缓存穿透</p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>如何避免？</p>
<p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
<p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p>
<p>3：由于请求参数是不合法的（每次都请求不存在的参数），于是我们可以使用布隆过滤器（Bloomfilter）或压缩filter提前进行拦截，不合法就不让这个请求进入到数据库层</p>
<p>缓存雪崩</p>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>
<p>如何避免？</p>
<p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p>
<p>3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<p>4：启用限流策略，尽量避免数据库被干掉</p>
<p>缓存击穿</p>
<p>概念 一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p>
<p>解决方案 A. 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key</p>
<p>B. 服务层处理 - 方法加锁 + 双重校验：</p>
<pre><code>// 锁-实例
private Lock lock = new ReentrantLock();

public String getProductImgUrlById(String id){
    // 获取缓存
    String product = jedisClient.get(PRODUCT_KEY + id);
    if (null == product) {
        // 如果没有获取锁等待3秒，SECONDS代表：秒
        try {
            if (lock.tryLock(3, TimeUnit.SECONDS)) {
                try {
                    // 获取锁后再查一次，查到了直接返回结果
                    product = jedisClient.get(PRODUCT_KEY + id);
                    if (null == product) {
                        // ....
                    }
                    return product;
                } catch (Exception e) {
                    product = jedisClient.get(PRODUCT_KEY + id);
                } finally {
                    // 释放锁（成功、失败都必须释放，如果是lock.tryLock()方法会一直阻塞在这）
                    lock.unlock();
                }
            } else {
                product = jedisClient.get(PRODUCT_KEY + id);
            }
        } catch (InterruptedException e) {
            product = jedisClient.get(PRODUCT_KEY + id);
        }
    }
    return product;
}</code></pre></blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">解释</th>
<th align="left">基础解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left">缓存穿透</td>
<td align="left">访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉</td>
<td align="left">1.采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；2.访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间</td>
</tr>
<tr>
<td align="left">缓存雪崩</td>
<td align="left">大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩</td>
<td align="left">可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效</td>
</tr>
<tr>
<td align="left">缓存击穿</td>
<td align="left">一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增</td>
<td align="left">在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key</td>
</tr>
</tbody></table>
<h1 id="61、缓存与数据库双写一致"><a href="#61、缓存与数据库双写一致" class="headerlink" title="61、缓存与数据库双写一致"></a>61、缓存与数据库双写一致</h1><blockquote>
<p>如果仅仅是读数据，没有此类问题</p>
<p>如果是新增数据，也没有此类问题</p>
<p>当数据需要更新时，如何保证缓存与数据库的双写一致性？</p>
<p>三种更新策略：</p>
<ol>
<li>先更新数据库，再更新缓存  -&gt;</li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存</li>
</ol>
<p>方案一：并发的时候，执行顺序无法保证，可能A先更新数据库，但B后更新数据库但先更新缓存</p>
<p>加锁的话，确实可以避免，但这样吞吐量会下降，可以根据业务场景考虑</p>
<p>方案二：该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形: （1）请求A进行写操作，删除缓存 （2）请求B查询发现缓存不存在 （3）请求B去数据库查询得到旧值 （4）请求B将旧值写入缓存 （5）请求A将新值写入数据库</p>
<p>因此采用：<strong>采用延时双删策略</strong>  即进入逻辑就删除Key，执行完操作，延时再删除key</p>
<p>方案三：更新数据库 - 删除缓存  可能出现问题的场景：</p>
<p>（1）缓存刚好失效 （2）请求A查询数据库，得一个旧值 （3）请求B将新值写入数据库 （4）请求B删除缓存 （5）请求A将查到的旧值写入缓存</p>
<p>先天条件要求：请求第二步的读取操作耗时要大于更新操作，条件较为苛刻</p>
<p>但如果真的发生怎么处理？</p>
<p>A. 给键设置合理的过期时间</p>
<p>B. 异步延时删除key</p>
</blockquote>
<h1 id="62、何保证Redis中的数据都是热点数据"><a href="#62、何保证Redis中的数据都是热点数据" class="headerlink" title="62、何保证Redis中的数据都是热点数据"></a>62、何保证Redis中的数据都是热点数据</h1><blockquote>
<p>A. 可以通过手工或者主动方式，去加载热点数据</p>
<p>B. Redis有其自己的数据淘汰策略：</p>
<p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p>
<ol>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction（驱逐）：禁止驱逐数据</li>
</ol>
</blockquote>
<h1 id="63、Redis的并发竞争问题如何解决"><a href="#63、Redis的并发竞争问题如何解决" class="headerlink" title="63、Redis的并发竞争问题如何解决?"></a>63、Redis的并发竞争问题如何解决?</h1><pre><code>即多线程同时操作统一Key的解决办法：

Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成

对此有多种解决方法：
A：条件允许的情况下，请使用redis自带的incr命令,decr命令
B：乐观锁方式
watch price
get price $price
$price = $price + 10
multi
set price $price
exec

C：针对客户端，操作同一个key的时候，进行加锁处理
D：场景允许的话，使用setnx 实现</code></pre><h1 id="64、Redis回收进程如何工作的-Redis回收使用的是什么算法"><a href="#64、Redis回收进程如何工作的-Redis回收使用的是什么算法" class="headerlink" title="64、Redis回收进程如何工作的? Redis回收使用的是什么算法?"></a>64、Redis回收进程如何工作的? Redis回收使用的是什么算法?</h1><blockquote>
<p>62 中提到过，当所需内存超过配置的最大内存时，redis会启用数据淘汰规则</p>
<p>默认规则是：# maxmemory-policy noeviction</p>
<p>即只允许读，无法继续添加key</p>
<p>因此常需要配置淘汰策略，比如LRU算法</p>
<p><img src="image-20200907110332746.png" alt="image-20200907110332746"></p>
<pre><code>LRU算法最为精典的实现，就是HashMap+Double LinkedList，时间复杂度为O(1)</code></pre></blockquote>
<h1 id="65、Redis大批量增加数据"><a href="#65、Redis大批量增加数据" class="headerlink" title="65、Redis大批量增加数据"></a>65、Redis大批量增加数据</h1><p>参考文章：<a href="https://www.cnblogs.com/PatrickLiu/p/8548580.html" target="_blank" rel="noopener">https://www.cnblogs.com/PatrickLiu/p/8548580.html</a></p>
<blockquote>
<p>使用管道模式，运行的命令如下所示：</p>
<pre><code>cat data.txt | redis-cli --pipe</code></pre><p>data.txt文本：</p>
<pre><code>SET Key0 Value0
SET Key1 Value1
...
SET KeyN ValueN

# 或者是 RESP协议内容 - 注意文件编码！！！

*8
$5
HMSET
$8
person:1
$2
id
$1
1</code></pre><p>这将产生类似于这样的输出：</p>
<pre><code>All data transferred. Waiting for the last reply...
Last reply received from server.
errors: 0, replies: 1000000</code></pre><p>redis-cli实用程序还将确保只将从Redis实例收到的错误重定向到标准输出</p>
<p>演示：</p>
<pre><code>cat redis_commands.txt | redis-cli -h 192.168.127.130 -p 6379 [-a &quot;password&quot;] -n 0 --pipe

All data transferred.Waiting for the last reply...
Last reply received from server.
errors:0，replies：10000000</code></pre><p><code>mysql数据快速导入到redis 实战：</code> 文件详情：可见Redis-通道实战</p>
<p>博文：<a href="https://www.cnblogs.com/tommy-huang/p/4703514.html" target="_blank" rel="noopener">https://www.cnblogs.com/tommy-huang/p/4703514.html</a></p>
<pre><code># 1.准备一个table
create database  if not exists `test`;
use `test`;
CREATE TABLE `person` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(200) NOT NULL,
  `age` varchar(200) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

# 2.插入七八万条数据

# 3.SQL查询，将其转化为 RESP协议命令   Linux 版本： -&gt; 不要在windows环境试，没啥意义
SELECT CONCAT(
   &quot;*8\r\n&quot;,
   &#39;$&#39;,LENGTH(redis_cmd),&#39;\r\n&#39;,redis_cmd,&#39;\r\n&#39;,
   &#39;$&#39;,LENGTH(redis_key),&#39;\r\n&#39;,redis_key,&#39;\r\n&#39;,
   &#39;$&#39;,LENGTH(hkey1),&#39;\r\n&#39;,hkey1,&#39;\r\n&#39;,&#39;$&#39;,LENGTH(hval1),&#39;\r\n&#39;,hval1,&#39;\r\n&#39;,
   &#39;$&#39;,LENGTH(hkey2),&#39;\r\n&#39;,hkey2,&#39;\r\n&#39;,&#39;$&#39;,LENGTH(hval2),&#39;\r\n&#39;,hval2,&#39;\r\n&#39;,
   &#39;$&#39;,LENGTH(hkey3),&#39;\r\n&#39;,hkey3,&#39;\r\n&#39;,&#39;$&#39;,LENGTH(hval3),&#39;\r\n&#39;,hval3,&#39;\r&#39;
)FROM(
   SELECT &#39;HMSET&#39; AS redis_cmd,
   concat_ws(&#39;:&#39;,&#39;person&#39;, id) AS redis_key,
   &#39;id&#39; AS hkey1, id AS hval1,
   &#39;name&#39; AS hkey2, name AS hval2,
   &#39;age&#39; AS hkey3, age AS hval3
   From person
)AS t

# 4.如果用的就是线上数据库+线上Linux -&gt; 把sql存到 order.sql，进行执行
mysql -uroot -p123456 test --default-character-set=utf8 --skip-column-names --raw &lt; order.sql  
|
redis-cli -h 127.0.0.1 -p 6379 -a 123456 --pipe

# 5.本地数据库+线上redis
利用Navicat导出数据 -&gt; data.txt，清理格式（导出来的数据里面各种 &quot; 符号），全局替换即可
cat data.txt | redis-cli -h 127.0.0.1 -p 6379 -a 123456  --pipe

81921条数据 一瞬间导入完成

注意事项：RESP协议要求，不要有莫名其妙的字符，注意文件类型是Unix编码类型</code></pre></blockquote>
<h1 id="66、延申：布隆过滤器"><a href="#66、延申：布隆过滤器" class="headerlink" title="66、延申：布隆过滤器"></a>66、延申：布隆过滤器</h1><blockquote>
<p>数据结构及算法篇 / 布隆过滤器</p>
<p>Redis 实现</p>
<p>redis 4.X 以上 提供 布隆过滤器插件</p>
<p>centos中安装redis插件bloom-filter：<a href="https://blog.csdn.net/u013030276/article/details/88350641" target="_blank" rel="noopener">https://blog.csdn.net/u013030276/article/details/88350641</a></p>
<p>语法：<em>[bf.add  key  options]</em></p>
<p>语法：[bf.exists  key  options]</p>
<p>注意: <code>redis 布隆过滤器提供的是 最大内存512M，2亿数据，万分之一的误差率</code></p>
</blockquote>
<h1 id="67、Lua脚本相关"><a href="#67、Lua脚本相关" class="headerlink" title="67、Lua脚本相关"></a>67、Lua脚本相关</h1><p>使用Lua脚本的好处：</p>
<ul>
<li>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延</li>
<li>原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。因此在编写脚本的过程中无需担心会出现竞态条件，无需使用事务</li>
<li>复用，客户端发送的脚本会永久存在redis中，这样，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑</li>
</ul>
<pre><code>@RequestMapping(&quot;/testLua&quot;)
public String testLua () {

    String key   = &quot;mylock&quot;;
    String value = &quot;xxxxxxxxxxxxxxx&quot;;

    //        if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1]
    //            then
    //                return redis.call(&#39;del&#39;, KEYS[1])
    //        else
    //            return 0
    //        end

    // lua脚本，用来释放分布式锁 - 如果使用的较多，可以封装到文件中, 再进行调用
    String luaScript = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end&quot;;
    Object eval = jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value));
    return eval.toString();
}</code></pre><h1 id="68、性能相关-Redis慢查询分析"><a href="#68、性能相关-Redis慢查询分析" class="headerlink" title="68、性能相关 - Redis慢查询分析"></a>68、性能相关 - Redis慢查询分析</h1><blockquote>
<p>redis 命令会放在redis内置队列中，然后主线程一个个执行，因此 其中一个 命令执行时间过长，会造成成批量的阻塞</p>
<p><code>命令：</code>slowlog get 获取慢查询记录 slowlog len 获取慢查询记录量 (慢查询队列是先进先出的，因此新的值在满载的时候，旧的会出去)</p>
<p>Redis 慢查询 -&gt; 执行阶段耗时过长</p>
<p><code>conf文件设置：</code>slowlog-low-slower-than 10000 -&gt; 10000微秒,10毫秒 (默认) 0 -&gt; 记录所有命令 -1 -&gt; 不记录命令 slow-max-len 存放的最大条数</p>
<p><code>慢查询导致原因: value 值过大，解决办法:</code>数据分段（更细颗粒度存放数据）</p>
</blockquote>
<h1 id="69、如何提高Redis处理效率-基于Jedis-的批量操作-Pipelined"><a href="#69、如何提高Redis处理效率-基于Jedis-的批量操作-Pipelined" class="headerlink" title="69、如何提高Redis处理效率? 基于Jedis 的批量操作 Pipelined"></a>69、如何提高Redis处理效率? 基于Jedis 的批量操作 Pipelined</h1><pre><code>Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);
Pipeline pipelined = jedis.pipelined();
for (String key : keys) {
    pipelined.del(key);
}

pipelined.sync();
jedis.close();

// pipelined 实际是封装过一层的指令集 -&gt;  实际应用的还是单条指令，但是节省了网络传输开销（服务端到Redis环境的网络开销）</code></pre>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
              <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag"># 中间件</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/06/old/redis%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C/" rel="prev" title="redis使用操作">
      <i class="fa fa-chevron-left"></i> redis使用操作
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/08/old/os%E7%9A%84io%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F/" rel="next" title="os的io操作模式">
      os的io操作模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、什么是Redis？"><span class="nav-text">1、什么是Redis？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、Redis相比memcached有哪些优势？"><span class="nav-text">2、Redis相比memcached有哪些优势？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、Redis支持哪几种数据类型？"><span class="nav-text">3、Redis支持哪几种数据类型？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、Redis主要消耗什么物理资源？"><span class="nav-text">4、Redis主要消耗什么物理资源？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、Redis的全称是什么？"><span class="nav-text">5、Redis的全称是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、Redis有哪几种数据淘汰策略？"><span class="nav-text">6、Redis有哪几种数据淘汰策略？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7、Redis官方为什么不提供Windows版本？"><span class="nav-text">7、Redis官方为什么不提供Windows版本？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8、一个字符串类型的值能存储最大容量是多少？"><span class="nav-text">8、一个字符串类型的值能存储最大容量是多少？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9、为什么Redis需要把所有数据放到内存中？"><span class="nav-text">9、为什么Redis需要把所有数据放到内存中？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10、Redis集群方案应该怎么做？都有哪些方案？"><span class="nav-text">10、Redis集群方案应该怎么做？都有哪些方案？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11、Redis集群方案什么情况下会导致整个集群不可用？"><span class="nav-text">11、Redis集群方案什么情况下会导致整个集群不可用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"><span class="nav-text">12、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13、Redis有哪些适合的场景？"><span class="nav-text">13、Redis有哪些适合的场景？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14、Redis支持的Java客户端都有哪些？官方推荐用哪个？"><span class="nav-text">14、Redis支持的Java客户端都有哪些？官方推荐用哪个？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15、Redis和Redisson有什么关系？"><span class="nav-text">15、Redis和Redisson有什么关系？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16、Jedis与Redisson对比有什么优缺点？"><span class="nav-text">16、Jedis与Redisson对比有什么优缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17、Redis如何设置密码及验证密码？"><span class="nav-text">17、Redis如何设置密码及验证密码？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18、说说Redis哈希槽的概念？"><span class="nav-text">18、说说Redis哈希槽的概念？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19、Redis集群的主从复制模型是怎样的？"><span class="nav-text">19、Redis集群的主从复制模型是怎样的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20、Redis集群会有写操作丢失吗？为什么？"><span class="nav-text">20、Redis集群会有写操作丢失吗？为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21、Redis集群之间是如何复制的？"><span class="nav-text">21、Redis集群之间是如何复制的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22、Redis集群最大节点个数是多少？"><span class="nav-text">22、Redis集群最大节点个数是多少？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23、Redis集群如何选择数据库？"><span class="nav-text">23、Redis集群如何选择数据库？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24、怎么测试Redis的连通性？"><span class="nav-text">24、怎么测试Redis的连通性？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25、Redis中的管道有什么用？"><span class="nav-text">25、Redis中的管道有什么用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26、怎么理解Redis事务？"><span class="nav-text">26、怎么理解Redis事务？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27、Redis事务相关的命令有哪几个？"><span class="nav-text">27、Redis事务相关的命令有哪几个？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28、Redis-key的过期时间和永久有效分别怎么设置？"><span class="nav-text">28、Redis key的过期时间和永久有效分别怎么设置？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29、Redis如何做内存优化？"><span class="nav-text">29、Redis如何做内存优化？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30、Redis回收进程如何工作的？"><span class="nav-text">30、Redis回收进程如何工作的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31、Redis回收使用的是什么算法？"><span class="nav-text">31、Redis回收使用的是什么算法？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32、Redis如何做大量数据插入？"><span class="nav-text">32、Redis如何做大量数据插入？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33、为什么要做Redis分区？"><span class="nav-text">33、为什么要做Redis分区？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34、你知道有哪些Redis分区实现方案？"><span class="nav-text">34、你知道有哪些Redis分区实现方案？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35、Redis分区有什么缺点？"><span class="nav-text">35、Redis分区有什么缺点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36、Redis持久化数据和缓存怎么做扩容？"><span class="nav-text">36、Redis持久化数据和缓存怎么做扩容？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37、分布式Redis是前期做还是后期规模上来了再做好？为什么？"><span class="nav-text">37、分布式Redis是前期做还是后期规模上来了再做好？为什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38、Twemproxy是什么？"><span class="nav-text">38、Twemproxy是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39、支持一致性哈希的客户端有哪些？"><span class="nav-text">39、支持一致性哈希的客户端有哪些？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40、Redis与其他key-value存储有什么不同？"><span class="nav-text">40、Redis与其他key-value存储有什么不同？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41、Redis的内存占用情况怎么样？"><span class="nav-text">41、Redis的内存占用情况怎么样？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42、都有哪些办法可以降低Redis的内存使用情况呢？"><span class="nav-text">42、都有哪些办法可以降低Redis的内存使用情况呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43、查看Redis使用情况及状态信息用什么命令？"><span class="nav-text">43、查看Redis使用情况及状态信息用什么命令？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44、Redis的内存用完了会发生什么？"><span class="nav-text">44、Redis的内存用完了会发生什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45、Redis是单线程的，如何提高多核CPU的利用率？"><span class="nav-text">45、Redis是单线程的，如何提高多核CPU的利用率？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46、一个Redis实例最多能存放多少的keys？List、Set、Sorted-Set他们最多能存放多少元素？"><span class="nav-text">46、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47、Redis常见性能问题和解决方案？"><span class="nav-text">47、Redis常见性能问题和解决方案？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48、Redis提供了哪几种持久化方式？"><span class="nav-text">48、Redis提供了哪几种持久化方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49、如何选择合适的持久化方式？"><span class="nav-text">49、如何选择合适的持久化方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50、修改配置不重启Redis会实时生效吗？"><span class="nav-text">50、修改配置不重启Redis会实时生效吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#51、为什么Redis能这么快"><span class="nav-text">51、为什么Redis能这么快</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#52、从海量Key里查询出某一个固定前缀的Key"><span class="nav-text">52、从海量Key里查询出某一个固定前缀的Key</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53、如何通过Redis实现分布式锁"><span class="nav-text">53、如何通过Redis实现分布式锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54、如何实现异步队列"><span class="nav-text">54、如何实现异步队列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55、Redis支持的数据类型？"><span class="nav-text">55、Redis支持的数据类型？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"><span class="nav-text">56、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57、redis通讯协议-RESP"><span class="nav-text">57、redis通讯协议(RESP)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58、redis架构有哪些"><span class="nav-text">58、redis架构有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单节点"><span class="nav-text">单节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主从复制"><span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哨兵"><span class="nav-text">哨兵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群"><span class="nav-text">集群</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#59、Redis集群-如何从海量数据里快速找到所需？"><span class="nav-text">59、Redis集群-如何从海量数据里快速找到所需？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分片"><span class="nav-text">分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一致性Hash算法"><span class="nav-text">一致性Hash算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash环的数据倾斜问题"><span class="nav-text">Hash环的数据倾斜问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#60、什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？"><span class="nav-text">60、什么是缓存穿透？如何避免？什么是缓存雪崩？如何避免？什么是缓存击穿？如何避免？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61、缓存与数据库双写一致"><span class="nav-text">61、缓存与数据库双写一致</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62、何保证Redis中的数据都是热点数据"><span class="nav-text">62、何保证Redis中的数据都是热点数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#63、Redis的并发竞争问题如何解决"><span class="nav-text">63、Redis的并发竞争问题如何解决?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#64、Redis回收进程如何工作的-Redis回收使用的是什么算法"><span class="nav-text">64、Redis回收进程如何工作的? Redis回收使用的是什么算法?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#65、Redis大批量增加数据"><span class="nav-text">65、Redis大批量增加数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66、延申：布隆过滤器"><span class="nav-text">66、延申：布隆过滤器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#67、Lua脚本相关"><span class="nav-text">67、Lua脚本相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#68、性能相关-Redis慢查询分析"><span class="nav-text">68、性能相关 - Redis慢查询分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#69、如何提高Redis处理效率-基于Jedis-的批量操作-Pipelined"><span class="nav-text">69、如何提高Redis处理效率? 基于Jedis 的批量操作 Pipelined</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">261</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">142</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
