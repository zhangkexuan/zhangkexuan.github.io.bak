<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="StampedLock类，在JDK1.8时引入，是对读写锁ReentrantReadWriteLock的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，更细粒度控制并发。 首先明确下，该类的设计初衷是作为一个内部工具类，用于辅助开发其它线程安全组件，用得好，该类可以提升系统性能，用不好，容易产生死锁和其它莫名其妙的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="juc_locks框架#7-AQS_StampedLock">
<meta property="og:url" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="StampedLock类，在JDK1.8时引入，是对读写锁ReentrantReadWriteLock的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，更细粒度控制并发。 首先明确下，该类的设计初衷是作为一个内部工具类，用于辅助开发其它线程安全组件，用得好，该类可以提升系统性能，用不好，容易产生死锁和其它莫名其妙的问题。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922122950917.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922123034223.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922123047041.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922123208729.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922123302778.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922123657800.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922123804156.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922131825419.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922131854468.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922131908193.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922131952653.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922132004020.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922132015033.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922132025687.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922132039412.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922132052263.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/(image-20200922135649764.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922132106088.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922132118728.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922132136022.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922133037585.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922133235161.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922133701747.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922133730463.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135143639.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135154316.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135208152.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135218433.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135233190.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135245323.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135257395.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135310849.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135328579.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135340146.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135349722.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135406780.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135420734.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135440824.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135450981.png">
<meta property="og:image" content="c:/Users/65135/Desktop/blog文章/深入并发/juc_locks框架-7-AQS_StampedLock(image-20200922135459409.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135631763.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135522882.png">
<meta property="og:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922135547455.png">
<meta property="article:published_time" content="2020-08-19T01:34:33.000Z">
<meta property="article:modified_time" content="2021-05-19T02:01:12.095Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="锁">
<meta property="article:tag" content="深入并发">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/image-20200922122950917.png">

<link rel="canonical" href="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>juc_locks框架#7-AQS_StampedLock | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/19/juc_locks%E6%A1%86%E6%9E%B6-7-AQS_StampedLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          juc_locks框架#7-AQS_StampedLock
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-19 09:34:33" itemprop="dateCreated datePublished" datetime="2020-08-19T09:34:33+08:00">2020-08-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">深入并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>StampedLock类，在JDK1.8时引入，是对读写锁ReentrantReadWriteLock的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，更细粒度控制并发。</p>
<p>首先明确下，该类的设计初衷是作为一个内部工具类，用于辅助开发其它线程安全组件，用得好，该类可以提升系统性能，用不好，容易产生死锁和其它莫名其妙的问题。</p>
<span id="more"></span>

<h1 id="一、StampedLock类简介"><a href="#一、StampedLock类简介" class="headerlink" title="一、StampedLock类简介"></a>一、StampedLock类简介</h1><h2 id="1-1-StampedLock的引入"><a href="#1-1-StampedLock的引入" class="headerlink" title="1.1 StampedLock的引入"></a>1.1 StampedLock的引入</h2><blockquote>
<p>先来看下，为什么有了ReentrantReadWriteLock，还要引入StampedLock？</p>
</blockquote>
<p>ReentrantReadWriteLock使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的。</p>
<p>但是，读写锁如果使用不当，很容易产生“饥饿”问题：</p>
<p>比如在读线程非常多，写线程很少的情况下，很容易导致写线程“饥饿”，虽然使用“公平”策略可以一定程度上缓解这个问题，但是“公平”策略是以牺牲系统吞吐量为代价的。</p>
<h2 id="1-2-StampedLock的特点"><a href="#1-2-StampedLock的特点" class="headerlink" title="1.2 StampedLock的特点"></a>1.2 StampedLock的特点</h2><p>StampedLock的主要特点概括一下，有以下几点：</p>
<ol>
<li>所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功；</li>
<li>所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；</li>
<li>StampedLock是不可重入的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li>
<li>StampedLock有三种访问模式：<br>①Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似<br>②Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似<br>③Optimistic reading（乐观读模式）：这是一种优化的读模式。</li>
<li>StampedLock支持读锁和写锁的相互转换<br>我们知道RRW中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的。<br>StampedLock提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。</li>
<li>无论写锁还是读锁，都不支持Conditon等待</li>
</ol>
<blockquote>
<p>我们知道，在ReentrantReadWriteLock中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会阻塞。<br>但是，在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用Optimistic reading获取到读锁时，必须对获取结果进行校验。</p>
</blockquote>
<h1 id="二、StampedLock使用示例"><a href="#二、StampedLock使用示例" class="headerlink" title="二、StampedLock使用示例"></a>二、StampedLock使用示例</h1><p>先来看一个Oracle官方的例子：</p>
<pre><code class="java">class Point &#123;
    private double x, y;
    private final StampedLock sl = new StampedLock();

    void move(double deltaX, double deltaY) &#123;
        long stamp = sl.writeLock();    //涉及对共享资源的修改，使用写锁-独占操作
        try &#123;
            x += deltaX;
            y += deltaY;
        &#125; finally &#123;
            sl.unlockWrite(stamp);
        &#125;
    &#125;

    /**
     * 使用乐观读锁访问共享资源
     * 注意：乐观读锁在保证数据一致性上需要拷贝一份要操作的变量到方法栈，并且在操作数据时候可能其他写线程已经修改了数据，
     * 而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。
     *
     * @return
     */
    double distanceFromOrigin() &#123;
        long stamp = sl.tryOptimisticRead();    // 使用乐观读锁
        double currentX = x, currentY = y;      // 拷贝共享资源到本地方法栈中
        if (!sl.validate(stamp)) &#123;              // 如果有写锁被占用，可能造成数据不一致，所以要切换到普通读锁模式
            stamp = sl.readLock();             
            try &#123;
                currentX = x;
                currentY = y;
            &#125; finally &#123;
                sl.unlockRead(stamp);
            &#125;
        &#125;
        return Math.sqrt(currentX * currentX + currentY * currentY);
    &#125;

    void moveIfAtOrigin(double newX, double newY) &#123; // upgrade
        // Could instead start with optimistic, not read mode
        long stamp = sl.readLock();
        try &#123;
            while (x == 0.0 &amp;&amp; y == 0.0) &#123;
                long ws = sl.tryConvertToWriteLock(stamp);  //读锁转换为写锁
                if (ws != 0L) &#123;
                    stamp = ws;
                    x = newX;
                    y = newY;
                    break;
                &#125; else &#123;
                    sl.unlockRead(stamp);
                    stamp = sl.writeLock();
                &#125;
            &#125;
        &#125; finally &#123;
            sl.unlock(stamp);
        &#125;
    &#125;
&#125;
</code></pre>
<p>可以看到，上述示例最特殊的其实是<strong>distanceFromOrigin</strong>方法，这个方法中使用了“Optimistic reading”乐观读锁，使得读写可以并发执行，但是“Optimistic reading”的使用必须遵循以下模式：</p>
<pre><code class="java">long stamp = lock.tryOptimisticRead();  // 非阻塞获取版本信息
copyVaraibale to ThreadMemory();           // 拷贝变量到线程本地堆栈
if(!lock.validate(stamp))&#123;              // 校验
    long stamp = lock.readLock();       // 获取读锁
    try &#123;
        copyVaraibale2ThreadMemory();   // 拷贝变量到线程本地堆栈
     &#125; finally &#123;
       lock.unlock(stamp);              // 释放悲观锁
    &#125;

&#125;
useThreadMemoryVarables();              // 使用线程本地堆栈里面的数据进行操作
</code></pre>
<h1 id="三、StampedLock原理"><a href="#三、StampedLock原理" class="headerlink" title="三、StampedLock原理"></a>三、StampedLock原理</h1><h2 id="3-1-StampedLock的内部常量"><a href="#3-1-StampedLock的内部常量" class="headerlink" title="3.1 StampedLock的内部常量"></a>3.1 StampedLock的内部常量</h2><p>StampedLock虽然不像其它锁一样定义了内部类来实现AQS框架，但是StampedLock的基本实现思路还是利用CLH队列进行线程的管理，通过同步状态值来表示锁的状态和类型。</p>
<p>StampedLock内部定义了很多常量，定义这些常量的根本目的还是和ReentrantReadWriteLock一样，对同步状态值按位切分，以通过位运算对State进行操作：</p>
<blockquote>
<p>对于StampedLock来说，写锁被占用的标志是第8位为1，读锁使用0-7位，正常情况下读锁数目为1-126，超过126时，使用一个名为<code>readerOverflow</code>的int整型保存超出数。</p>
</blockquote>
<p><img src="image-20200922122950917.png" alt="(image-20200922122950917"></p>
<p>部分常量的比特位表示如下：<br><img src="image-20200922123034223.png" alt="(image-20200922123034223"></p>
<p>另外，StampedLock相比ReentrantReadWriteLock，对多核CPU进行了优化，可以看到，当CPU核数超过1时，会有一些自旋操作:<br><img src="image-20200922123047041.png" alt="(image-20200922123047041"></p>
<h2 id="3-2-示例分析"><a href="#3-2-示例分析" class="headerlink" title="3.2 示例分析"></a>3.2 示例分析</h2><blockquote>
<p>假设现在有三个线程：ThreadA、ThreadB、ThreadC、ThreadD。操作如下：<br><code>//ThreadA调用writeLock, 获取写锁</code><br><code>//ThreadB调用readLock, 获取读锁</code><br><code>//ThreadC调用readLock, 获取读锁</code><br><code>//ThreadD调用writeLock, 获取写锁</code><br><code>//ThreadE调用readLock, 获取读锁</code></p>
</blockquote>
<h3 id="1-StampedLock对象的创建"><a href="#1-StampedLock对象的创建" class="headerlink" title="1. StampedLock对象的创建"></a>1. StampedLock对象的创建</h3><p>StampedLock的构造器很简单，构造时设置下同步状态值：<br><img src="image-20200922123208729.png" alt="(image-20200922123208729"></p>
<p>另外，StamedLock提供了三类视图：<br><img src="image-20200922123302778.png" alt="(image-20200922123302778"></p>
<p>这些视图其实是对StamedLock方法的封装，便于习惯了ReentrantReadWriteLock的用户使用：例如，<strong>ReadLockView</strong>其实相当于<code>ReentrantReadWriteLock.readLock()</code>返回的读锁;<br><img src="image-20200922123657800.png" alt="(image-20200922123657800"></p>
<h3 id="2-ThreadA调用writeLock获取写锁"><a href="#2-ThreadA调用writeLock获取写锁" class="headerlink" title="2. ThreadA调用writeLock获取写锁"></a>2. ThreadA调用writeLock获取写锁</h3><p>来看下<strong>writeLock</strong>方法：<br><img src="image-20200922123804156.png" alt="(image-20200922123804156"></p>
<p>StampedLock中大量运用了位运算，这里<code>(s = state) &amp; ABITS == 0L</code> 表示读锁和写锁都未被使用，这里写锁可以立即获取成功，然后CAS操作更新同步状态值State。</p>
<p>操作完成后，等待队列的结构如下：<br><img src="image-20200922131825419.png" alt="(image-20200922131825419"></p>
<blockquote>
<p>注意：StampedLock中，等待队列的结点要比AQS中简单些，仅仅三种状态。<br>0：初始状态<br>-1：等待中<br>1：取消</p>
</blockquote>
<p>另外，结点的定义中有个<code>cowait</code>字段，该字段指向一个栈，用于保存读线程，这个后续会讲到。<br><img src="image-20200922131854468.png" alt="(image-20200922131854468"></p>
<h3 id="3-ThreadB调用readLock获取读锁"><a href="#3-ThreadB调用readLock获取读锁" class="headerlink" title="3. ThreadB调用readLock获取读锁"></a>3. ThreadB调用readLock获取读锁</h3><p>来看下<strong>readLock</strong>方法：<br>由于ThreadA此时持有写锁，所以ThreadB获取读锁失败，将调用<strong>acquireRead</strong>方法，加入等待队列：<br><img src="image-20200922131908193.png" alt="(image-20200922131908193"></p>
<p><strong>acquireRead</strong>方法非常复杂，用到了大量自旋操作：</p>
<pre><code class="java">/**
 * 尝试自旋的获取读锁, 获取不到则加入等待队列, 并阻塞线程
 *
 * @param interruptible true 表示检测中断, 如果线程被中断过, 则最终返回INTERRUPTED
 * @param deadline      如果非0, 则表示限时获取
 * @return 非0表示获取成功, INTERRUPTED表示中途被中断过
 */
private long acquireRead(boolean interruptible, long deadline) &#123;
    WNode node = null, p;   // node指向入队结点, p指向入队前的队尾结点

    /**
     * 自旋入队操作
     * 如果写锁未被占用, 则立即尝试获取读锁, 获取成功则返回.
     * 如果写锁被占用, 则将当前读线程包装成结点, 并插入等待队列（如果队尾是写结点,直接链接到队尾;否则,链接到队尾读结点的栈中）
     */
    for (int spins = -1; ; ) &#123;
        WNode h;
        if ((h = whead) == (p = wtail)) &#123;   // 如果队列为空或只有头结点, 则会立即尝试获取读锁
            for (long m, s, ns; ; ) &#123;
                if ((m = (s = state) &amp; ABITS) &lt; RFULL ?     // 判断写锁是否被占用
                    U.compareAndSwapLong(this, STATE, s, ns = s + RUNIT) :  //写锁未占用,且读锁数量未超限, 则更新同步状态
                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != 0L))        //写锁未占用,但读锁数量超限, 超出部分放到readerOverflow字段中
                    return ns;          // 获取成功后, 直接返回
                else if (m &gt;= WBIT) &#123;   // 写锁被占用,以随机方式探测是否要退出自旋
                    if (spins &gt; 0) &#123;
                        if (LockSupport.nextSecondarySeed() &gt;= 0)
                            --spins;
                    &#125; else &#123;
                        if (spins == 0) &#123;
                            WNode nh = whead, np = wtail;
                            if ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))
                                break;
                        &#125;
                        spins = SPINS;
                    &#125;
                &#125;
            &#125;
        &#125;
        if (p == null) &#123;                            // p == null表示队列为空, 则初始化队列(构造头结点)
            WNode hd = new WNode(WMODE, null);
            if (U.compareAndSwapObject(this, WHEAD, null, hd))
                wtail = hd;
        &#125; else if (node == null) &#123;                  // 将当前线程包装成读结点
            node = new WNode(RMODE, p);
        &#125; else if (h == p || p.mode != RMODE) &#123;     // 如果队列只有一个头结点, 或队尾结点不是读结点, 则直接将结点链接到队尾, 链接完成后退出自旋
            if (node.prev != p)
                node.prev = p;
            else if (U.compareAndSwapObject(this, WTAIL, p, node)) &#123;
                p.next = node;
                break;
            &#125;
        &#125;
        // 队列不为空, 且队尾是读结点, 则将添加当前结点链接到队尾结点的cowait链中（实际上构成一个栈, p是栈顶指针 ）
        else if (!U.compareAndSwapObject(p, WCOWAIT, node.cowait = p.cowait, node)) &#123;    // CAS操作队尾结点p的cowait字段,实际上就是头插法插入结点
            node.cowait = null;
        &#125; else &#123;
            for (; ; ) &#123;
                WNode pp, c;
                Thread w;
                // 尝试唤醒头结点的cowait中的第一个元素, 假如是读锁会通过循环释放cowait链
                if ((h = whead) != null &amp;&amp; (c = h.cowait) != null &amp;&amp;
                    U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;
                    (w = c.thread) != null) // help release
                    U.unpark(w);
                if (h == (pp = p.prev) || h == p || pp == null) &#123;
                    long m, s, ns;
                    do &#123;
                        if ((m = (s = state) &amp; ABITS) &lt; RFULL ?
                            U.compareAndSwapLong(this, STATE, s,
                                ns = s + RUNIT) :
                            (m &lt; WBIT &amp;&amp;
                                (ns = tryIncReaderOverflow(s)) != 0L))
                            return ns;
                    &#125; while (m &lt; WBIT);
                &#125;
                if (whead == h &amp;&amp; p.prev == pp) &#123;
                    long time;
                    if (pp == null || h == p || p.status &gt; 0) &#123;
                        node = null; // throw away
                        break;
                    &#125;
                    if (deadline == 0L)
                        time = 0L;
                    else if ((time = deadline - System.nanoTime()) &lt;= 0L)
                        return cancelWaiter(node, p, false);
                    Thread wt = Thread.currentThread();
                    U.putObject(wt, PARKBLOCKER, this);
                    node.thread = wt;
                    if ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp; whead == h &amp;&amp; p.prev == pp) &#123;
                        // 写锁被占用, 且当前结点不是队首结点, 则阻塞当前线程
                        U.park(false, time);
                    &#125;
                    node.thread = null;
                    U.putObject(wt, PARKBLOCKER, null);
                    if (interruptible &amp;&amp; Thread.interrupted())
                        return cancelWaiter(node, p, true);
                &#125;
            &#125;
        &#125;
    &#125;

    for (int spins = -1; ; ) &#123;
        WNode h, np, pp;
        int ps;
        if ((h = whead) == p) &#123;     // 如果当前线程是队首结点, 则尝试获取读锁
            if (spins &lt; 0)
                spins = HEAD_SPINS;
            else if (spins &lt; MAX_HEAD_SPINS)
                spins &lt;&lt;= 1;
            for (int k = spins; ; ) &#123; // spin at head
                long m, s, ns;
                if ((m = (s = state) &amp; ABITS) &lt; RFULL ?     // 判断写锁是否被占用
                    U.compareAndSwapLong(this, STATE, s, ns = s + RUNIT) :  //写锁未占用,且读锁数量未超限, 则更新同步状态
                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != 0L)) &#123;      //写锁未占用,但读锁数量超限, 超出部分放到readerOverflow字段中
                    // 获取读锁成功, 释放cowait链中的所有读结点
                    WNode c;
                    Thread w;

                    // 释放头结点, 当前队首结点成为新的头结点
                    whead = node;
                    node.prev = null;

                    // 从栈顶开始(node.cowait指向的结点), 依次唤醒所有读结点, 最终node.cowait==null, node成为新的头结点
                    while ((c = node.cowait) != null) &#123;
                        if (U.compareAndSwapObject(node, WCOWAIT, c, c.cowait) &amp;&amp; (w = c.thread) != null)
                            U.unpark(w);
                    &#125;
                    return ns;
                &#125; else if (m &gt;= WBIT &amp;&amp;
                    LockSupport.nextSecondarySeed() &gt;= 0 &amp;&amp; --k &lt;= 0)
                    break;
            &#125;
        &#125; else if (h != null) &#123;     // 如果头结点存在cowait链, 则唤醒链中所有读线程
            WNode c;
            Thread w;
            while ((c = h.cowait) != null) &#123;
                if (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;
                    (w = c.thread) != null)
                    U.unpark(w);
            &#125;
        &#125;
        if (whead == h) &#123;
            if ((np = node.prev) != p) &#123;
                if (np != null)
                    (p = np).next = node;   // stale
            &#125; else if ((ps = p.status) == 0)        // 将前驱结点的等待状态置为WAITING, 表示之后将唤醒当前结点
                U.compareAndSwapInt(p, WSTATUS, 0, WAITING);
            else if (ps == CANCELLED) &#123;
                if ((pp = p.prev) != null) &#123;
                    node.prev = pp;
                    pp.next = node;
                &#125;
            &#125; else &#123;        // 阻塞当前读线程
                long time;
                if (deadline == 0L)
                    time = 0L;
                else if ((time = deadline - System.nanoTime()) &lt;= 0L)   //限时等待超时, 取消等待
                    return cancelWaiter(node, node, false);

                Thread wt = Thread.currentThread();
                U.putObject(wt, PARKBLOCKER, this);
                node.thread = wt;
                if (p.status &lt; 0 &amp;&amp; (p != h || (state &amp; ABITS) == WBIT) &amp;&amp; whead == h &amp;&amp; node.prev == p) &#123;
                    // 如果前驱的等待状态为WAITING, 且写锁被占用, 则阻塞当前调用线程
                    U.park(false, time);
                &#125;
                node.thread = null;
                U.putObject(wt, PARKBLOCKER, null);
                if (interruptible &amp;&amp; Thread.interrupted())
                    return cancelWaiter(node, node, true);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>我们来分析下这个方法。<br>该方法会首先自旋的尝试获取读锁，获取成功后，就直接返回；否则，会将当前线程包装成一个读结点，插入到等待队列。<br>由于，目前等待队列还是空，所以ThreadB会初始化队列，然后将自身包装成一个读结点，插入队尾，然后在下面这个地方跳出自旋：<br><img src="image-20200922131952653.png" alt="(image-20200922131952653"></p>
<p>此时，等待队列的结构如下：<br><img src="image-20200922132004020.png" alt="(image-20200922132004020"></p>
<p>跳出自旋后，ThreadB会继续向下执行，进入下一个自旋，在下一个自旋中，依然会再次尝试获取读锁，如果这次再获取不到，就会将前驱的等待状态置为WAITING, 表示我（当前线程）要去睡了（阻塞），到时记得叫醒我：<br><img src="image-20200922132015033.png" alt="(image-20200922132015033"></p>
<p><img src="image-20200922132025687.png" alt="(image-20200922132025687"></p>
<p>最终, ThreadB进入阻塞状态:<br><img src="image-20200922132039412.png" alt="(image-20200922132039412"></p>
<p>最终，等待队列的结构如下：</p>
<p><img src="image-20200922132052263.png" alt="(image-20200922132052263"></p>
<h3 id="4-ThreadC调用readLock获取读锁"><a href="#4-ThreadC调用readLock获取读锁" class="headerlink" title="4. ThreadC调用readLock获取读锁"></a>4. ThreadC调用readLock获取读锁</h3><p>这个过程和ThreadB获取读锁一样，区别在于ThreadC被包装成结点加入等待队列后，是链接到ThreadB结点的栈指针中的。调用完下面这段代码后，ThreadC会链接到以Thread B为栈顶指针的栈中：<br><img src="(image-20200922135649764.png" alt="(image-20200922135649764"></p>
<p><img src="image-20200922132106088.png" alt="(image-20200922132106088"></p>
<blockquote>
<p>注意：读结点的cowait字段其实构成了一个栈，入栈的过程其实是个“头插法”插入单链表的过程。比如，再来个ThreadX读结点，则cowait链表结构为：<code>ThreadB - &gt; ThreadX -&gt; ThreadC</code>。最终唤醒读结点时，将从栈顶开始。</p>
</blockquote>
<p>然后会在下一次自旋中，阻塞当前读线程：<br><img src="image-20200922132118728.png" alt="(image-20200922132118728"></p>
<p>最终，等待队列的结构如下：<br><img src="image-20200922132136022.png" alt="(image-20200922132136022"></p>
<p>可以看到，此时ThreadC结点并没有把它的前驱的等待状态置为-1，因为ThreadC是链接到栈中的，当写锁释放的时候，会从栈底元素开始，唤醒栈中所有读结点。</p>
<h3 id="5-ThreadD调用writeLock获取写锁"><a href="#5-ThreadD调用writeLock获取写锁" class="headerlink" title="5. ThreadD调用writeLock获取写锁"></a>5. ThreadD调用writeLock获取写锁</h3><p>ThreadD调用<strong>writeLock</strong>方法获取写锁失败后（ThreadA依然占用着写锁），会调用<strong>acquireWrite</strong>方法，该方法整体逻辑和<strong>acquireRead</strong>差不多，首先自旋的尝试获取写锁，获取成功后，就直接返回；否则，会将当前线程包装成一个写结点，插入到等待队列。</p>
<p><img src="image-20200922133037585.png" alt="(image-20200922133037585"></p>
<p><em>acquireWrite源码：</em></p>
<pre><code class="java">/**
 * 尝试自旋的获取写锁, 获取不到则阻塞线程
 *
 * @param interruptible true 表示检测中断, 如果线程被中断过, 则最终返回INTERRUPTED
 * @param deadline      如果非0, 则表示限时获取
 * @return 非0表示获取成功, INTERRUPTED表示中途被中断过
 */
private long acquireWrite(boolean interruptible, long deadline) &#123;
    WNode node = null, p;

    /**
     * 自旋入队操作
     * 如果没有任何锁被占用, 则立即尝试获取写锁, 获取成功则返回.
     * 如果存在锁被使用, 则将当前线程包装成独占结点, 并插入等待队列尾部
     */
    for (int spins = -1; ; ) &#123;
        long m, s, ns;
        if ((m = (s = state) &amp; ABITS) == 0L) &#123;      // 没有任何锁被占用
            if (U.compareAndSwapLong(this, STATE, s, ns = s + WBIT))    // 尝试立即获取写锁
                return ns;                                                 // 获取成功直接返回
        &#125; else if (spins &lt; 0)
            spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : 0;
        else if (spins &gt; 0) &#123;
            if (LockSupport.nextSecondarySeed() &gt;= 0)
                --spins;
        &#125; else if ((p = wtail) == null) &#123;       // 队列为空, 则初始化队列, 构造队列的头结点
            WNode hd = new WNode(WMODE, null);
            if (U.compareAndSwapObject(this, WHEAD, null, hd))
                wtail = hd;
        &#125; else if (node == null)               // 将当前线程包装成写结点
            node = new WNode(WMODE, p);
        else if (node.prev != p)
            node.prev = p;
        else if (U.compareAndSwapObject(this, WTAIL, p, node)) &#123;    // 链接结点至队尾
            p.next = node;
            break;
        &#125;
    &#125;

    for (int spins = -1; ; ) &#123;
        WNode h, np, pp;
        int ps;
        if ((h = whead) == p) &#123;     // 如果当前结点是队首结点, 则立即尝试获取写锁
            if (spins &lt; 0)
                spins = HEAD_SPINS;
            else if (spins &lt; MAX_HEAD_SPINS)
                spins &lt;&lt;= 1;
            for (int k = spins; ; ) &#123; // spin at head
                long s, ns;
                if (((s = state) &amp; ABITS) == 0L) &#123;      // 写锁未被占用
                    if (U.compareAndSwapLong(this, STATE, s,
                        ns = s + WBIT)) &#123;               // CAS修改State: 占用写锁
                        // 将队首结点从队列移除
                        whead = node;
                        node.prev = null;
                        return ns;
                    &#125;
                &#125; else if (LockSupport.nextSecondarySeed() &gt;= 0 &amp;&amp;
                    --k &lt;= 0)
                    break;
            &#125;
        &#125; else if (h != null) &#123;  // 唤醒头结点的栈中的所有读线程
            WNode c;
            Thread w;
            while ((c = h.cowait) != null) &#123;
                if (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp; (w = c.thread) != null)
                    U.unpark(w);
            &#125;
        &#125;
        if (whead == h) &#123;
            if ((np = node.prev) != p) &#123;
                if (np != null)
                    (p = np).next = node;   // stale
            &#125; else if ((ps = p.status) == 0)        // 将当前结点的前驱置为WAITING, 表示当前结点会进入阻塞, 前驱将来需要唤醒我
                U.compareAndSwapInt(p, WSTATUS, 0, WAITING);
            else if (ps == CANCELLED) &#123;
                if ((pp = p.prev) != null) &#123;
                    node.prev = pp;
                    pp.next = node;
                &#125;
            &#125; else &#123;        // 阻塞当前调用线程
                long time;  // 0 argument to park means no timeout
                if (deadline == 0L)
                    time = 0L;
                else if ((time = deadline - System.nanoTime()) &lt;= 0L)
                    return cancelWaiter(node, node, false);
                Thread wt = Thread.currentThread();
                U.putObject(wt, PARKBLOCKER, this);
                node.thread = wt;
                if (p.status &lt; 0 &amp;&amp; (p != h || (state &amp; ABITS) != 0L) &amp;&amp; whead == h &amp;&amp; node.prev == p)
                    U.park(false, time);    // emulate LockSupport.park
                node.thread = null;
                U.putObject(wt, PARKBLOCKER, null);
                if (interruptible &amp;&amp; Thread.interrupted())
                    return cancelWaiter(node, node, true);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>acquireWrite</strong>中的下面这个自旋操作，用于将线程包装成写结点，插入队尾：<br><img src="image-20200922133235161.png" alt="(image-20200922133235161"></p>
<p>插入完成后，队列结构如下：<br><img src="image-20200922133701747.png" alt="(image-20200922133701747"></p>
<p>然后，进入下一个自旋，并在下一个自旋中阻塞ThreadD，最终队列结构如下：<br><img src="image-20200922133730463.png" alt="(image-20200922133730463"></p>
<h3 id="6-ThreadE调用readLock获取读锁"><a href="#6-ThreadE调用readLock获取读锁" class="headerlink" title="6. ThreadE调用readLock获取读锁"></a>6. ThreadE调用readLock获取读锁</h3><p>同样，由于写锁被ThreadA占用着，所以最终会调用<strong>acquireRead</strong>方法，在该方法的第一个自旋中，会将ThreadE加入等待队列：<br><img src="image-20200922135143639.png" alt="(image-20200922135143639"></p>
<blockquote>
<p>注意，由于队尾结点是写结点，所以当前读结点会直接链接到队尾；如果队尾是读结点，则会链接到队尾读结点的cowait链中。</p>
</blockquote>
<p>然后进入第二个自旋，阻塞ThreadE，最终队列结构如下：<br><img src="image-20200922135154316.png" alt="(image-20200922135154316"></p>
<h3 id="7-ThreadA调用unlockWrite释放写锁"><a href="#7-ThreadA调用unlockWrite释放写锁" class="headerlink" title="7. ThreadA调用unlockWrite释放写锁"></a>7. ThreadA调用unlockWrite释放写锁</h3><p>通过CAS操作，修改State成功后，会调用<strong>release</strong>方法唤醒等待队列的队首结点：<br><img src="image-20200922135208152.png" alt="(image-20200922135208152"></p>
<p><strong>release</strong>方法非常简单，先将头结点的等待状态置为0，表示即将唤醒后继结点，然后立即唤醒队首结点：<br><img src="image-20200922135218433.png" alt="(image-20200922135218433"></p>
<p>此时，等待队列的结构如下：<br><img src="image-20200922135233190.png" alt="(image-20200922135233190"></p>
<h3 id="8-ThreadB被唤醒后继续向下执行"><a href="#8-ThreadB被唤醒后继续向下执行" class="headerlink" title="8. ThreadB被唤醒后继续向下执行"></a>8. ThreadB被唤醒后继续向下执行</h3><p>ThreadB被唤醒后，会从原阻塞处继续向下执行，然后开始下一次自旋：<br><img src="image-20200922135245323.png" alt="(image-20200922135245323"></p>
<p>第二次自旋时，ThreadB发现写锁未被占用，则成功获取到读锁，然后从栈顶（ThreadB的cowait指针指向的结点）开始唤醒栈中所有线程，<br>最后返回：<br><img src="image-20200922135257395.png" alt="(image-20200922135257395"></p>
<p>最终，等待队列的结构如下：<br><img src="image-20200922135310849.png" alt="(image-20200922135310849"></p>
<h3 id="9-ThreadC被唤醒后继续向下执行"><a href="#9-ThreadC被唤醒后继续向下执行" class="headerlink" title="9. ThreadC被唤醒后继续向下执行"></a>9. ThreadC被唤醒后继续向下执行</h3><p>ThreadC被唤醒后，继续执行，并进入下一次自旋，下一次自旋时，会成功获取到读锁。<br><img src="image-20200922135328579.png" alt="(image-20200922135328579"></p>
<p>注意，此时ThreadB和ThreadC已经拿到了读锁，ThreadD（写线程）和ThreadE（读线程）依然阻塞中，原来ThreadC对应的结点是个孤立结点，会被GC回收。</p>
<p>最终，等待队列的结构如下：<br><img src="image-20200922135340146.png" alt="(image-20200922135340146"></p>
<h3 id="10-ThreadB和ThreadC释放读锁"><a href="#10-ThreadB和ThreadC释放读锁" class="headerlink" title="10. ThreadB和ThreadC释放读锁"></a>10. ThreadB和ThreadC释放读锁</h3><p>ThreadB和ThreadC调用<strong>unlockRead</strong>方法释放读锁，CAS操作State将读锁数量减1：<br><img src="image-20200922135349722.png" alt="(image-20200922135349722"></p>
<p>注意，当读锁的数量变为0时才会调用<strong>release</strong>方法，唤醒队首结点：<br><img src="image-20200922135406780.png" alt="(image-20200922135406780"></p>
<p>队首结点（ThreadD写结点被唤醒），最终等待队列的结构如下：<br><img src="image-20200922135420734.png" alt="(image-20200922135420734"></p>
<h3 id="11-ThreadD被唤醒后继续向下执行"><a href="#11-ThreadD被唤醒后继续向下执行" class="headerlink" title="11. ThreadD被唤醒后继续向下执行"></a>11. ThreadD被唤醒后继续向下执行</h3><p>ThreadD会从原阻塞处继续向下执行，并在下一次自旋中获取到写锁，然后返回:<br><img src="image-20200922135440824.png" alt="(image-20200922135440824"></p>
<p>最终，等待队列的结构如下：<br><img src="image-20200922135450981.png" alt="(image-20200922135450981"></p>
<h3 id="12-ThreadD调用unlockWrite释放写锁"><a href="#12-ThreadD调用unlockWrite释放写锁" class="headerlink" title="12. ThreadD调用unlockWrite释放写锁"></a>12. ThreadD调用unlockWrite释放写锁</h3><p>ThreadD释放写锁的过程和步骤7于ThreadE是个读结点，所以同时会唤醒cowait栈中的所有读结点，过程和步骤8完全一样。最终，等待队列的结构如下：</p>
<p><img src="C:\Users\65135\Desktop\blog文章\深入并发\juc_locks框架-7-AQS_StampedLock(image-20200922135459409.png" alt="(image-20200922135459409"></p>
<p><img src="image-20200922135631763.png" alt="(image-20200922135631763"></p>
<p>至此，全部执行完成。</p>
<h2 id="四、StampedLock类-方法声明"><a href="#四、StampedLock类-方法声明" class="headerlink" title="四、StampedLock类/方法声明"></a>四、StampedLock类/方法声明</h2><p>参考Oracle官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javas…</a><br>*<strong>类声明：*</strong><br><img src="image-20200922135522882.png" alt="(image-20200922135522882"></p>
<p>*<strong>方法声明：*</strong><br><img src="image-20200922135547455.png" alt="(image-20200922135547455"></p>
<h2 id="五、StampedLock总结"><a href="#五、StampedLock总结" class="headerlink" title="五、StampedLock总结"></a>五、StampedLock总结</h2><p>StampedLock的等待队列与RRW的CLH队列相比，有以下特点：</p>
<ol>
<li>当入队一个线程时，如果队尾是读结点，不会直接链接到队尾，而是链接到该读结点的cowait链中，cowait链本质是一个栈；</li>
<li>当入队一个线程时，如果队尾是写结点，则直接链接到队尾；</li>
<li>唤醒线程的规则和AQS类似，都是首先唤醒队首结点。区别是StampedLock中，当唤醒的结点是读结点时，会唤醒该读结点的cowait链中的所有读结点（顺序和入栈顺序相反，也就是后进先出）。</li>
</ol>
<p>另外，StampedLock使用时要特别小心，避免锁重入的操作，在使用乐观读锁时也需要遵循相应的调用模板，防止出现数据不一致的问题。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%94%81/" rel="tag"># 锁</a>
              <a href="/tags/%E6%B7%B1%E5%85%A5%E5%B9%B6%E5%8F%91/" rel="tag"># 深入并发</a>
              <a href="/tags/juc/" rel="tag"># juc</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/18/%E7%AE%97%E6%B3%95-1-%E5%9B%9E%E6%BA%AF/" rel="prev" title="算法#1-回溯">
      <i class="fa fa-chevron-left"></i> 算法#1-回溯
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/20/juc_atomic%E6%A1%86%E6%9E%B6-1-Unsase%E7%B1%BB/" rel="next" title="juc_atomic框架#1-Unsase类">
      juc_atomic框架#1-Unsase类 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81StampedLock%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="nav-text">一、StampedLock类简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-StampedLock%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">1.1 StampedLock的引入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-StampedLock%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">1.2 StampedLock的特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81StampedLock%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">二、StampedLock使用示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81StampedLock%E5%8E%9F%E7%90%86"><span class="nav-text">三、StampedLock原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-StampedLock%E7%9A%84%E5%86%85%E9%83%A8%E5%B8%B8%E9%87%8F"><span class="nav-text">3.1 StampedLock的内部常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-text">3.2 示例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-StampedLock%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">1. StampedLock对象的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ThreadA%E8%B0%83%E7%94%A8writeLock%E8%8E%B7%E5%8F%96%E5%86%99%E9%94%81"><span class="nav-text">2. ThreadA调用writeLock获取写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ThreadB%E8%B0%83%E7%94%A8readLock%E8%8E%B7%E5%8F%96%E8%AF%BB%E9%94%81"><span class="nav-text">3. ThreadB调用readLock获取读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ThreadC%E8%B0%83%E7%94%A8readLock%E8%8E%B7%E5%8F%96%E8%AF%BB%E9%94%81"><span class="nav-text">4. ThreadC调用readLock获取读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-ThreadD%E8%B0%83%E7%94%A8writeLock%E8%8E%B7%E5%8F%96%E5%86%99%E9%94%81"><span class="nav-text">5. ThreadD调用writeLock获取写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-ThreadE%E8%B0%83%E7%94%A8readLock%E8%8E%B7%E5%8F%96%E8%AF%BB%E9%94%81"><span class="nav-text">6. ThreadE调用readLock获取读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-ThreadA%E8%B0%83%E7%94%A8unlockWrite%E9%87%8A%E6%94%BE%E5%86%99%E9%94%81"><span class="nav-text">7. ThreadA调用unlockWrite释放写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-ThreadB%E8%A2%AB%E5%94%A4%E9%86%92%E5%90%8E%E7%BB%A7%E7%BB%AD%E5%90%91%E4%B8%8B%E6%89%A7%E8%A1%8C"><span class="nav-text">8. ThreadB被唤醒后继续向下执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-ThreadC%E8%A2%AB%E5%94%A4%E9%86%92%E5%90%8E%E7%BB%A7%E7%BB%AD%E5%90%91%E4%B8%8B%E6%89%A7%E8%A1%8C"><span class="nav-text">9. ThreadC被唤醒后继续向下执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-ThreadB%E5%92%8CThreadC%E9%87%8A%E6%94%BE%E8%AF%BB%E9%94%81"><span class="nav-text">10. ThreadB和ThreadC释放读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-ThreadD%E8%A2%AB%E5%94%A4%E9%86%92%E5%90%8E%E7%BB%A7%E7%BB%AD%E5%90%91%E4%B8%8B%E6%89%A7%E8%A1%8C"><span class="nav-text">11. ThreadD被唤醒后继续向下执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-ThreadD%E8%B0%83%E7%94%A8unlockWrite%E9%87%8A%E6%94%BE%E5%86%99%E9%94%81"><span class="nav-text">12. ThreadD调用unlockWrite释放写锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81StampedLock%E7%B1%BB-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E"><span class="nav-text">四、StampedLock类&#x2F;方法声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81StampedLock%E6%80%BB%E7%BB%93"><span class="nav-text">五、StampedLock总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
