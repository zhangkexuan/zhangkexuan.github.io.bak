<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="今天我们来学习一种可以快速查找、插入、删除的数据结构，据说可以代替红黑树。就是本文的标题——跳表(SkipList)。跳表还有一个优点是实现起来简单。 redis中的有序集合，其实就是基于跳表实现的。">
<meta property="og:type" content="article">
<meta property="og:title" content="跳表的介绍与使用">
<meta property="og:url" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="今天我们来学习一种可以快速查找、插入、删除的数据结构，据说可以代替红黑树。就是本文的标题——跳表(SkipList)。跳表还有一个优点是实现起来简单。 redis中的有序集合，其实就是基于跳表实现的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711104107346.png">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711104724926.png">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711104929676.png">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711105104803.png">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711105838467.png">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711152251358.png">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711104929676.png">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711160516462.png">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711162337749.png">
<meta property="og:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711162337749.png">
<meta property="article:published_time" content="2020-03-29T01:34:33.000Z">
<meta property="article:modified_time" content="2021-05-19T02:28:02.464Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/20190711104107346.png">

<link rel="canonical" href="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>跳表的介绍与使用 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/29/%E8%B7%B3%E8%A1%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          跳表的介绍与使用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-29 09:34:33" itemprop="dateCreated datePublished" datetime="2020-03-29T09:34:33+08:00">2020-03-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>今天我们来学习一种可以快速查找、插入、删除的数据结构，据说可以代替红黑树。就是本文的标题——跳表(SkipList)。跳表还有一个优点是实现起来简单。</p>
<p>redis中的有序集合，其实就是基于跳表实现的。</p>
<span id="more"></span>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>今天我们来学习一种可以快速查找、插入、删除的数据结构，据说可以代替红黑树。就是本文的标题——跳表(SkipList)。跳表还有一个优点是实现起来简单。</p>
<p>redis中的有序集合，其实就是基于跳表实现的。</p>
<p>为啥叫做跳表，听到这个名字我第一反应是感觉它很跳。</p>
<p>其实</p>
<ul>
<li>跳表结合了链表和二分查找的思想</li>
<li>由原始链表和一些通过“跳跃”生成的链表组成</li>
<li>第0层是原始链表，越上层“跳跃”的越高，元素越少</li>
<li>上层链表是下层链表的子序列</li>
<li>查找时从顶层向下，不断缩小搜索范围</li>
</ul>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>跳表有很多层，如果只看0层的话，就是一个有序链表。那么其他层是什么呢？</p>
<p>我们知道，链表的查询复杂度为O(n)O(n)O(n)</p>
<p><img src="20190711104107346.png" alt="在这里插入图片描述"></p>
<p>如果在这个基础之上，增加一层“索引”，查找就会快一点点。<br>之前直接查找单链表，比如查询节点7：</p>
<p><img src="20190711104724926.png" alt="在这里插入图片描述"><br>会经过6个节点，那通过索引呢？</p>
<p><img src="20190711104929676.png" alt="在这里插入图片描述"><br>经过4个节点就能找到了。是不是快了一点。<br>要注意到，每一层上的索引是可以向下层走的。上面的图只是一个简化结构，更严谨的一个结构应该如下：</p>
<p><img src="20190711105104803.png" alt="在这里插入图片描述"></p>
<p>最左边的是header节点，不存值，上图的31，出现在了0,1,2,3层，其实就是一个节点。不是四个节点(这个要看具体的实现，这里是通过数组实现，可以通过下标访问，也可以通过链式实现)。这些层次信息是通过<code>forwards(ArrayList)</code>保存的。因此可以很快的访问到下一层。</p>
<p>如果元素个数很多的话，通常层数也会相应的增加。比如我们再增加一层。</p>
<p><img src="20190711105838467.png" alt="在这里插入图片描述"></p>
<p>现在访问节点7经过的节点为：1-&gt;6-&gt;7。</p>
<p>这里有必要提出的是，每隔两个节点往上提升一层建立索引只是理想情况，实际上是通过随机层数来实现的。这点后面会分析。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>我们将每个节点值以及每层上的索引信息封装到一个类中：</p>
<pre><code class="java">private class Node &#123;
    //保存值
    E data;
    //保存了每一层上的节点信息，可能为null
    List&lt;Node&gt; forwards;

    Node(E data) &#123;
        this.data = data;
        forwards = new ArrayList&lt;&gt;();
        //事先把每一层都置为null，虽然空间利用率没那么高，但是简化了实现
        //也可以通过自定义列表(比如B树实现中用到的Vector)来实现，就可以不用下面的操作
        for (int i = 0; i &lt;= maxLevel; i++) &#123;
            forwards.add(null);
        &#125;
    &#125;

    @Override
    public String toString() &#123;
        return data == null ? &quot; &quot; : &quot;&quot; + data;
    &#125;

    /**
     * 得到当前节点level层上的下一个(右边一个)节点
     *
     * @param level
     * @return
     */
    Node next(int level) &#123;
        return this.forwards.get(level);
    &#125;

&#125;
</code></pre>
<p>同样地，这个<code>Node</code>也是通过内部类来实现的,<code>forwards</code>保存了每一层上的索引信息。</p>
<p><img src="20190711152251358.png" alt="在这里插入图片描述"></p>
<p><code>forwards</code>描述了上图中标红的部分,16是通过<code>data</code>属性保存的。<br>节点的结构还是挺简单的，这里我增加了一个<code>next()</code>方法用来访问同层的右边节点。</p>
<p>有了这个之后，我们来看一下查找的实现是怎样的。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><img src="20190711104929676.png" alt="在这里插入图片描述"></p>
<p>查找时从顶层向下，不断缩小搜索范围。</p>
<p>以前面的图片为例，假设有这样一个跳表。查询节点值为7的过程如上所示。<br>首先从头结点<code>header</code>开始，并起始于顶层(这里是1)。<br>第1层：经由1,4,6。 由于6的下一个节点(这里说的下一个节点都是指右边一个，不是下一层)是8，我们要查找的是7，因此小于7的最大节点就是6，我们从此处往下到达下一层。<br>第0层：经由6,7。 从6往右就到了7了。找到了！！<br>整个查询的复杂度为O(logn)O(\log n)O(logn)</p>
<pre><code class="java">public Node find(E e) &#123;
    if (empty()) &#123;
        return null;
    &#125;
    return find(e, head, curLevel);
&#125;

private Node find(E e, Node current, int level) &#123;
    while (level &gt;= 0) &#123;
        current = findNext(e, current, level);
        level--;
    &#125;
    return current;
&#125;

//返回给定层数中小于e的最大者
private Node findNext(E e, Node current, int level) &#123;
    Node next = current.next(level);
    while (next != null) &#123;
        if (e.compareTo(next.data) &lt; 0) &#123;
            break;
        &#125;
        //到这说明e &gt;= next.data
        current = next;
        next = current.next(level);
    &#125;
    return current;
&#125;
</code></pre>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><img src="20190711160516462.png" alt="在这里插入图片描述"><br>给定如上跳表，假设要插入节点2。<br>首先需要判断节点2是否已经存在，若存在则返回<code>false</code>。</p>
<p>否则，随机生成待插入节点的层数。</p>
<pre><code class="java">/**
 * 生成随机层数[0,maxLevel)
 * 生成的值越大，概率越小
 *
 * @return
 */
private int randomLevel() &#123;
    int level = 0;
    while (Math.random() &lt; PROBABILITY &amp;&amp; level &lt; maxLevel - 1) &#123;
        ++level;
    &#125;
    return level;
&#125;
</code></pre>
<p>这里的<code>PROBABILITY =0.5</code>。上面算法的意思是返回1的概率是12\frac{1}{2}21；返回2的概率是14\frac{1}{4}41；返回3的概率是18\frac{1}{8}81，依次类推。看成一个分布的话，第0层包含所有节点，第1层含有12\frac{1}{2}21个节点，第2层含有14\frac{1}{4}41个节点…</p>
<p>注意这里有一个最大层数<code>maxLevel</code>，也可以不设置最大层数。</p>
<p>通过这种随机生成层数的方式使得实现起来简单。</p>
<p>假设我们生成的层数是3。</p>
<p><img src="20190711162337749.png" alt="在这里插入图片描述"><br>在1和3之间插入节点2，层数是3，也就是节点2跳跃到了第3层。</p>
<pre><code class="java">public boolean add(E e) &#123;
    if (contains(e)) &#123;
        return false;
    &#125;
    int level = randomLevel();
    if (level &gt; curLevel) &#123;
        curLevel = level;
    &#125;
    Node newNode = new Node(e);
    Node current = head;
    //插入方向由上到下
    while (level &gt;= 0) &#123;
        //找到比e小的最大节点
        current = findNext(e, current, level);
        //将newNode插入到current后面
        //newNode的next指针指向该节点的后继
        newNode.forwards.add(0, current.next(level));
        //该节点的next指向newNode
        current.forwards.set(level, newNode);
        level--;//每层都要插入
    &#125;
    size++;
    return true;
&#125;
</code></pre>
<p>我们通过一个例子来模拟，<strong>由于实现了直观的打印算法，因此就不画图了</strong>。<br>假设我们要插入<code>1, 6, 9, 3, 5, 7, 4, 8</code></p>
<p>过程如下：</p>
<pre><code>add: 1
Level 0:  1

add: 6
Level 0:  1 6

add: 9
Level 2:      9
Level 1:      9
Level 0:  1 6 9

add: 3
Level 2:    3   9
Level 1:    3   9
Level 0:  1 3 6 9

add: 5
Level 2:    3     9
Level 1:    3 5   9
Level 0:  1 3 5 6 9

add: 7
Level 2:    3       9
Level 1:    3 5     9
Level 0:  1 3 5 6 7 9

add: 4
Level 2:    3         9
Level 1:    3   5     9
Level 0:  1 3 4 5 6 7 9

add: 8
Level 2:    3           9
Level 1:    3   5       9
Level 0:  1 3 4 5 6 7 8 9
</code></pre>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>之前在研究二叉树的时候，发现所有的平衡的二叉树(也包括多叉树，如B树）删除算法都是最难的。<br>上文说了跳表的一个优点是实现简单，删除也不例外，也是异常的简单。</p>
<blockquote>
<p>该删除算法是根据查找算法实现的，并通过大量的测试(随机插入2000个数据，并根据插入顺序删除，没有抛出异常，因此应该是没问题的，如果发现删除实现有问题，请一定要告诉我)。<br>我看了网上其他O(logn)O(\log n)O(logn)的删除算法实现基本都是基于双向链表的，但是双向链表需要多维护一个<code>pre</code>指针，或者额外需要一个<code>updates</code>列表来记录前驱节点，增加了复杂度。根据查找算法，理论上是可以在一次查找过程中找到它的前驱节点，并进行删除的。</p>
</blockquote>
<p>测试代码如下：</p>
<pre><code class="java">public static void main(String[] args) &#123;
    Random random = new Random();
    int[] values = random.ints(2000, 1, 10000).toArray();
   // int[] values = &#123;1, 6, 9, 3, 5, 7, 4, 8&#125;;
    SkipList&lt;Integer&gt; list = new SkipList&lt;&gt;();
    for (int value : values) &#123;
        //System.out.println(&quot;add: &quot; + value);
        list.add(value);
        //list.print();
        //System.out.println();
    &#125;


    for (int value : values) &#123;
        list.remove(value);
        System.out.println(&quot;remove: &quot; + value);
        list.print();
        System.out.println();
    &#125;

&#125;
</code></pre>
<p>删除可以说是插入的逆过程<br><img src="20190711162337749.png" alt="在这里插入图片描述"><br>上文中我们插入了节点2，如果想要删除它的话，就是将它的前驱节点指向它的后继节点(跳表需要对链表的操作比较熟悉，如果不太了解的话，建议先去搜一下)。</p>
<p>把握住这个思路，实现删除就不难了。</p>
<pre><code class="java">/**
 * O(logN)的删除算法
 *
 * @param e
 * @return
 */
public boolean remove(E e) &#123;
    if (empty()) &#123;
        return false;
    &#125;
    boolean removed = false;//记录是否删除
    int level = curLevel;
    //current用于遍历,pre指向待删除节点前一个节点
    Node current = head.next(level), pre = head;
    while (level &gt;= 0) &#123;
        while (current != null) &#123;
            //e &lt; current.data
            if (e.compareTo(current.data) &lt; 0) &#123;
                break;
            &#125;
            //只有e &gt;= current.data才需要继续
            //如果e == current.data
            if (e.compareTo(current.data) == 0) &#123;
                //pre指向它的后继
                pre.forwards.set(level, current.next(level));
                //设置删除标记
                removed = true;
                //跳出循环内层循环
                break;
            &#125;
            pre = current;
            current = current.next(level);
        &#125;
        //继续搜索下一层
        level--;
        if (level &lt; 0) &#123;
            //防止next(-1)
            break;
        &#125;
        //往下一层,从pre开始往下即可，不需要从头(header)开始
        current = pre.next(level);
    &#125;
    if (removed) &#123;
        size--;//不要忘记size--
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<p>整个代码实现完成后，发现真的很简单，也很简短。</p>
<p>还是插入<code>1, 6, 9, 3, 5, 7, 4, 8</code>，然后依次删除它：</p>
<pre><code>before remove:
Level 4:            7
Level 3:            7 8
Level 2:      4     7 8
Level 1:      4 5   7 8
Level 0:  1 3 4 5 6 7 8 9

remove: 1
Level 4:          7
Level 3:          7 8
Level 2:    4     7 8
Level 1:    4 5   7 8
Level 0:  3 4 5 6 7 8 9

remove: 6
Level 4:        7
Level 3:        7 8
Level 2:    4   7 8
Level 1:    4 5 7 8
Level 0:  3 4 5 7 8 9

remove: 9
Level 4:        7
Level 3:        7 8
Level 2:    4   7 8
Level 1:    4 5 7 8
Level 0:  3 4 5 7 8

remove: 3
Level 4:      7
Level 3:      7 8
Level 2:  4   7 8
Level 1:  4 5 7 8
Level 0:  4 5 7 8

remove: 5
Level 4:    7
Level 3:    7 8
Level 2:  4 7 8
Level 1:  4 7 8
Level 0:  4 7 8

remove: 7
Level 4: 
Level 3:    8
Level 2:  4 8
Level 1:  4 8
Level 0:  4 8

remove: 4
Level 4: 
Level 3:  8
Level 2:  8
Level 1:  8
Level 0:  8

remove: 8
Level 4: 
Level 3: 
Level 2: 
Level 1: 
Level 0: 
</code></pre>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="java">package com.algorithms.list;


import java.util.*;

/**
 * 跳表
 *
 * @Author: Yinjingwei
 * @Date: 2019/7/9/009 21:36
 * @Description:
 */
public class SkipList&lt;E extends Comparable&lt;? super E&gt;&gt; implements Iterable&lt;E&gt; &#123;
    //当前层数
    private int curLevel;
    //头结点，不保存值
    private Node head;
    //跳表中元素个数
    private int size;
    //用于生成随机层数
    private static final double PROBABILITY = 0.5;
    //最大层数,也可以写成通过构造函数注入的方式动态设置
    private static final int maxLevel = 8;

    public SkipList() &#123;
        size = 0;
        curLevel = 0;
        head = new Node(null);
    &#125;

    public int size() &#123;
        return size;
    &#125;

    public boolean add(E e) &#123;
        if (contains(e)) &#123;
            return false;
        &#125;
        int level = randomLevel();
        if (level &gt; curLevel) &#123;
            curLevel = level;
        &#125;
        Node newNode = new Node(e);
        Node current = head;
        //插入方向由上到下
        while (level &gt;= 0) &#123;
            //找到比e小的最大节点
            current = findNext(e, current, level);
            //将newNode插入到current后面
            //newNode的next指针指向该节点的后继
            newNode.forwards.add(0, current.next(level));
            //该节点的next指向newNode
            current.forwards.set(level, newNode);
            level--;//每层都要插入
        &#125;
        size++;
        return true;
    &#125;

    //返回给定层数中小于e的最大者
    private Node findNext(E e, Node current, int level) &#123;
        Node next = current.next(level);
        while (next != null) &#123;
            if (e.compareTo(next.data) &lt; 0) &#123;
                break;
            &#125;
            //到这说明e &gt;= next.data
            current = next;
            next = current.next(level);
        &#125;
        return current;
    &#125;

    public Node find(E e) &#123;
        if (empty()) &#123;
            return null;
        &#125;
        return find(e, head, curLevel);
    &#125;

    private Node find(E e, Node current, int level) &#123;
        while (level &gt;= 0) &#123;
            current = findNext(e, current, level);
            level--;
        &#125;
        return current;
    &#125;

    public boolean empty() &#123;
        return size == 0;
    &#125;

    /**
     * O(logN)的删除算法
     *
     * @param e
     * @return
     */
    public boolean remove(E e) &#123;
        if (empty()) &#123;
            return false;
        &#125;
        boolean removed = false;//记录是否删除
        int level = curLevel;
        //current用于遍历,pre指向待删除节点前一个节点
        Node current = head.next(level), pre = head;
        while (level &gt;= 0) &#123;
            while (current != null) &#123;
                //e &lt; current.data
                if (e.compareTo(current.data) &lt; 0) &#123;
                    break;
                &#125;
                //只有e &gt;= current.data才需要继续
                //如果e == current.data
                if (e.compareTo(current.data) == 0) &#123;
                    //pre指向它的后继
                    pre.forwards.set(level, current.next(level));
                    //设置删除标记
                    removed = true;
                    //跳出循环内层循环
                    break;
                &#125;
                pre = current;
                current = current.next(level);
            &#125;
            //继续搜索下一层
            level--;
            if (level &lt; 0) &#123;
                //防止next(-1)
                break;
            &#125;
            //往下一层,从pre开始往下即可，不需要从头(header)开始
            current = pre.next(level);
        &#125;
        if (removed) &#123;
            size--;//不要忘记size--
            return true;
        &#125;
        return false;
    &#125;

    /**
     * 生成随机层数[0,maxLevel)
     * 生成的值越大，概率越小
     *
     * @return
     */
    private int randomLevel() &#123;
        int level = 0;
        while (Math.random() &lt; PROBABILITY &amp;&amp; level &lt; maxLevel - 1) &#123;
            ++level;
        &#125;
        return level;
    &#125;

    public boolean contains(E e) &#123;
        Node node = find(e);
        return node != null &amp;&amp; node.data != null &amp;&amp; node.data.compareTo(e) == 0;
    &#125;

    @Override
    public Iterator&lt;E&gt; iterator() &#123;
        return new SkipListIterator();
    &#125;

    private class SkipListIterator implements Iterator&lt;E&gt; &#123;
        Node current = head;

        @Override
        public boolean hasNext() &#123;
            return current.next(0) != null;
        &#125;

        @Override
        public E next() &#123;
            current = current.next(0);
            return current.data;
        &#125;
    &#125;

    private class Node &#123;
        //保存值
        E data;
        //保存了每一层上的节点信息，可能为null
        List&lt;Node&gt; forwards;

        Node(E data) &#123;
            this.data = data;
            forwards = new ArrayList&lt;&gt;();
            //事先把每一层都置为null，虽然空间利用率没那么高，但是简化了实现
            //也可以通过自定义列表(比如B树实现中用到的Vector)来实现，就可以不用下面的操作
            for (int i = 0; i &lt;= maxLevel; i++) &#123;
                forwards.add(null);
            &#125;
        &#125;

        @Override
        public String toString() &#123;
            return data == null ? &quot; &quot; : &quot;&quot; + data;
        &#125;

        /**
         * 得到当前节点level层上的下一个(右边一个)节点
         *
         * @param level
         * @return
         */
        Node next(int level) &#123;
            return this.forwards.get(level);
        &#125;

    &#125;

    public void print() &#123;
        //记录了第0层值对应的索引，从1开始
        Map&lt;E, Integer&gt; indexMap = new HashMap&lt;&gt;();
        Node current = head.next(0);
        int index = 1;
        int maxWidth = 1;//值的最大宽度，为了格式化好看一点
        while (current != null) &#123;
            int curWidth = current.data.toString().length();
            if (curWidth &gt; maxWidth) &#123;
                maxWidth = curWidth;//得到最大宽度
            &#125;
            indexMap.put(current.data, index++);
            current = current.next(0);
        &#125;
        print(indexMap, maxWidth);
    &#125;

    private void print(int level, Node current, Map&lt;E, Integer&gt; indexMap, int width) &#123;
        System.out.print(&quot;Level &quot; + level + &quot;: &quot;);
        int preIndex = 0;//该层前一个元素的索引
        while (current != null) &#123;
            //当前元素的索引
            int curIndex = indexMap.get(current.data);
            if (level == 0) &#123;
                //第0层直接打印即可
                printSpace(curIndex - preIndex);
            &#125; else &#123;
                //其他层稍微复杂一点
                //计算空格数
                //相差的元素个数 + 相差的元素个数乘以宽度
                int num = (curIndex - preIndex) + (curIndex - preIndex - 1) * width;
                printSpace(num);
            &#125;
            System.out.printf(&quot;%&quot; + width + &quot;s&quot;, current.data);
            preIndex = curIndex;
            current = current.next(level);
        &#125;
        System.out.println();
    &#125;

    /**
     * 打印num个空格
     *
     * @param num
     */
    private void printSpace(int num) &#123;
        for (int i = 0; i &lt; num; i++) &#123;
            System.out.print(&#39; &#39;);
        &#125;
    &#125;

    private void print(Map&lt;E, Integer&gt; map, int width) &#123;
        //从顶层开始打印
        int level = curLevel;
        while (level &gt;= 0) &#123;
            print(level, head.next(level), map, width);
            level--;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        //Random random = new Random();
        //int[] values = random.ints(2000, 1, 10000).toArray();
        int[] values = &#123;1, 6, 9, 3, 5, 7, 4, 8&#125;;
        SkipList&lt;Integer&gt; list = new SkipList&lt;&gt;();
        for (int value : values) &#123;
            //System.out.println(&quot;add: &quot; + value);
            list.add(value);
            //list.print();
            //System.out.println();
        &#125;

        System.out.println(&quot;before remove:&quot;);
        list.print();
        System.out.println();


        for (int value : values) &#123;
            list.remove(value);
            System.out.println(&quot;remove: &quot; + value);
            list.print();
            System.out.println();
        &#125;

    &#125;
&#125;

</code></pre>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>跳表会不会很浪费内存？建立的索引必然会占用内存，但是会占用多少呢？我们来分析一下。</p>
<p>假设原始链表大小为nnn,那么第1层索引大约有n2\frac{n}{2}2n个节点，第2层有n4\frac{n}{4}4n个节点，依次类推，直到最后剩下2个节点，总数为：n2+n4+n8+…+8+4+2=n−2\frac{n}{2} + \frac{n}{4} + \frac{n}{8} + … + 8 + 4 + 2 = n - 22n+4n+8n+…+8+4+2=n−2，因此空间复杂度是O(n)O(n)O(n)</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>上文说了，查找的时间复杂度为O(logn)O(\log n)O(logn)，根据上面的图解，也不难理解，其实插入和删除都是在一次查找过程中实现的。<br>插入和删除的复杂度也是O(logn)O(\log n)O(logn)</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/28/mybatis-3-parameter%E5%92%8Cresult%E8%AE%BE%E7%BD%AE/" rel="prev" title="mybatis#3-parameter和result设置">
      <i class="fa fa-chevron-left"></i> mybatis#3-parameter和result设置
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/30/mybatis-4-%E8%BF%9E%E6%8E%A5%E6%B1%A0/" rel="next" title="mybatis#4-连接池">
      mybatis#4-连接池 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-text">特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-text">结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-text">插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-text">删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="nav-text">完整代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">时间复杂度</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
