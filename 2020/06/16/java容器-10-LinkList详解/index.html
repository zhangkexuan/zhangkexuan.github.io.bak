<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这次介绍一下List接口的另一个践行者——LinkedList，这是一位集诸多技能于一身的List接口践行者，可谓十八般武艺，样样精通，栈、队列、双端队列、链表、双向链表都可以用它来模拟，话不多说，赶紧一起来看看吧。 　　本篇将从以下几个方面对LinkedList进行解析： 　　1.LinkedList整体结构。 　　2.LinkedList基本操作使用栗子。 　　3.LinkedList与Ar">
<meta property="og:type" content="article">
<meta property="og:title" content="java容器#10-LinkedList详解">
<meta property="og:url" content="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="这次介绍一下List接口的另一个践行者——LinkedList，这是一位集诸多技能于一身的List接口践行者，可谓十八般武艺，样样精通，栈、队列、双端队列、链表、双向链表都可以用它来模拟，话不多说，赶紧一起来看看吧。 　　本篇将从以下几个方面对LinkedList进行解析： 　　1.LinkedList整体结构。 　　2.LinkedList基本操作使用栗子。 　　3.LinkedList与Ar">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/image-20200625130255080.png">
<meta property="og:image" content="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/image-20200625130308164.png">
<meta property="og:image" content="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/image-20200625130434997.png">
<meta property="og:image" content="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/image-20200625130502172.png">
<meta property="og:image" content="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/image-20200625130525569.png">
<meta property="og:image" content="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/image-20200625130654067.png">
<meta property="og:image" content="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/image-20200625130709555.png">
<meta property="article:published_time" content="2020-06-15T18:53:37.000Z">
<meta property="article:modified_time" content="2021-05-19T01:56:28.168Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="java容器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/image-20200625130255080.png">

<link rel="canonical" href="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java容器#10-LinkedList详解 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/java%E5%AE%B9%E5%99%A8-10-LinkList%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java容器#10-LinkedList详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 02:53:37" itemprop="dateCreated datePublished" datetime="2020-06-16T02:53:37+08:00">2020-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">java容器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>　这次介绍一下List接口的另一个践行者——LinkedList，这是一位集诸多技能于一身的List接口践行者，可谓十八般武艺，样样精通，栈、队列、双端队列、链表、双向链表都可以用它来模拟，话不多说，赶紧一起来看看吧。</p>
<p>　　本篇将从以下几个方面对LinkedList进行解析：</p>
<p>　　1.LinkedList整体结构。</p>
<p>　　2.LinkedList基本操作使用栗子。</p>
<p>　　3.LinkedList与ArrayList的对比分析。</p>
<p>　　4.LinkedList整体源码分析。</p>
<span id="more"></span>

<h1 id="LinkedList整体结构"><a href="#LinkedList整体结构" class="headerlink" title="LinkedList整体结构"></a>LinkedList整体结构</h1><p>　　先来看看LinkedList中的结构，LinkedList跟ArrayList不一样，ArrayList中是动态维护了一个数组，所有的操作都是 在该数据上进行操作，而LinkedList中其实是一个个的Node节点，每个Node节点首尾相连。如果你还记得前几篇的内容的话，就应该会想起HashMap中其实也是有Node节点的，但两者还是有比较多不一样的地方，先来看看LinkedList中的Node吧。</p>
<pre><code class="java">    private static class Node&lt;E&gt; &#123;
        E item;
        Node&lt;E&gt; next;
        Node&lt;E&gt; prev;

        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
            this.item = element;
            this.next = next;
            this.prev = prev;
        &#125;
    &#125;
</code></pre>
<p>　　嗯，其实很简单，里面只有三个成员变量，item用来存储具体的元素信息，next指向下一个Node节点，prev指向上一个Node节点，node节点之间通过next和prev相连接，组成了一个双向链表的形式。</p>
<p><img src="image-20200625130255080.png" alt="image-20200625130255080"></p>
<p><img src="image-20200625130308164.png" alt="image-20200625130308164"></p>
<p>　嗯，看图说话应该就很好懂了，LinkedList正是由Node这样首尾相连组成了铁索连环的格局。而HashMap中的Node节点其实是一个单链表的节点，只有指向后一个节点的引用（next），并没有指向前一个节点的引用，回顾一下HashMap的Node节点代码便能发现这一点。</p>
<pre><code class="java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;

        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        &#125;

       ......省略部分代码
    &#125;
</code></pre>
<h1 id="inkedList基本操作使用栗子"><a href="#inkedList基本操作使用栗子" class="headerlink" title="inkedList基本操作使用栗子"></a>inkedList基本操作使用栗子</h1><p>　　接下来看看LinkedList中的一些基础操作，以下是一个小栗子： </p>
<pre><code class="java">ublic class LinkedListTest &#123;

    public static void main(String[] args)&#123;
        // 定义要插入集合的字符串对象
        String a = &quot;A&quot;, b = &quot;B&quot;, c = &quot;C&quot;, d = &quot;D&quot;, e = &quot;E&quot;, f = &quot;F&quot;, g = &quot;G&quot;;
        // 创建List集合
        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();

        // add操作 添加元素
        list.add(a);
        list.add(b);
        list.add(c);
        list.add(f);

        // 迭代器遍历
        System.out.println(&quot;修改前：&quot;);
        traverseListByIterator(list);

        // set操作
        // 将索引位置为1的对象修改为对象g
        list.set(1, g);
        // 将索引位置为2的对象修改为对象d
        list.set(2, e);

        // 新建迭代器进行遍历（注意：迭代器是一次性使用的，遍历到列表尾部之后，无法重置，再次遍历时需要新建迭代器）
        System.out.println();
        System.out.println(&quot;set修改后的集合中的元素是：&quot;);
        traverseListByIterator(list);

        // 创建ArrayList
        List&lt;String&gt; strings = new ArrayList&lt;&gt;();
        strings.add(d);
        strings.add(a);
        strings.add(f);

        // addAll添加所有元素
        list.addAll(strings);

        //foreach方式遍历
        System.out.println(&quot;addAll修改后的集合中的元素是：&quot;);
        traverseListByForEach(list);

        // remove移除元素
        String removeElement = list.remove();
        System.out.println(&quot;移除的元素是：&quot; + removeElement);
        System.out.println(&quot;remove修改后的集合中的元素是：&quot;);
        traverseListByForEach(list);

        // add插入元素（在第四个位置插入元素&quot;gg&quot;）
        list.add(3, &quot;gg&quot;);
        System.out.println(&quot;add插入元素后的集合中的元素是：&quot;);
        traverseListByForEach(list);
    &#125;

    /**
     * foreach方式遍历列表
     * @param list 待遍历的列表
     */
    private static &lt;T&gt; void traverseListByForEach(List&lt;T&gt; list)&#123;
        for (T t : list)&#123;
            System.out.print(t + &quot; &quot;);
        &#125;
        System.out.println();
    &#125;

    /**
     * 迭代器方式遍历列表
     * @param list 待遍历的列表
     */
    private static &lt;T&gt; void traverseListByIterator(List&lt;T&gt; list)&#123;
        Iterator&lt;T&gt; iterator = list.iterator();
        // 循环获取列表中的元素
        while (iterator.hasNext()) &#123;
            System.out.print(iterator.next() + &quot; &quot;);
        &#125;
    &#125;

&#125;
</code></pre>
<p>　　这里仅仅演示了LinkedList的链表操作，主要有add、addAll、remove、set等，几乎每个常用方法都有重载方法，比如只有一个参数的add方法，会直接将该元素插入到列表的尾部，而有两个参数的add方法，会将元素插入指定位置。</p>
<h1 id="LinkedList与ArrayList的对比分析"><a href="#LinkedList与ArrayList的对比分析" class="headerlink" title="LinkedList与ArrayList的对比分析"></a>LinkedList与ArrayList的对比分析</h1><p>　　也许你会问，ArrayList不是也挺好用的吗，那些操作ArrayList也能做啊，为什么还要用LinkedList呢？</p>
<p>　　这是一个好问题，ArrayList的最大特点就是能随机访问，因为元素在物理上是连续存储的，所以访问的时候，可以通过简单的算法直接定位到指定位置，所以不管队列的元素数量有多少，总能在O(1)的时间里定位到指定位置，但是连续存储也是它的缺点，导致要在中间插入一个元素的时候，所有之后的元素都要往后挪动。而LinkedList的插入只需要调整前后元素的引用即可。</p>
<p><img src="image-20200625130434997.png" alt="image-20200625130434997"></p>
<p><img src="image-20200625130502172.png" alt="image-20200625130502172"></p>
<p><img src="image-20200625130525569.png" alt="image-20200625130525569"></p>
<p>看图说话，ArrayList插入显然需要进行更多的赋值操作，特别是数组元素个数比较多的时候，会更加明显，如果刚好需要扩容的话，那就会更慢了。而LinkedList只需要将插入位置的前后元素的next或prev引用进行调整即可，而且也没有扩容问题，因为它本身就没有容量的概念，理论上可以无限添加元素。</p>
<p>　　然后来实际对比一下效率差距：</p>
<pre><code class="java">public abstract class TimeCounter &#123;
    private String name;

    TimeCounter(String name)&#123;
        this.name = name;
    &#125;

    public void count()&#123;long time = System.currentTimeMillis();
        doSomething();
        System.out.println(name + &quot; 耗时：&quot; + (System.currentTimeMillis() - time));
    &#125;

    protected abstract void doSomething();
&#125;
</code></pre>
<p>　　先将这个计时抽象成一个模板，每个需要统计耗时的操作只需要继承该类，然后重写doSomeThing方法即可。</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args)&#123;
        TimeCounter arrayListAddCounter = new TimeCounter(&quot;ArrayList add插入到末尾：&quot;) &#123;
            private List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

            @Override
            protected void doSomething() &#123;
                for (int i = 0; i &lt; 100000; i++) &#123;
                    list.add( i);
                &#125;
            &#125;
        &#125;;

        TimeCounter linkedListAddCounter = new TimeCounter(&quot;LinkedList add插入到末尾：&quot;) &#123;
            private List&lt;Integer&gt; list = new LinkedList&lt;&gt;();

            @Override
            protected void doSomething() &#123;
                for (int i = 0; i &lt; 100000; i++) &#123;
                    list.add( i);
                &#125;
            &#125;
        &#125;;

        arrayListAddCounter.count();
        linkedListAddCounter.count();
    &#125;
&#125;
ArrayList add插入到末尾： 耗时：11
LinkedList add插入到末尾： 耗时：9
</code></pre>
<p>好像勉强符合预期，LinkedList比ArrayList略微快一点，其实如果在ArrayList容量足够的情况下，ArrayList的插入元素到末尾操作是要比LinkedList插入要快的，因为它只需要进行一次赋值即可，而LinkedList还需要先new一个新节点然后再接到链表的最后，这个new的过程看起来微不足道，但是一旦循环次数到达一定量级，开销是不可忽略的。例如把上面的循环次数从100000改成1000000，结果就会变成这样：</p>
<pre><code>ArrayList add插入到末尾： 耗时：40
LinkedList add插入到末尾： 耗时：768
</code></pre>
<p>这时候，创建节点的开销成了主要时间开销，效率甚至不如ArrayList。我们再换一个插入方式，上面是把元素插入到末尾，这次来把元素插入到首端看看：</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args)&#123;
        TimeCounter arrayListAddCounter = new TimeCounter(&quot;ArrayList add插入到首端：&quot;) &#123;
            private List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

            @Override
            protected void doSomething() &#123;
                for (int i = 0; i &lt; 100000; i++) &#123;
                    list.add(0, i);
                &#125;
            &#125;
        &#125;;

        TimeCounter linkedListAddCounter = new TimeCounter(&quot;LinkedList add插入到首端：&quot;) &#123;
            private List&lt;Integer&gt; list = new LinkedList&lt;&gt;();

            @Override
            protected void doSomething() &#123;
                for (int i = 0; i &lt; 100000; i++) &#123;
                    list.add(0, i);
                &#125;
            &#125;
        &#125;;

        arrayListAddCounter.count();
        linkedListAddCounter.count();
    &#125;
&#125;
ArrayList add插入到首端： 耗时：607
LinkedList add插入到首端： 耗时：11
</code></pre>
<p>　　当每次都插入在首端时，ArrayList每次都需要进行元素移动，而且列表中元素越多，需要进行移动的次数也越多，在这种情况下，LinkedList是明显优于ArrayList的。</p>
<p>　　所以说，其实这两者是各有所长各有所短的，一般情况下，选ArrayList就好，除非是需要进行循环操作的次数到达了万的量级的时候，才需要对两者进行选择。也许你会说，既然一般情况下，两者的效率差别不大，那直接用ArrayList就好了，说这么多干嘛呢。哈哈，如果是这样想，那就大错特错了。首先我们不仅需要知其然，还需要知其所以然，如果仅仅知道LinkedList比ArrayList插入效率高，但是却不知道为什么高，高多少，是远远不够的。其次，我们不能仅仅考虑正常情况，对于极端情况也需要有预防措施，对极端情况的思考，正是高手与新手的最大区别。</p>
<p>　　下面再看看查找元素的比较：</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args)&#123;
        TimeCounter arrayListAddCounter = new TimeCounter(&quot;ArrayList get遍历元素：&quot;) &#123;
            private List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

            &#123;
                for (int i = 0; i &lt; 100000; i++) &#123;
                    list.add(i);
                &#125;
            &#125;

            @Override
            protected void doSomething() &#123;
                for (int i = 0; i &lt; 100000; i++) &#123;
                    list.get(i);
                &#125;
            &#125;
        &#125;;

        TimeCounter linkedListAddCounter = new TimeCounter(&quot;LinkedList get遍历元素：&quot;) &#123;
            private List&lt;Integer&gt; list = new LinkedList&lt;&gt;();

            &#123;
                for (int i = 0; i &lt; 100000; i++) &#123;
                    list.add(i);
                &#125;
            &#125;

            @Override
            protected void doSomething() &#123;
                for (int i = 0; i &lt; 100000; i++) &#123;
                    list.get(i);
                &#125;
            &#125;
        &#125;;

        arrayListAddCounter.count();
        linkedListAddCounter.count();
    &#125;
&#125;
ArrayList get遍历元素： 耗时：3
LinkedList get遍历元素： 耗时：4484
</code></pre>
<p>　　ArrayList完胜，可以看出LinkedList中查找元素是一个十分耗时的操作，甚至比插入元素耗时还要长，因为每次get的时候都是从链表两端进行逐个查找，直到找到指定的位置。想要知道具体细节的话，那就耐心的看看下面的源码解析吧。</p>
<h1 id="LinkedList整体源码分析"><a href="#LinkedList整体源码分析" class="headerlink" title="LinkedList整体源码分析"></a>LinkedList整体源码分析</h1><p>　　先来看看LinkedList的整体结构：</p>
<p><img src="image-20200625130654067.png" alt="image-20200625130654067"></p>
<p><img src="image-20200625130709555.png" alt="image-20200625130709555"></p>
<p>　　可以看到LinkedList有四个内部类，分别是Node、ListItr、DescendingIterator、LLSpliterator。Node类主要用于存放元素，先来看看Node：</p>
<pre><code class="java">    private static class Node&lt;E&gt; &#123;
        //存放元素
        E item;
        //指向下一个Node节点
        Node&lt;E&gt; next;
        //指向上一个Node节点
        Node&lt;E&gt; prev;

        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
            this.item = element;
            this.next = next;
            this.prev = prev;
        &#125;
    &#125;
</code></pre>
<p>　　这是可以说是最简单的类了，也构成了LinkedList的基础，LinkedList正是由一个个Node节点连接组成。再来看看ListItr类：</p>
<pre><code class="java">    //列表迭代器类
    private class ListItr implements ListIterator&lt;E&gt; &#123;
        private Node&lt;E&gt; lastReturned;
        private Node&lt;E&gt; next;
        private int nextIndex;
        private int expectedModCount = modCount;

        ListItr(int index) &#123;
            // assert isPositionIndex(index);
            next = (index == size) ? null : node(index);
            nextIndex = index;
        &#125;

        public boolean hasNext() &#123;
            return nextIndex &lt; size;
        &#125;

        public E next() &#123;
            checkForComodification();
            if (!hasNext())
                throw new NoSuchElementException();

            lastReturned = next;
            next = next.next;
            nextIndex++;
            return lastReturned.item;
        &#125;

        public boolean hasPrevious() &#123;
            return nextIndex &gt; 0;
        &#125;

        public E previous() &#123;
            checkForComodification();
            if (!hasPrevious())
                throw new NoSuchElementException();

            lastReturned = next = (next == null) ? last : next.prev;
            nextIndex--;
            return lastReturned.item;
        &#125;

        public int nextIndex() &#123;
            return nextIndex;
        &#125;

        public int previousIndex() &#123;
            return nextIndex - 1;
        &#125;

        public void remove() &#123;
            checkForComodification();
            if (lastReturned == null)
                throw new IllegalStateException();

            Node&lt;E&gt; lastNext = lastReturned.next;
            unlink(lastReturned);
            if (next == lastReturned)
                next = lastNext;
            else
                nextIndex--;
            lastReturned = null;
            expectedModCount++;
        &#125;

        public void set(E e) &#123;
            if (lastReturned == null)
                throw new IllegalStateException();
            checkForComodification();
            lastReturned.item = e;
        &#125;

        public void add(E e) &#123;
            checkForComodification();
            lastReturned = null;
            if (next == null)
                linkLast(e);
            else
                linkBefore(e, next);
            nextIndex++;
            expectedModCount++;
        &#125;

        public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;
            Objects.requireNonNull(action);
            while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;
                action.accept(next.item);
                lastReturned = next;
                next = next.next;
                nextIndex++;
            &#125;
            checkForComodification();
        &#125;

        final void checkForComodification() &#123;
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        &#125;
    &#125;
</code></pre>
<p>　　这个类是LinkedList的迭代器类，主要用于顺序遍历LinkedList，在前面的栗子中有使用迭代器的hasNext方法和next方法，其实它们的实现都很简单，hasNext只是简单的比较下一个要访问的元素序号是否大于列表中的元素个数，next方法则是将next的引用赋值给lastReturned变量，然后将next指向其下一个节点并且将index加1。但跟普通迭代器不一样的地方在于这个迭代器不仅可以正序遍历，还可以使用previous方法进行倒序遍历，DescendingIterator便是使用了迭代器的previous方法进行便利的。</p>
<pre><code class="java">    /**
     * 降序迭代器
     */
    private class DescendingIterator implements Iterator&lt;E&gt; &#123;
        private final ListItr itr = new ListItr(size());
        public boolean hasNext() &#123;
            return itr.hasPrevious();
        &#125;
        public E next() &#123;
            return itr.previous();
        &#125;
        public void remove() &#123;
            itr.remove();
        &#125;
    &#125;
</code></pre>
<p>　　这个迭代器就比较简单了，只是包裹了一个ListItr实例，然后重载了Iterator的几个方法。LLSpliterator是用于并行流的可分割式迭代器，这里就不做过多介绍了。</p>
<p>　　再来看看常用的几个方法的实现：</p>
<pre><code class="java">    /**
     * 添加指定元素到列表尾部
     */
    public boolean add(E e) &#123;
        linkLast(e);
        return true;
    &#125;

    /**
     * 把元素e链接成尾节点
     */
    void linkLast(E e) &#123;
        final Node&lt;E&gt; l = last;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    &#125;
</code></pre>
<p>　　当插入一个元素时，会new一个Node对象，并将该值放入Node节点中，然后挂到链表的尾部。</p>
<pre><code class="java">    /**
     * 在列表指定位置插入指定元素
     */
    public void add(int index, E element) &#123;
        checkPositionIndex(index);

        if (index == size)
            linkLast(element);
        else
            linkBefore(element, node(index));
    &#125;

    /**
     * 插入一个元素到指定非空节点之前
     */
    void linkBefore(E e, Node&lt;E&gt; succ) &#123;
        // assert succ != null;
        final Node&lt;E&gt; pred = succ.prev;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    &#125;
</code></pre>
<p>　　add的重载版本，可以指定序号进行插入，将元素插入到链表中间，进行的操作过程可以联系前面的图进行理解。</p>
<pre><code class="java">    /**
     * 返回指定位置的元素
     */
    public E get(int index) &#123;
        checkElementIndex(index);
        return node(index).item;
    &#125;

    /**
     * 返回指定元素序号的非空节点。
     */
    Node&lt;E&gt; node(int index) &#123;
        // assert isElementIndex(index);

        //做了一个小优化，如果取的序号小于元素个数的一半，则从链表首端开始遍历，否则从链表尾部开始遍历
        if (index &lt; (size &gt;&gt; 1)) &#123;
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        &#125; else &#123;
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        &#125;
    &#125;
</code></pre>
<p>　　可以看到get方法其实是从头部或者尾部进行遍历定位的，每次将x的引用向后/向前移动一位，当链表数据量比较大时，这个过程其实是很耗时间的，前面的对比中应该也能发现这一点。</p>
<pre><code class="java">    /**
     * 取回并删除此列表的头部（第一个元素）。
     */
    public E remove() &#123;
        return removeFirst();
    &#125;

    /**
     * 移除列表指定位置的元素，如果其后子序列存在，则将其元素左移，将它们的序号减一。
     * 返回列表中移除的元素。
     */
    public E remove(int index) &#123;
        checkElementIndex(index);
        return unlink(node(index));
    &#125;

    /**
     * 移除并返回首节点
     */
    public E removeFirst() &#123;
        final Node&lt;E&gt; f = first;
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    &#125;

    /**
     * 移除首节点并返回该节点元素值
     */
    private E unlinkFirst(Node&lt;E&gt; f) &#123;
        // assert f == first &amp;&amp; f != null;
        final E element = f.item;
        final Node&lt;E&gt; next = f.next;
        f.item = null;
        f.next = null; // help GC
        first = next;
        if (next == null)
            last = null;
        else
            next.prev = null;
        size--;
        modCount++;
        return element;
    &#125;

    /**
     * 移除非空节点x
     */
    E unlink(Node&lt;E&gt; x) &#123;
        // assert x != null;
        final E element = x.item;
        final Node&lt;E&gt; next = x.next;
        final Node&lt;E&gt; prev = x.prev;

        if (prev == null) &#123;
            first = next;
        &#125; else &#123;
            prev.next = next;
            x.prev = null;
        &#125;

        if (next == null) &#123;
            last = prev;
        &#125; else &#123;
            next.prev = prev;
            x.next = null;
        &#125;

        x.item = null;
        size--;
        modCount++;
        return element;
    &#125;
</code></pre>
<p>　　remove方法也有两个重载版本，不带参数的remove方法仅仅移除并返回最后一个节点，而指定序号参数的remove方法则会移除并返回链表中指定位置的节点。</p>
<p>　　此外链表还有可以用于队列的诸多方法：</p>
<ul>
<li>在尾部添加元素：(add, offer)，add()会在长度不够时抛出异常：IllegalStateException;  offer()则不会,只返回false。</li>
<li>查看头部元素 (element, peek)，返回头部元素，但不改变队列。element()会在没元素时抛出异常：NoSuchElementException;  peek()返回null;</li>
<li>删除头部元素 (remove, poll)，返回头部元素，并且从队列中删除，remove()会在没元素时抛出异常：NoSuchElementException;  poll()返回null; </li>
</ul>
<p>　　即可以通过以上方法来实现单向队列的操作，也可以使用addFirst,addLast,removeFirst,removeLast方法来实现双向队列的操作。以下是一个简单队列的实现：</p>
<pre><code class="java">public class MyQueue&lt;T&gt; &#123;
    private LinkedList&lt;T&gt; list = new LinkedList&lt;T&gt;();

    //清空队列
    public void clear() &#123;
        list.clear();
    &#125;

    //判断队列是否为空
    public boolean isEmpty() &#123;
        return list.isEmpty();
    &#125;

    //进队
    public void enqueue(T o) &#123;
        list.addLast(o);
    &#125;

    //出队
    public T dequeue()&#123;
        if(!list.isEmpty())
        &#123;
            return list.removeFirst();
        &#125;
        return null;
    &#125;

    //获取队列长度
    public int length() &#123;
        return list.size();
    &#125;

    //查看队首元素
    public T peek() &#123;
        return list.getFirst();
    &#125;
    
    //测试队列
    public static void main(String[] args) &#123;
        MyQueue&lt;String&gt; queue = new MyQueue&lt;String&gt;();
        System.out.println(queue.isEmpty());
        queue.enqueue(&quot;a&quot;);
        queue.enqueue(&quot;b&quot;);
        queue.enqueue(&quot;c&quot;);
        queue.enqueue(&quot;d&quot;);
        queue.enqueue(&quot;e&quot;);
        queue.enqueue(&quot;f&quot;);
        System.out.println(queue.length());
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        System.out.println(queue.peek());
        System.out.println(queue.dequeue());
        queue.clear();
        queue.enqueue(&quot;s&quot;);
        queue.enqueue(&quot;t&quot;);
        queue.enqueue(&quot;r&quot;);
        System.out.println(queue.dequeue());
        System.out.println(queue.length());
        System.out.println(queue.peek());
        System.out.println(queue.dequeue());
    &#125;
&#125;
</code></pre>
<p>　　嗯，其实就是借鸡生蛋的事情嘛，哈哈。</p>
<p>　　再来看看用LinkedList的简单栈实现：</p>
<pre><code class="java">public class MyStack&lt;T&gt; &#123;
    private LinkedList&lt;T&gt; stack = new LinkedList&lt;T&gt;();

    // 入栈
    public void push(T v) &#123;
        stack.addFirst(v);
    &#125;

    // 出栈，但不删除
    public T peek() &#123;
        return stack.getFirst();
    &#125;

    // 出栈
    public T pop() &#123;
        return stack.removeFirst();
    &#125;

    // 栈是否为空
    public boolean empty() &#123;
        return stack.isEmpty();
    &#125;

    // 打印栈元素
    public String toString() &#123;
        return stack.toString();
    &#125;
&#125;
</code></pre>
<p>　　你看，其实很简单吧，LinkedList提供的大量的方法，可以很方便的进行链表、双向链表、队列、双端队列、栈等数据结构的实现，可以说非常好用了。</p>
<p>　　下面是LinkedList的全部源码，行有余力的话可以选择你想要了解的部分进行阅读，如果有不懂的地方可以在本文后面留言，当然，也可以直接跳过，以后想要深入了解的时候再进行阅读也不迟。</p>
<pre><code class="java">/**
 * 双向链表实现了List接口和Deque接口，实现了多有可选List操作，并且允许放入所有的元素，包括null。
 *
 * 所有的操作都表现得像双向链表，索引到列表中的操作将从开头或者结尾遍历列表，以较接近指定索引为准。
 *
 * 注意，这个实现类不是线程安全的，如果多个线程同时访问一个链表，并且至少一个线程修改了链表的结构，
 * 则必须在外部实现同步。结构性修改指的是那些增加删除一个或多个元素的操作，仅设置元素的值不是结构修改。
 * 这通常通过在封装列表的某个对象上进行同步来实现。
 *
 * 如果没有这样的对象存在，则列表应该使用Collections#synchronizedList方法包装，最好在创建列表的时候进行，
 * 以防止意外的非同步引用对列表进行了修改。
 *   List list = Collections.synchronizedList(new LinkedList(...));
 *
 * 该类的iterator方法和listIterator方法返回的迭代器是“fail-fast”的，如果列表在迭代器创建之后的任何时刻被进行
 * 结构性的修改了，则调用迭代器自身的remove或者add方法时将会抛出ConcurrentModificationException异常，因此
 * 当遇到并发修改时，迭代器会快速的失败，而不是在未来某个不确定的时刻进行武断冒险或不确定性的行为
 *
 * 注意，通常来说，不能保证迭代器的fail-fast机制，在遇到非同步的并发修改时，不可能做出任何严格的保证。
 * fail-fast 迭代器只能尽最大努力抛出ConcurrentModificationException异常，因此，如果程序依赖这个异常来
 * 进行正确性判断是错误的，fail-fast机制仅应该用于检测异常。
 *
 */

public class LinkedList&lt;E&gt;
        extends AbstractSequentialList&lt;E&gt;
        implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;
    transient int size = 0;

    /**
     * 指向第一个节点
     * 恒等式: (first == null &amp;&amp; last == null) ||
     *            (first.prev == null &amp;&amp; first.item != null)
     */
    transient Node&lt;E&gt; first;

    /**
     * 指向最后一个节点
     * 恒等式: (first == null &amp;&amp; last == null) ||
     *            (last.next == null &amp;&amp; last.item != null)
     */
    transient Node&lt;E&gt; last;

    /**
     * 构造一个空的列表
     */
    public LinkedList() &#123;
    &#125;

    /**
     * 构造一个包含指定集合内所有元素的列表，存储的顺序为集合的迭代器访问顺序。
     * @throws NullPointerException 空指针异常
     */
    public LinkedList(Collection&lt;? extends E&gt; c) &#123;
        this();
        addAll(c);
    &#125;

    /**
     * 把元素e链接成首节点
     */
    private void linkFirst(E e) &#123;
        final Node&lt;E&gt; f = first;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);
        first = newNode;
        if (f == null)
            last = newNode;
        else
            f.prev = newNode;
        size++;
        modCount++;
    &#125;

    /**
     * 把元素e链接成尾节点
     */
    void linkLast(E e) &#123;
        final Node&lt;E&gt; l = last;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    &#125;

    /**
     * 插入一个元素到指定非空节点之前
     */
    void linkBefore(E e, Node&lt;E&gt; succ) &#123;
        // assert succ != null;
        final Node&lt;E&gt; pred = succ.prev;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    &#125;

    /**
     * 移除首节点并返回该节点元素值
     */
    private E unlinkFirst(Node&lt;E&gt; f) &#123;
        // assert f == first &amp;&amp; f != null;
        final E element = f.item;
        final Node&lt;E&gt; next = f.next;
        f.item = null;
        f.next = null; // help GC
        first = next;
        if (next == null)
            last = null;
        else
            next.prev = null;
        size--;
        modCount++;
        return element;
    &#125;

    /**
     * 移除尾节点并返回该节点元素值
     */
    private E unlinkLast(Node&lt;E&gt; l) &#123;
        // assert l == last &amp;&amp; l != null;
        final E element = l.item;
        final Node&lt;E&gt; prev = l.prev;
        l.item = null;
        l.prev = null; // help GC
        last = prev;
        if (prev == null)
            first = null;
        else
            prev.next = null;
        size--;
        modCount++;
        return element;
    &#125;

    /**
     * 移除非空节点x
     */
    E unlink(Node&lt;E&gt; x) &#123;
        // assert x != null;
        final E element = x.item;
        final Node&lt;E&gt; next = x.next;
        final Node&lt;E&gt; prev = x.prev;

        if (prev == null) &#123;
            first = next;
        &#125; else &#123;
            prev.next = next;
            x.prev = null;
        &#125;

        if (next == null) &#123;
            last = prev;
        &#125; else &#123;
            next.prev = prev;
            x.next = null;
        &#125;

        x.item = null;
        size--;
        modCount++;
        return element;
    &#125;

    /**
     * 返回列表的首节点
     */
    public E getFirst() &#123;
        final Node&lt;E&gt; f = first;
        if (f == null)
            throw new NoSuchElementException();
        return f.item;
    &#125;

    /**
     * 返回列表的最后一个节点
     */
    public E getLast() &#123;
        final Node&lt;E&gt; l = last;
        if (l == null)
            throw new NoSuchElementException();
        return l.item;
    &#125;

    /**
     * 移除并返回首节点
     */
    public E removeFirst() &#123;
        final Node&lt;E&gt; f = first;
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    &#125;

    /**
     * 移除并返回尾节点
     */
    public E removeLast() &#123;
        final Node&lt;E&gt; l = last;
        if (l == null)
            throw new NoSuchElementException();
        return unlinkLast(l);
    &#125;

    /**
     * 插入指定元素到列表首端
     */
    public void addFirst(E e) &#123;
        linkFirst(e);
    &#125;

    /**
     * 扩展指定元素到列表尾端
     */
    public void addLast(E e) &#123;
        linkLast(e);
    &#125;

    /**
     * 返回列表中是否包含指定元素
     */
    public boolean contains(Object o) &#123;
        return indexOf(o) != -1;
    &#125;

    /**
     * 返回列表中元素个数
     */
    public int size() &#123;
        return size;
    &#125;

    /**
     * 添加指定元素到列表尾部
     */
    public boolean add(E e) &#123;
        linkLast(e);
        return true;
    &#125;

    /**
     * 如果该元素存在，则移除列表中首次出现的该指定元素，如果不存在，则原链表不会改变。
     * 如果该列表中包含该指定元素则返回true，否则返回false
     */
    public boolean remove(Object o) &#123;
        if (o == null) &#123;
            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
                if (x.item == null) &#123;
                    unlink(x);
                    return true;
                &#125;
            &#125;
        &#125; else &#123;
            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
                if (o.equals(x.item)) &#123;
                    unlink(x);
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;

    /**
     * 添加指定集合中的所有元素到列表的尾部，顺序为指定集合的迭代器遍历顺序。如果该操作正在进行时，指定集合
     * 被修改了，那么该操作的行为是不可预测的。
     */
    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;
        return addAll(size, c);
    &#125;

    /**
     * 将指定集合中的所有元素插入到该列表的指定位置之后。将当前在该位置的元素及其之后的元素右移。新元素在列表
     * 中的顺序为其原集合迭代器遍历顺序。
     */
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;
        checkPositionIndex(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        if (numNew == 0)
            return false;

        Node&lt;E&gt; pred, succ;
        if (index == size) &#123;
            succ = null;
            pred = last;
        &#125; else &#123;
            succ = node(index);
            pred = succ.prev;
        &#125;

        for (Object o : a) &#123;
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
            Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);
            if (pred == null)
                first = newNode;
            else
                pred.next = newNode;
            pred = newNode;
        &#125;

        if (succ == null) &#123;
            last = pred;
        &#125; else &#123;
            pred.next = succ;
            succ.prev = pred;
        &#125;

        size += numNew;
        modCount++;
        return true;
    &#125;

    /**
     * 移除列表中所有元素
     */
    public void clear() &#123;
        // 清除节点之间所有元素的链接不是必要的，但是:
        // - 如果被清除的节点处于不同代之间，可以帮助分代GC。
        // - 一定要释放内存，即便有一个迭代器引用
        for (Node&lt;E&gt; x = first; x != null; ) &#123;
            Node&lt;E&gt; next = x.next;
            x.item = null;
            x.next = null;
            x.prev = null;
            x = next;
        &#125;
        first = last = null;
        size = 0;
        modCount++;
    &#125;


    // 位置访问操作

    /**
     * 返回指定位置的元素
     */
    public E get(int index) &#123;
        checkElementIndex(index);
        return node(index).item;
    &#125;

    /**
     * 使用指定元素替换指定位置的元素
     */
    public E set(int index, E element) &#123;
        checkElementIndex(index);
        Node&lt;E&gt; x = node(index);
        E oldVal = x.item;
        x.item = element;
        return oldVal;
    &#125;

    /**
     * 在列表指定位置插入指定元素，如果该位置有任何元素，则将其后的子序列元素都往右移（将它们的序号都增加1）
     */
    public void add(int index, E element) &#123;
        checkPositionIndex(index);

        if (index == size)
            linkLast(element);
        else
            linkBefore(element, node(index));
    &#125;

    /**
     * 移除列表指定位置的元素，如果其后子序列存在，则将其元素左移，将它们的序号减一。
     * 返回列表中移除的元素。
     */
    public E remove(int index) &#123;
        checkElementIndex(index);
        return unlink(node(index));
    &#125;

    /**
     * 判断该序号是否在列表中对应位置存在元素
     */
    private boolean isElementIndex(int index) &#123;
        return index &gt;= 0 &amp;&amp; index &lt; size;
    &#125;

    /**
     * 判断给参数是否是迭代器或者add操作的合法位置
     */
    private boolean isPositionIndex(int index) &#123;
        return index &gt;= 0 &amp;&amp; index &lt;= size;
    &#125;

    /**
     * 构造一个IndexOutOfBoundsException 异常的详情消息，在错误处理代码的许多可能的重构中，
     * 这个大纲在服务端和客户端虚拟机中都表现的最好。
     */
    private String outOfBoundsMsg(int index) &#123;
        return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
    &#125;

    private void checkElementIndex(int index) &#123;
        if (!isElementIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    &#125;

    private void checkPositionIndex(int index) &#123;
        if (!isPositionIndex(index))
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    &#125;

    /**
     * 返回指定元素序号的非空节点。
     */
    Node&lt;E&gt; node(int index) &#123;
        // assert isElementIndex(index);

        //做了一个小优化，如果取的序号小于元素个数的一半，则从链表首端开始遍历，否则从链表尾部开始遍历
        if (index &lt; (size &gt;&gt; 1)) &#123;
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        &#125; else &#123;
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        &#125;
    &#125;

    // 搜索操作

    /**
     * 返回指定元素在列表中第一次出现的位置，否则返回-1
     */
    public int indexOf(Object o) &#123;
        int index = 0;
        if (o == null) &#123;
            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
                if (x.item == null)
                    return index;
                index++;
            &#125;
        &#125; else &#123;
            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
                if (o.equals(x.item))
                    return index;
                index++;
            &#125;
        &#125;
        return -1;
    &#125;

    /**
     * 返回指定元素在链表中最后一次出现的位置，如果链表中不包含该元素，则返回-1
     */
    public int lastIndexOf(Object o) &#123;
        int index = size;
        if (o == null) &#123;
            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;
                index--;
                if (x.item == null)
                    return index;
            &#125;
        &#125; else &#123;
            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;
                index--;
                if (o.equals(x.item))
                    return index;
            &#125;
        &#125;
        return -1;
    &#125;

    // 队列操作

    /**
     * 取回但不删除此列表的头部（第一个元素）。
     */
    public E peek() &#123;
        final Node&lt;E&gt; f = first;
        return (f == null) ? null : f.item;
    &#125;

    /**
     * 取回但不删除此列表的头部（第一个元素）。
     * 如果不存在，则会抛出NoSuchElementException异常
     */
    public E element() &#123;
        return getFirst();
    &#125;

    /**
     * 取回并删除此列表的头部（第一个元素）。
     * 如果该链表为空，则返回null
     */
    public E poll() &#123;
        final Node&lt;E&gt; f = first;
        return (f == null) ? null : unlinkFirst(f);
    &#125;

    /**
     * 取回并删除此列表的头部（第一个元素）。
     */
    public E remove() &#123;
        return removeFirst();
    &#125;

    /**
     * 添加指定元素到链表尾部
     */
    public boolean offer(E e) &#123;
        return add(e);
    &#125;

    // 双向队列操作
    /**
     * 插入指定元素到队列首部
     */
    public boolean offerFirst(E e) &#123;
        addFirst(e);
        return true;
    &#125;

    /**
     * 插入指定元素到队列尾部
     */
    public boolean offerLast(E e) &#123;
        addLast(e);
        return true;
    &#125;

    /**
     *
     * 取回但是不删除队列的首元素。如果队列为空则返回null。
     */
    public E peekFirst() &#123;
        final Node&lt;E&gt; f = first;
        return (f == null) ? null : f.item;
    &#125;

    /**
     * 取回但是不删除链表的最后一个元素，如果队列为空，则返回null
     */
    public E peekLast() &#123;
        final Node&lt;E&gt; l = last;
        return (l == null) ? null : l.item;
    &#125;

    /**
     * 取回并删除队列的首元素，如果队列为空，则返回null
     */
    public E pollFirst() &#123;
        final Node&lt;E&gt; f = first;
        return (f == null) ? null : unlinkFirst(f);
    &#125;

    /**
     * 取回并删除队列的尾元素，如果队列为空，则返回null
     */
    public E pollLast() &#123;
        final Node&lt;E&gt; l = last;
        return (l == null) ? null : unlinkLast(l);
    &#125;

    /**
     * 在队列前端插入元素
     */
    public void push(E e) &#123;
        addFirst(e);
    &#125;

    /**
     * 删除并返回队列的第一个元素，如果列表为空则抛出NoSuchElementException 异常
     */
    public E pop() &#123;
        return removeFirst();
    &#125;

    /**
     * 删除此队列中第一个出现的指定元素（从头到尾的方式遍历时），如果队列中不包含该元素，则队列不会改变。
     */
    public boolean removeFirstOccurrence(Object o) &#123;
        return remove(o);
    &#125;

    /**
     * 删除此队列中最后一次出现的指定元素（从头到尾的方式遍历时），如果队列中不包含该元素，则队列不会改变。
     */
    public boolean removeLastOccurrence(Object o) &#123;
        if (o == null) &#123;
            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;
                if (x.item == null) &#123;
                    unlink(x);
                    return true;
                &#125;
            &#125;
        &#125; else &#123;
            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;
                if (o.equals(x.item)) &#123;
                    unlink(x);
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;

    /**
     * 返回从指定位置开始，以正确的序列迭代该列表的迭代器.
     * 列表迭代器是“fail-fast”的，如果列表在迭代器创建之后的任何时刻被进行
     * 结构性的修改了，则调用迭代器自身的remove或者add方法时将会抛出ConcurrentModificationException异常，因此
     * 当遇到并发修改时，迭代器会快速的失败，而不是在未来某个不确定的时刻进行武断冒险或不确定性的行为
     *
     * 注意，通常来说，不能保证迭代器的fail-fast机制，在遇到非同步的并发修改时，不可能做出任何严格的保证。
     * fail-fast 迭代器只能尽最大努力抛出ConcurrentModificationException异常，因此，如果程序依赖这个异常来
     * 进行正确性判断是错误的，fail-fast机制仅应该用于检测异常。
     */
    public ListIterator&lt;E&gt; listIterator(int index) &#123;
        checkPositionIndex(index);
        return new ListItr(index);
    &#125;

    //列表迭代器类
    private class ListItr implements ListIterator&lt;E&gt; &#123;
        //记录上一个返回的节点
        private Node&lt;E&gt; lastReturned;
        //指向下一个节点
        private Node&lt;E&gt; next;
        //下一个节点的序号
        private int nextIndex;
        //用于检测遍历过程中List是否被修改
        private int expectedModCount = modCount;

        ListItr(int index) &#123;
            // assert isPositionIndex(index);
            next = (index == size) ? null : node(index);
            nextIndex = index;
        &#125;

        public boolean hasNext() &#123;
            return nextIndex &lt; size;
        &#125;

        public E next() &#123;
            //检测是否修改
            checkForComodification();
            if (!hasNext())
                throw new NoSuchElementException();

            lastReturned = next;
            next = next.next;
            nextIndex++;
            return lastReturned.item;
        &#125;

        public boolean hasPrevious() &#123;
            return nextIndex &gt; 0;
        &#125;

        public E previous() &#123;
            checkForComodification();
            if (!hasPrevious())
                throw new NoSuchElementException();

            lastReturned = next = (next == null) ? last : next.prev;
            nextIndex--;
            return lastReturned.item;
        &#125;

        public int nextIndex() &#123;
            return nextIndex;
        &#125;

        public int previousIndex() &#123;
            return nextIndex - 1;
        &#125;

        public void remove() &#123;
            checkForComodification();
            if (lastReturned == null)
                throw new IllegalStateException();

            Node&lt;E&gt; lastNext = lastReturned.next;
            unlink(lastReturned);
            if (next == lastReturned)
                next = lastNext;
            else
                nextIndex--;
            lastReturned = null;
            expectedModCount++;
        &#125;

        public void set(E e) &#123;
            if (lastReturned == null)
                throw new IllegalStateException();
            checkForComodification();
            lastReturned.item = e;
        &#125;

        public void add(E e) &#123;
            checkForComodification();
            lastReturned = null;
            if (next == null)
                linkLast(e);
            else
                linkBefore(e, next);
            nextIndex++;
            expectedModCount++;
        &#125;

        public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;
            Objects.requireNonNull(action);
            while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123;
                action.accept(next.item);
                lastReturned = next;
                next = next.next;
                nextIndex++;
            &#125;
            checkForComodification();
        &#125;

        final void checkForComodification() &#123;
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        &#125;
    &#125;

    private static class Node&lt;E&gt; &#123;
        //存放元素
        E item;
        //指向下一个Node节点
        Node&lt;E&gt; next;
        //指向上一个Node节点
        Node&lt;E&gt; prev;

        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
            this.item = element;
            this.next = next;
            this.prev = prev;
        &#125;
    &#125;

    /**
     * 返回一个倒序遍历的迭代器
     */
    public Iterator&lt;E&gt; descendingIterator() &#123;
        return new DescendingIterator();
    &#125;

    /**
     * 降序迭代器
     */
    private class DescendingIterator implements Iterator&lt;E&gt; &#123;
        private final ListItr itr = new ListItr(size());
        public boolean hasNext() &#123;
            return itr.hasPrevious();
        &#125;
        public E next() &#123;
            return itr.previous();
        &#125;
        public void remove() &#123;
            itr.remove();
        &#125;
    &#125;

    private LinkedList&lt;E&gt; superClone() &#123;
        try &#123;
            return (LinkedList&lt;E&gt;) super.clone();
        &#125; catch (CloneNotSupportedException e) &#123;
            throw new InternalError(e);
        &#125;
    &#125;

    /**
     * 浅克隆
     */
    public Object clone() &#123;
        LinkedList&lt;E&gt; clone = superClone();

        // Put clone into &quot;virgin&quot; state
        clone.first = clone.last = null;
        clone.size = 0;
        clone.modCount = 0;

        // Initialize clone with our elements
        for (Node&lt;E&gt; x = first; x != null; x = x.next)
            clone.add(x.item);

        return clone;
    &#125;

    /**
     * 返回一个包含列表所有元素的数组，元素的顺序为从第一个到最后一个。
     */
    public Object[] toArray() &#123;
        Object[] result = new Object[size];
        int i = 0;
        for (Node&lt;E&gt; x = first; x != null; x = x.next)
            result[i++] = x.item;
        return result;
    &#125;

    /**
     * 返回一个包含列表所有元素的数组，元素的顺序为从第一个到最后一个。返回元素数组的类型
     * 与指定数组的类型一致。如果列表大小适合指定的数组，则返回该数组。 否则，将为新数组分配指定
     * 数组的运行时类型和此列表的大小。
     *
     * 如果列表的空间适合指定的数组（数组比列表有更多的元素），紧跟在列表末尾之后的数组中的元素设置
     * 为null（仅当调用者知道列表不包含任何null元素时，这在确定列表长度时很有用。）
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T[] toArray(T[] a) &#123;
        if (a.length &lt; size)
            a = (T[])java.lang.reflect.Array.newInstance(
                    a.getClass().getComponentType(), size);
        int i = 0;
        Object[] result = a;
        for (Node&lt;E&gt; x = first; x != null; x = x.next)
            result[i++] = x.item;

        if (a.length &gt; size)
            a[size] = null;

        return a;
    &#125;

    private static final long serialVersionUID = 876323262645176354L;

    /**
     * 序列化
     */
    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException &#123;
        // Write out any hidden serialization magic
        s.defaultWriteObject();

        // Write out size
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (Node&lt;E&gt; x = first; x != null; x = x.next)
            s.writeObject(x.item);
    &#125;

    /**
     * 反序列化
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException &#123;
        // Read in any hidden serialization magic
        s.defaultReadObject();

        // Read in size
        int size = s.readInt();

        // Read in all elements in the proper order.
        for (int i = 0; i &lt; size; i++)
            linkLast((E)s.readObject());
    &#125;

    /**
     * 创建一个可分割的迭代器
     */
    @Override
    public Spliterator&lt;E&gt; spliterator() &#123;
        return new LLSpliterator&lt;E&gt;(this, -1, 0);
    &#125;

    /** Spliterators.IteratorSpliterator 的定制版本 */
    static final class LLSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123;
        static final int BATCH_UNIT = 1 &lt;&lt; 10;  // batch array size increment
        static final int MAX_BATCH = 1 &lt;&lt; 25;  // max batch array size;
        final LinkedList&lt;E&gt; list; // null OK unless traversed
        Node&lt;E&gt; current;      // current node; null until initialized
        int est;              // size estimate; -1 until first needed
        int expectedModCount; // initialized when est set
        int batch;            // batch size for splits

        LLSpliterator(LinkedList&lt;E&gt; list, int est, int expectedModCount) &#123;
            this.list = list;
            this.est = est;
            this.expectedModCount = expectedModCount;
        &#125;

        final int getEst() &#123;
            int s; // force initialization
            final LinkedList&lt;E&gt; lst;
            if ((s = est) &lt; 0) &#123;
                if ((lst = list) == null)
                    s = est = 0;
                else &#123;
                    expectedModCount = lst.modCount;
                    current = lst.first;
                    s = est = lst.size;
                &#125;
            &#125;
            return s;
        &#125;

        public long estimateSize() &#123; return (long) getEst(); &#125;

        public Spliterator&lt;E&gt; trySplit() &#123;
            Node&lt;E&gt; p;
            int s = getEst();
            if (s &gt; 1 &amp;&amp; (p = current) != null) &#123;
                int n = batch + BATCH_UNIT;
                if (n &gt; s)
                    n = s;
                if (n &gt; MAX_BATCH)
                    n = MAX_BATCH;
                Object[] a = new Object[n];
                int j = 0;
                do &#123; a[j++] = p.item; &#125; while ((p = p.next) != null &amp;&amp; j &lt; n);
                current = p;
                batch = j;
                est = s - j;
                return Spliterators.spliterator(a, 0, j, Spliterator.ORDERED);
            &#125;
            return null;
        &#125;

        public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;
            Node&lt;E&gt; p; int n;
            if (action == null) throw new NullPointerException();
            if ((n = getEst()) &gt; 0 &amp;&amp; (p = current) != null) &#123;
                current = null;
                est = 0;
                do &#123;
                    E e = p.item;
                    p = p.next;
                    action.accept(e);
                &#125; while (p != null &amp;&amp; --n &gt; 0);
            &#125;
            if (list.modCount != expectedModCount)
                throw new ConcurrentModificationException();
        &#125;

        public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123;
            Node&lt;E&gt; p;
            if (action == null) throw new NullPointerException();
            if (getEst() &gt; 0 &amp;&amp; (p = current) != null) &#123;
                --est;
                E e = p.item;
                current = p.next;
                action.accept(e);
                if (list.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                return true;
            &#125;
            return false;
        &#125;

        public int characteristics() &#123;
            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
        &#125;
    &#125;

&#125;
</code></pre>
<p>　　最后，再对LinkedList做一个简单的小结：</p>
<p>　　LinkedList是由Node节点首尾相连而成的结构，相比ArrayList而言，在进行插入和删除时不需要进行大量的元素移动，省去了元素复制的开销，也不存在扩容开销，但是每次添加节点都需要创建一个新的Node对象，所以当节点数量很多时，这部分对象将占用很大开销，包括时间成本和空间成本，因此需要根据实际情况进行合理选择。LinkedList因为提供了大量方便的获取元素、插入元素和移除元素的方法，所以可以很方便的进行队列、栈等数据结构的实现。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E5%AE%B9%E5%99%A8/" rel="tag"># java容器</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/15/java%E5%AE%B9%E5%99%A8-9-HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="java容器#9-HashSet源码分析">
      <i class="fa fa-chevron-left"></i> java容器#9-HashSet源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/17/java%E5%AE%B9%E5%99%A8-11-LinkedHashMap%E8%AF%A6%E8%A7%A3/" rel="next" title="java容器#11-LinkedHashMap详解">
      java容器#11-LinkedHashMap详解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LinkedList%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-text">LinkedList整体结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#inkedList%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8%E6%A0%97%E5%AD%90"><span class="nav-text">inkedList基本操作使用栗子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LinkedList%E4%B8%8EArrayList%E7%9A%84%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="nav-text">LinkedList与ArrayList的对比分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LinkedList%E6%95%B4%E4%BD%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">LinkedList整体源码分析</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
