<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="今天要介绍的是基础容器类（为了与并发容器类区分开来而命名的名字）中的另一个成员——PriorityQueue，它的大名叫做优先级队列，想必即使没有用过也该有所耳闻吧，什么？没。。没听过？emmm。。。那就更该认真看看了。 　　通过本篇你将了解到： 　　1、PriorityQueue是什么？ 　　2、PriorityQueue的内部结构是什么？ 　　3、二叉堆、大顶堆、小顶堆分别是什么？有什么特性？">
<meta property="og:type" content="article">
<meta property="og:title" content="java容器#16-PriorityQueue详解">
<meta property="og:url" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="今天要介绍的是基础容器类（为了与并发容器类区分开来而命名的名字）中的另一个成员——PriorityQueue，它的大名叫做优先级队列，想必即使没有用过也该有所耳闻吧，什么？没。。没听过？emmm。。。那就更该认真看看了。 　　通过本篇你将了解到： 　　1、PriorityQueue是什么？ 　　2、PriorityQueue的内部结构是什么？ 　　3、二叉堆、大顶堆、小顶堆分别是什么？有什么特性？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626120326143.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626120350360.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626120414804.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626120430993.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626120453494.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626120521141.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626120542682.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626122606358.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626122620529.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626122646173.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626122759125.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626122826443.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626122850626.png">
<meta property="og:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626122910780.png">
<meta property="article:published_time" content="2020-06-22T15:04:51.000Z">
<meta property="article:modified_time" content="2021-05-19T01:56:48.541Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="java容器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/image-20200626120326143.png">

<link rel="canonical" href="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java容器#16-PriorityQueue详解 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/22/java%E5%AE%B9%E5%99%A8-16-PriorityQueue%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java容器#16-PriorityQueue详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-22 23:04:51" itemprop="dateCreated datePublished" datetime="2020-06-22T23:04:51+08:00">2020-06-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">java容器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>今天要介绍的是基础容器类（为了与并发容器类区分开来而命名的名字）中的另一个成员——PriorityQueue，它的大名叫做优先级队列，想必即使没有用过也该有所耳闻吧，什么？没。。没听过？emmm。。。那就更该认真看看了。</p>
<p>　　通过本篇你将了解到：</p>
<p>　　1、PriorityQueue是什么？</p>
<p>　　2、PriorityQueue的内部结构是什么？</p>
<p>　　3、二叉堆、大顶堆、小顶堆分别是什么？有什么特性？</p>
<p>　　4、小顶堆是如何实现的，如何用数组表示？</p>
<p>　　5、小顶堆的删除、插入操作是如何进行的？</p>
<p>　　6、PriorityQueue的源码解析。</p>
<p>　　7、PriorityQueue的应用场景。</p>
<span id="more"></span>

<h1 id="PriorityQueue简介"><a href="#PriorityQueue简介" class="headerlink" title="PriorityQueue简介"></a>PriorityQueue简介</h1><p>　　PriorityQueue也是Queue的一个继承者，相比于一般的列表，它的特点便如它的名字一样，出队的时候可以按照优先级进行出队，所以不像LinkedList那样只能按照插入的顺序出队，PriorityQueue是可以根据给定的优先级顺序进行出队的。这里说的给定优先级顺序既可以是内部比较器，也可以是外部比较器。PriorityQueue内部是根据小顶堆的结构进行存储的，所谓小顶堆的意思，便是最小的元素总是在最上面，每次出队总是将堆顶元素移除，这样便能让出队变得有序，至于什么是小顶堆，后面会有详细介绍。</p>
<p>　　比如说，比较常见的场景就是任务队列，队列动态插入，后面的任务优先级高的需要被先执行，那么使用优先级队列就可以比较好的实现这样的需求。下面我们模拟一下这个场景：</p>
<pre><code class="java">public class PriorityQueueTest &#123;
    public static void main(String[] args)&#123;
        // 传入外部比较器，
        //PriorityQueue&lt;Task&gt; taskQueue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(Task::getPriority));
        //PriorityQueue&lt;Task&gt; taskQueue = new PriorityQueue&lt;&gt;((t1, t2) -&gt; t1.getPriority() - t2.getPriority());
        PriorityQueue&lt;Task&gt; taskQueue = new PriorityQueue&lt;&gt;(new Comparator&lt;Task&gt;() &#123;
            @Override
            public int compare(Task t1, Task t2) &#123;
                return t1.getPriority() - t2.getPriority();
            &#125;
        &#125;);

        // 添加六个任务
        taskQueue.add(new Task(1, &quot;learn java&quot;));
        taskQueue.add(new Task(3, &quot;learn c++&quot;));
        taskQueue.add(new Task(4, &quot;learn c#&quot;));
        taskQueue.add(new Task(2, &quot;learn python&quot;));
        taskQueue.add(new Task(2, &quot;learn php&quot;));
        taskQueue.add(new Task(5, &quot;learn js&quot;));

        // 出队
        while (!taskQueue.isEmpty())&#123;
            System.out.println(taskQueue.poll());
        &#125;
    &#125;
&#125;

class Task&#123;
    /**
     * 任务优先级
     */
    private int priority;
    /**
     * 任务名称
     */
    private String taskName;

    public Task() &#123;
    &#125;

    public Task(int priority, String taskName) &#123;
        this.priority = priority;
        this.taskName = taskName;
    &#125;

    public int getPriority() &#123;
        return priority;
    &#125;

    public void setPriority(int priority) &#123;
        this.priority = priority;
    &#125;

    public String getTaskName() &#123;
        return taskName;
    &#125;

    public void setTaskName(String taskName) &#123;
        this.taskName = taskName;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Task&#123;&quot; +
                &quot;priority=&quot; + priority +
                &quot;, taskName=&#39;&quot; + taskName + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>　　输出如下：</p>
<pre><code class="java">Task&#123;priority=1, taskName=&#39;learn java&#39;&#125;
Task&#123;priority=2, taskName=&#39;learn python&#39;&#125;
Task&#123;priority=2, taskName=&#39;learn php&#39;&#125;
Task&#123;priority=3, taskName=&#39;learn c++&#39;&#125;
Task&#123;priority=4, taskName=&#39;learn c#&#39;&#125;
Task&#123;priority=5, taskName=&#39;learn js&#39;&#125;
</code></pre>
<p>　　可以看到，输出的时候是按照我们设定的优先级顺序进行输出的，由于默认的是小顶堆，所以这里Priority值小的会被先输出。</p>
<h1 id="PriorityQueue的内部结构"><a href="#PriorityQueue的内部结构" class="headerlink" title="PriorityQueue的内部结构"></a>PriorityQueue的内部结构</h1><p>　　上面已经提到了，PriorityQueue的内部结构其实是按照小顶堆的结构进行存储的，那么什么是小顶堆呢？说到小顶堆，还是先从堆开始介绍吧。</p>
<p>　　堆和栈一样是一种很基础的数据结构，在维基百科中的介绍如下：</p>
<blockquote>
<p><strong>堆</strong>（英语：Heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>
</blockquote>
<p>　　用图来表示的话就像这样：<img src="image-20200626120326143.png" alt="image-20200626120326143"></p>
<p>　　说完了堆，再来聊聊它的进化版——二叉堆，同样引用维基百科中的介绍：</p>
<blockquote>
<p>二叉堆（英语：binary heap）是一种特殊的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">堆</a>，二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足堆特性：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。</p>
<p>当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。</p>
</blockquote>
<p>　　其中，最大堆也叫做大顶堆或者大根堆，最小堆也叫做小顶堆或者小根堆。上面的图一其实就是一个大顶堆，而图二则是小顶堆。PriorityQueue是通过数组表示的小顶堆实现的，既然如此，PriorityQueue的排序特性自然与小顶堆的特性一致，下面便介绍小顶堆如何使用数组进行表示以及插入删除时的调整。</p>
<p>　　下面是一个由10，16，20，22，18，25，26，30，24，23构成的小顶堆：</p>
<p><img src="image-20200626120350360.png" alt="image-20200626120350360">　　</p>
<p>将其从第一个元素开始依次从上到下，从左到右给每个元素添加一个序号，从0开始，这样就得到了相应元素在数组中的位置，而且这个序号是很有规则的，第k个元素的左孩子的序号为2k+1，右孩子的序号为2k+2，这样就很容易根据序号直接算出对应孩子的位置，时间复杂度为o(1)。这也就是为什么可以用数组来存储堆结构的原因了。</p>
<p>　　再来看看小顶堆是如何插入元素的，假设我们插入一个元素15：</p>
<p><img src="image-20200626120414804.png" alt="image-20200626120414804"></p>
<p><img src="image-20200626120430993.png" alt="image-20200626120430993"></p>
<p><img src="image-20200626120453494.png" alt="image-20200626120453494"></p>
<p>　　插入元素的调整其实很简单，就是先插入到最后，然后再依次与其父节点进行比较，如果小于其父节点，则互换，直到不需要调整或者父节点为null为止。</p>
<p>　　那再来看看移除元素：</p>
<p><img src="image-20200626120521141.png" alt="image-20200626120521141"></p>
<p><img src="image-20200626120542682.png" alt="image-20200626120542682"></p>
<p><img src="image-20200626122606358.png" alt="image-20200626122606358"></p>
<p><img src="image-20200626122620529.png" alt="image-20200626122620529"></p>
<p>　　嗯，过程其实也很简单，先用最后的元素当替补，然后再从上往下进行调整。</p>
<h1 id="PriorityQueue源码解析"><a href="#PriorityQueue源码解析" class="headerlink" title="PriorityQueue源码解析"></a>PriorityQueue源码解析</h1><p>　　小顶堆已经介绍完了，那PriorityQueue就没什么内容可讲了，嗯，那散了吧好了好了，不开玩笑了，接下来让我们一起来看看源码中是如何实现的。</p>
<p>　　先来继承结构：</p>
<p><img src="image-20200626122646173.png" alt="image-20200626122646173"></p>
<p>　　PriorityQueue继承自AbstractQueue，像这样的Abstract开头的抽象类，想必应该不陌生了，就是继承自指定接口然后进行了一些默认实现。</p>
<p>　　来看看PriorityQueue的内部成员：</p>
<pre><code class="java">    // 默认初始化容量
    private static final int DEFAULT_INITIAL_CAPACITY = 11;

    /**
     * 优先级队列是使用平衡二叉堆表示的: 节点queue[n]的两个孩子分别为
     * queue[2*n+1] 和 queue[2*(n+1)].  队列的优先级是由比较器或者
     * 元素的自然排序决定的， 对于堆中的任意元素n，其后代d满足：n&lt;=d
     * 如果堆是非空的，则堆中最小值为queue[0]。
     */
    transient Object[] queue; 

    /**
     * 队列中元素个数
     */
    private int size = 0;

    /**
     * 比较器
     */
    private final Comparator&lt;? super E&gt; comparator;

    /**
     * 修改次数
     */
    transient int modCount = 0; 
</code></pre>
<p>　　可以看到内部使用的是一个Object数组进行元素的存储，并对该数组进行了详细的注释，所以不管是根据子节点找父节点，还是根据父节点找子节点都肥肠的方便。</p>
<p>　　再来看看它的构造函数，有点多，一共有六个构造函数：</p>
<pre><code class="java">    /**
     * 使用默认的容量（11）来构造一个空的优先级队列，使用元素的自然顺序进行排序（此时元素必须实现comparable接口）
     */
    public PriorityQueue() &#123;
        this(DEFAULT_INITIAL_CAPACITY, null);
    &#125;

    /**
     * 使用指定容量来构造一个空的优先级队列，使用元素的自然顺序进行排序（此时元素必须实现comparable接口）
     * 但如果指定的容量小于1则会抛出异常
     */
    public PriorityQueue(int initialCapacity) &#123;
        this(initialCapacity, null);
    &#125;

    /**
     * 使用默认的容量（11）构造一个优先级队列，使用指定的比较器进行排序
     */
    public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123;
        this(DEFAULT_INITIAL_CAPACITY, comparator);
    &#125;

    /**
     * 使用指定容量创建一个优先级队列，并使用指定比较器进行排序。
     * 但如果指定的容量小于1则会抛出异常
     */
    public PriorityQueue(int initialCapacity,
                         Comparator&lt;? super E&gt; comparator) &#123;
        if (initialCapacity &lt; 1)
            throw new IllegalArgumentException();
        this.queue = new Object[initialCapacity];
        this.comparator = comparator;
    &#125;

    /**
     * 使用指定集合的所有元素构造一个优先级队列，
     * 如果该集合为SortedSet或者PriorityQueue类型，则会使用相同的顺序进行排序，
     * 否则，将使用元素的自然排序（此时元素必须实现comparable接口），否则会抛出异常
     * 并且集合中不能有null元素，否则会抛出异常
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public PriorityQueue(Collection&lt;? extends E&gt; c) &#123;
        if (c instanceof SortedSet&lt;?&gt;) &#123;
            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;
            this.comparator = (Comparator&lt;? super E&gt;) ss.comparator();
            initElementsFromCollection(ss);
        &#125;
        else if (c instanceof PriorityQueue&lt;?&gt;) &#123;
            PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;
            this.comparator = (Comparator&lt;? super E&gt;) pq.comparator();
            initFromPriorityQueue(pq);
        &#125;
        else &#123;
            this.comparator = null;
            initFromCollection(c);
        &#125;
    &#125;

    /**
     * 使用指定的优先级队列中所有元素来构造一个新的优先级队列.  将使用原有顺序进行排序。
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public PriorityQueue(PriorityQueue&lt;? extends E&gt; c) &#123;
        this.comparator = (Comparator&lt;? super E&gt;) c.comparator();
        initFromPriorityQueue(c);
    &#125;

    /**
     * 根据指定的有序集合创建一个优先级队列，将使用原有顺序进行排序
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public PriorityQueue(SortedSet&lt;? extends E&gt; c) &#123;
        this.comparator = (Comparator&lt;? super E&gt;) c.comparator();
        initElementsFromCollection(c);
    &#125;
</code></pre>
<p>　　从集合中构造优先级队列的时候，调用了几个初始化函数：</p>
<pre><code class="java">    private void initFromPriorityQueue(PriorityQueue&lt;? extends E&gt; c) &#123;
        if (c.getClass() == PriorityQueue.class) &#123;
            this.queue = c.toArray();
            this.size = c.size();
        &#125; else &#123;
            initFromCollection(c);
        &#125;
    &#125;

    private void initElementsFromCollection(Collection&lt;? extends E&gt; c) &#123;
        Object[] a = c.toArray();
        // If c.toArray incorrectly doesn&#39;t return Object[], copy it.
        if (a.getClass() != Object[].class)
            a = Arrays.copyOf(a, a.length, Object[].class);
        int len = a.length;
        if (len == 1 || this.comparator != null)
            for (int i = 0; i &lt; len; i++)
                if (a[i] == null)
                    throw new NullPointerException();
        this.queue = a;
        this.size = a.length;
    &#125;

    private void initFromCollection(Collection&lt;? extends E&gt; c) &#123;
        initElementsFromCollection(c);
        heapify();
    &#125;
</code></pre>
<p>　　initFromPriorityQueue即从另外一个优先级队列构造一个新的优先级队列，此时内部的数组元素不需要进行调整，只需要将原数组元素都复制过来即可。但是从其他非PriorityQueue的集合中构造优先级队列时，需要先将元素复制过来后再进行调整，此时调用的是heapify方法：</p>
<pre><code class="java">    private void heapify() &#123;
        // 从最后一个非叶子节点开始从下往上调整
        for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)
            siftDown(i, (E) queue[i]);
    &#125;

    // 划重点了，这个函数即对应上面的元素删除时从上往下调整的步骤
    private void siftDown(int k, E x) &#123;
        if (comparator != null)
            // 如果比较器不为null，则使用比较器进行比较
            siftDownUsingComparator(k, x);
        else
            // 否则使用元素的compareTo方法进行比较
            siftDownComparable(k, x);
    &#125;

    private void siftDownUsingComparator(int k, E x) &#123;
        // 使用half记录队列size的一半，如果比half小的话，说明不是叶子节点
        // 因为最后一个节点的序号为size - 1，其父节点的序号为(size - 2) / 2或者(size - 3 ) / 2
        // 所以half所在位置刚好是第一个叶子节点
        int half = size &gt;&gt;&gt; 1;
        while (k &lt; half) &#123;
            // 如果不是叶子节点，找出其孩子中较小的那个并用其替换
            int child = (k &lt;&lt; 1) + 1;
            Object c = queue[child];
            int right = child + 1;
            if (right &lt; size &amp;&amp;
                comparator.compare((E) c, (E) queue[right]) &gt; 0)
                c = queue[child = right];
            if (comparator.compare(x, (E) c) &lt;= 0)
                break;
            // 用c替换
            queue[k] = c;
            k = child;
        &#125;
        // 
        queue[k] = x;
    &#125;
    // 同上，只是比较的时候使用的是元素的compareTo方法
    private void siftDownComparable(int k, E x) &#123;
        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x;
        int half = size &gt;&gt;&gt; 1;        // 如果是非叶子节点则继续循环
        while (k &lt; half) &#123;
            int child = (k &lt;&lt; 1) + 1;
            Object c = queue[child];
            int right = child + 1;
            if (right &lt; size &amp;&amp;
                ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0)
                c = queue[child = right];
            if (key.compareTo((E) c) &lt;= 0)
                break;
            queue[k] = c;
            k = child;
        &#125;
        queue[k] = key;
    &#125;
</code></pre>
<p>　　这里可能一眼看过去有点难以理解，嗯，那就多看两眼吧。</p>
<p>　　siftDown方法是这里面比较重要的方法之一，有两个参数，一个是序号k，另一个是元素x，这个方法的作用，便是把x从k开始往下调整，使得在节点k在其子树的每相邻层中，父节点都小于其子节点。所以heapify的作用就比较明显了，从最后一个非叶子节点开始，从下往上依次调整其子树，使得最终得到的树里，根节点是最小的。这里要先理解一下为什么heapify中i的初始值要设置为(size &gt;&gt;&gt; 1) - 1。因为这是最后一个非叶子节点的位置，不信的话可以随便画几个图验证一下，至于在siftDownUsingComparator方法中，int half = size &gt;&gt;&gt; 1;这里half则是第一个叶子节点的位置，小于这个序号的节点都是非叶子节点，这里也可以画图验证，当然，注释中我已经做了解释。</p>
<p>　　说了这么多，也许还是不太明白，以集合{14,7,12,6,9,4,17,23,10,15,3}为例画个图吧：</p>
<p><img src="image-20200626122759125.png" alt="image-20200626122759125"></p>
<p><img src="image-20200626122826443.png" alt="image-20200626122826443"></p>
<p><img src="image-20200626122850626.png" alt="image-20200626122850626"></p>
<p><img src="image-20200626122910780.png" alt="image-20200626122910780"></p>
<p>　　嗯，这样最小的元素就被顶上去了，有没有觉得有点像冒泡排序，嗯，确实有点像。</p>
<p>iftDown说完了，再来看一眼siftUp吧，这里操作是十分类似的。</p>
<pre><code class="java">    private void siftUp(int k, E x) &#123;
        if (comparator != null)
            siftUpUsingComparator(k, x);
        else
            siftUpComparable(k, x);
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    private void siftUpComparable(int k, E x) &#123;
        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;
        while (k &gt; 0) &#123;
            int parent = (k - 1) &gt;&gt;&gt; 1;
            Object e = queue[parent];
            if (key.compareTo((E) e) &gt;= 0)
                break;
            queue[k] = e;
            k = parent;
        &#125;
        queue[k] = key;
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    private void siftUpUsingComparator(int k, E x) &#123;
        while (k &gt; 0) &#123;
            int parent = (k - 1) &gt;&gt;&gt; 1;
            Object e = queue[parent];
            if (comparator.compare(x, (E) e) &gt;= 0)
                break;
            queue[k] = e;
            k = parent;
        &#125;
        queue[k] = x;
    &#125;
</code></pre>
<p>　　嗯，相信如果理解了siftDown的话，这里应该就不难理解了吧.</p>
<p>　　再来看看几个常用的方法：</p>
<pre><code class="java">    public boolean add(E e) &#123;
        return offer(e);
    &#125;

    public boolean offer(E e) &#123;
        if (e == null)
            throw new NullPointerException();
        modCount++;
        int i = size;
        if (i &gt;= queue.length)
            grow(i + 1);
        size = i + 1;
        if (i == 0)
            queue[0] = e;
        else
            siftUp(i, e);
        return true;
    &#125;
    // 扩容函数
    private void grow(int minCapacity) &#123;
        int oldCapacity = queue.length;
        // 如果当前容量比较小（小于64）的话进行双倍扩容，否则扩容50%
        int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?
                                         (oldCapacity + 2) :
                                         (oldCapacity &gt;&gt; 1));
        // 如果发现扩容后溢出了，则进行调整
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        queue = Arrays.copyOf(queue, newCapacity);
    &#125;
    private static int hugeCapacity(int minCapacity) &#123;
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    &#125;

    public boolean contains(Object o) &#123;
        return indexOf(o) != -1;
    &#125;

    private int indexOf(Object o) &#123;
        if (o != null) &#123;
            // 查找时需要进行全局遍历，比搜索二叉树的查找效率要低
            for (int i = 0; i &lt; size; i++)
                if (o.equals(queue[i]))
                    return i;
        &#125;
        return -1;
    &#125;

    public E poll() &#123;
        if (size == 0)
            return null;
        int s = --size;
        modCount++;
        E result = (E) queue[0];
        E x = (E) queue[s];
        queue[s] = null;
        if (s != 0)
            siftDown(0, x);
        return result;
    &#125;
</code></pre>
<p>　　这里对照一下最开始说的小顶堆的插入和移除就能比较好的理解了。</p>
<p>　　最后源码中还有一个remove方法，需要稍微说明一下：</p>
<pre><code class="java">    // 这里不是移除堆顶元素，而是移除指定元素
    public boolean remove(Object o) &#123;
        // 先找到该元素的位置
        int i = indexOf(o);
        if (i == -1)
            return false;
        else &#123;
            removeAt(i);
            return true;
        &#125;
    &#125;
    // 移除指定序号的元素
    private E removeAt(int i) &#123;
        // assert i &gt;= 0 &amp;&amp; i &lt; size;
        modCount++;
        // s为最后一个元素的序号
        int s = --size;
        if (s == i) 
            queue[i] = null;
        else &#123;
            // moved记录最后一个元素的值
            E moved = (E) queue[s];
            queue[s] = null;
            // 用最后一个元素代替要移除的元素，并向下进行调整
            siftDown(i, moved);
            // 如果向下调整后发现moved还在该位置，则再向上进行调整
            if (queue[i] == moved) &#123;
                siftUp(i, moved);
                if (queue[i] != moved)
                    return moved;
            &#125;
        &#125;
        return null;
    &#125;
</code></pre>
<p>　　当移除的不是堆顶元素的时候，同样先用最后一个元素代替，然后先从被移除的位置开始向下调整，如果发现没有改动，则再向上调整。</p>
<h1 id="PriorityQueue的应用场景"><a href="#PriorityQueue的应用场景" class="headerlink" title="PriorityQueue的应用场景"></a>PriorityQueue的应用场景</h1><p>　　最后，来聊聊PriorityQueue的应用场景，由于内部是用数组实现的小顶堆，所以堆适用的场景它都适用，比如典型的从n个元素中取出最小（最大）的前k个，这样的场景适用PriorityQueue就能以比较小的空间代价和还算ok的时间代价进行实现，另外，优先级队列适用场景的特点便是需要动态插入元素，并且元素有优先级，需要根据一定的规则进行优先级排序。</p>
<p>　　下面以从10000个整数中取出最大的10个整数为例进行介绍。</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args)&#123;
        ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(10000);
        Random random = new Random();
        for (int i = 0; i &lt; 10000; i++) &#123;
            Integer integer = random.nextInt();
            if (!integers.contains(integer))
                integers.add(integer);
        &#125;
        Integer[] largest = getLargest10(integers);
        for (Integer i : largest)&#123;
            System.out.print(i + &quot; &quot;);
        &#125;

        System.out.println();
        
        // 验证一下是否是最大的前10个
        integers.sort(Comparator.comparingInt(Integer::intValue));
        ArrayList&lt;Integer&gt; largest2 = new ArrayList&lt;&gt;(10);
        for (int i = integers.size() - 1; i &gt;= integers.size() - 10; i--)&#123;
            largest2.add(integers.get(i));
        &#125;

        // 在largest数组中查找
        System.out.println(Arrays.asList(largest).containsAll(largest2)); 
    &#125;

    public static Integer[] getLargest10(ArrayList&lt;Integer&gt; integers)&#123;
        PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(10);
        for (Integer integer : integers)&#123;
            queue.add(integer);
            if (queue.size() &gt; 10)&#123;
                queue.poll();
            &#125;
        &#125;
        return queue.toArray(new Integer[10]);
    &#125;
&#125;
</code></pre>
<p>　　输出如下，由于是取的随机数，所以每个人的输出都会不一样。</p>
<pre><code>2143974860 2143998490 2144350843 2145111627 2144739333 2145674658 2144667271 2145543903 2147209906 2145466260 
true
</code></pre>
<p>　　最后，我们来回答一下开头的问题：</p>
<p>　　1、PriorityQueue是什么？PriorityQueue是优先级队列，取出元素时会根据元素的优先级进行排序。</p>
<p>　　2、PriorityQueue的内部结构是什么？PriorityQueue内部是一个用数组实现的小顶堆。</p>
<p>　　3、二叉堆、大顶堆、小顶堆分别是什么？有什么特性？二叉堆是完全二叉树或者近完全二叉树，大顶堆即所有父节点大于子节点，小顶堆即所有父节点小于子节点。</p>
<p>　　4、小顶堆是如何实现的，如何用数组表示？小顶堆是用二叉树实现的，用数组表示时，父节点n的左孩子为2n+1，右孩子的序号为2n+2。</p>
<p>　　5、小顶堆的删除、插入操作是如何进行的？小顶堆删除堆顶元素后用最后一个元素替补，然后从上往下调整，插入一个元素时，先放到最后的位置，然后再从下往上调整。</p>
<p>　　6、PriorityQueue的源码解析。如上。</p>
<p>　　7、PriorityQueue的应用场景。适用于需要动态插入元素，且元素有优先级顺序的场景。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java%E5%AE%B9%E5%99%A8/" rel="tag"># java容器</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/21/java%E5%AE%B9%E5%99%A8-15-ArrayDeque%E8%AF%A6%E8%A7%A3/" rel="prev" title="java容器#15-ArrayDeque详解">
      <i class="fa fa-chevron-left"></i> java容器#15-ArrayDeque详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="next" title="排序算法的实现">
      排序算法的实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#PriorityQueue%E7%AE%80%E4%BB%8B"><span class="nav-text">PriorityQueue简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PriorityQueue%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-text">PriorityQueue的内部结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PriorityQueue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-text">PriorityQueue源码解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PriorityQueue%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">PriorityQueue的应用场景</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
