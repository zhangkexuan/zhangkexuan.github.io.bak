<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="消息队列是解决数据同步的重要方式：  了解常见的MQ产品 了解RabbitMQ的5种消息模型 会使用Spring AMQP 利用MQ实现搜索和静态页的数据同步">
<meta property="og:type" content="article">
<meta property="og:title" content="leyou门户#4-rabbitMQ数据同步">
<meta property="og:url" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="消息队列是解决数据同步的重要方式：  了解常见的MQ产品 了解RabbitMQ的5种消息模型 会使用Spring AMQP 利用MQ实现搜索和静态页的数据同步">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527063872737.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527064480681.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527064487042.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527064606029.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532758972119.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527064762982.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532759070767.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532761948333.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532761916357.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527068544487.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532762038694.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532762308507.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532762961149.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532762975546.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532763328424.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532763817830.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532763489858.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532763733443.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532763773208.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532764253019.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532764600849.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532764694290.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532764717995.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532764734232.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532764831241.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532764895239.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532764957092.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532765013834.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532765038088.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532765123282.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532765151039.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532765197277.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527085386747.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527085448377.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527085826462.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532765689904.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527086159534.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527086284940.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527086564505.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532766264386.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532766291204.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532766437787.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527088296131.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532766712166.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532766951432.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532766981230.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532767057491.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532767136007.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532767171063.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532767227821.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527090258083.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532767726274.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532768930797.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532769005960.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532769181819.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532769581964.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532772446520.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532772471931.png">
<meta property="og:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1532772521932.png">
<meta property="article:published_time" content="2020-06-02T09:13:38.000Z">
<meta property="article:modified_time" content="2021-05-19T02:11:46.963Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="rabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/1527063872737.png">

<link rel="canonical" href="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leyou门户#4-rabbitMQ数据同步 | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/leyou%E9%97%A8%E6%88%B7-4-rabbitMQ%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leyou门户#4-rabbitMQ数据同步
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-02 17:13:38" itemprop="dateCreated datePublished" datetime="2020-06-02T17:13:38+08:00">2020-06-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leyou/" itemprop="url" rel="index"><span itemprop="name">leyou</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>消息队列是解决数据同步的重要方式：</p>
<ul>
<li>了解常见的MQ产品</li>
<li>了解RabbitMQ的5种消息模型</li>
<li>会使用Spring AMQP</li>
<li>利用MQ实现搜索和静态页的数据同步</li>
</ul>
<span id="more"></span>

<h1 id="1-RabbitMQ"><a href="#1-RabbitMQ" class="headerlink" title="1.RabbitMQ"></a>1.RabbitMQ</h1><h2 id="1-1-搜索与商品服务的问题"><a href="#1-1-搜索与商品服务的问题" class="headerlink" title="1.1.搜索与商品服务的问题"></a>1.1.搜索与商品服务的问题</h2><p>目前我们已经完成了商品详情和搜索系统的开发。我们思考一下，是否存在问题？</p>
<ul>
<li>商品的原始数据保存在数据库中，增删改查都在数据库中完成。</li>
<li>搜索服务数据来源是索引库，如果数据库商品发生变化，索引库数据不能及时更新。</li>
<li>商品详情做了页面静态化，静态页面数据也不会随着数据库商品发生变化。</li>
</ul>
<p>如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？</p>
<p>这里有两种解决方案：</p>
<ul>
<li>方案1：每当后台对商品做增删改操作，同时要修改索引库数据及静态页面</li>
<li>方案2：搜索服务和商品页面服务对外提供操作接口，后台在商品增删改后，调用接口</li>
</ul>
<p>以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的<code>独立</code>原则。</p>
<p>所以，我们会通过另外一种方式来解决这个问题：消息队列</p>
<h2 id="1-2-消息队列（MQ）"><a href="#1-2-消息队列（MQ）" class="headerlink" title="1.2.消息队列（MQ）"></a>1.2.消息队列（MQ）</h2><h3 id="1-2-1-什么是消息队列"><a href="#1-2-1-什么是消息队列" class="headerlink" title="1.2.1.什么是消息队列"></a>1.2.1.什么是消息队列</h3><p>消息队列，即MQ，Message Queue。</p>
<p><img src="1527063872737.png" alt="1527063872737"></p>
<p>消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。</p>
<p>结合前面所说的问题：</p>
<ul>
<li>商品服务对商品增删改以后，无需去操作索引库或静态页面，只是发送一条消息，也不关心消息被谁接收。</li>
<li>搜索服务和静态页面服务接收消息，分别去处理索引库和静态页面。</li>
</ul>
<p>如果以后有其它系统也依赖商品服务的数据，同样监听消息即可，商品服务无需任何代码修改。</p>
<h3 id="1-2-2-AMQP和JMS"><a href="#1-2-2-AMQP和JMS" class="headerlink" title="1.2.2.AMQP和JMS"></a>1.2.2.AMQP和JMS</h3><p>MQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。</p>
<p><img src="1527064480681.png" alt="1527064480681"></p>
<p><img src="1527064487042.png" alt="1527064487042"></p>
<p>两者间的区别和联系：</p>
<ul>
<li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li>
<li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li>
<li>JMS规定了两种消息模型；而AMQP的消息模型更加丰富</li>
</ul>
<h3 id="1-2-3-常见MQ产品"><a href="#1-2-3-常见MQ产品" class="headerlink" title="1.2.3.常见MQ产品"></a>1.2.3.常见MQ产品</h3><p><img src="1527064606029.png" alt="1527064606029"></p>
<ul>
<li>ActiveMQ：基于JMS</li>
<li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li>
<li>RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会</li>
<li>Kafka：分布式消息系统，高吞吐量</li>
</ul>
<h3 id="1-2-4-RabbitMQ"><a href="#1-2-4-RabbitMQ" class="headerlink" title="1.2.4.RabbitMQ"></a>1.2.4.RabbitMQ</h3><p>RabbitMQ是基于AMQP的一款消息管理系统</p>
<p>官网： <a target="_blank" rel="noopener" href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a></p>
<p>官方教程：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/getstarted.html">http://www.rabbitmq.com/getstarted.html</a></p>
<p><img src="1532758972119.png" alt="1532758972119"></p>
<p> <img src="1527064762982.png" alt="1527064762982"></p>
<h2 id="1-3-下载和安装"><a href="#1-3-下载和安装" class="headerlink" title="1.3.下载和安装"></a>1.3.下载和安装</h2><h3 id="1-3-1-下载"><a href="#1-3-1-下载" class="headerlink" title="1.3.1.下载"></a>1.3.1.下载</h3><p>官网下载地址：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a></p>
<p><img src="1532759070767.png" alt="1532759070767"></p>
<p>目前最新版本是：3.7.5</p>
<p>我们的课程中使用的是：3.4.1版本</p>
<p>课前资料提供了安装包：</p>
<p><img src="1532761948333.png" alt="1532761948333"></p>
<h3 id="1-3-2-安装"><a href="#1-3-2-安装" class="headerlink" title="1.3.2.安装"></a>1.3.2.安装</h3><p>详见课前资料中的：</p>
<p><img src="1532761916357.png" alt="1532761916357"></p>
<h1 id="2-五种消息模型"><a href="#2-五种消息模型" class="headerlink" title="2.五种消息模型"></a>2.五种消息模型</h1><p>RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。</p>
<p>但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。</p>
<p><img src="1527068544487.png" alt="1527068544487"></p>
<p>我们通过一个demo工程来了解下RabbitMQ的工作方式：</p>
<p>导入工程：</p>
<p><img src="1532762038694.png" alt="1532762038694"></p>
<p>导入后：</p>
<p> <img src="1532762308507.png" alt="1532762308507"></p>
<p>依赖：</p>
<pre><code class="xml">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;cn.itcast.rabbitmq&lt;/groupId&gt;
    &lt;artifactId&gt;itcast-rabbitmq&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;
    &lt;/parent&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
            &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接：</p>
<pre><code class="java">public class ConnectionUtil &#123;
    /**
     * 建立与RabbitMQ的连接
     * @return
     * @throws Exception
     */
    public static Connection getConnection() throws Exception &#123;
        //定义连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        //设置服务地址
        factory.setHost(&quot;192.168.56.101&quot;);
        //端口
        factory.setPort(5672);
        //设置账号信息，用户名、密码、vhost
        factory.setVirtualHost(&quot;/leyou&quot;);
        factory.setUsername(&quot;leyou&quot;);
        factory.setPassword(&quot;leyou&quot;);
        // 通过工程获取连接
        Connection connection = factory.newConnection();
        return connection;
    &#125;
&#125;
</code></pre>
<h2 id="2-1-基本消息模型"><a href="#2-1-基本消息模型" class="headerlink" title="2.1.基本消息模型"></a>2.1.基本消息模型</h2><p>官方介绍：</p>
<p> <img src="1532762961149.png" alt="1532762961149"></p>
<p>RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。</p>
<p>RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。</p>
<p> <img src="1532762975546.png" alt="1532762975546"></p>
<p>P（producer/ publisher）：生产者，一个发送消息的用户应用程序。</p>
<p>C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序</p>
<p>队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。</p>
<p>总之：</p>
<p>生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。</p>
<p>我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。</p>
<p>我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。</p>
<h3 id="2-1-1-生产者发送消息"><a href="#2-1-1-生产者发送消息" class="headerlink" title="2.1.1.生产者发送消息"></a>2.1.1.生产者发送消息</h3><pre><code class="java">public class Send &#123;

    private final static String QUEUE_NAME = &quot;simple_queue&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接以及mq通道
        Connection connection = ConnectionUtil.getConnection();
        // 从连接中创建通道，这是完成大部分API的地方。
        Channel channel = connection.createChannel();

        // 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。
        // 声明一个队列是幂等的 - 只有当它不存在时才会被创建
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 消息内容
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
        System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);

        //关闭通道和连接
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<p>控制台：</p>
<p><img src="1532763328424.png" alt="1532763328424"></p>
<h3 id="2-1-2-管理工具中查看消息"><a href="#2-1-2-管理工具中查看消息" class="headerlink" title="2.1.2.管理工具中查看消息"></a>2.1.2.管理工具中查看消息</h3><p>进入队列页面，可以看到新建了一个队列：simple_queue</p>
<p><img src="1532763817830.png" alt="1532763817830"></p>
<p>点击队列名称，进入详情页，可以查看消息：</p>
<p><img src="1532763489858.png" alt="1532763489858"></p>
<p>在控制台查看消息并不会将消息消费，所以消息还在。</p>
<h3 id="2-1-3-消费者获取消息"><a href="#2-1-3-消费者获取消息" class="headerlink" title="2.1.3.消费者获取消息"></a>2.1.3.消费者获取消息</h3><pre><code class="java">public class Recv &#123;
    private final static String QUEUE_NAME = &quot;simple_queue&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 创建通道
        Channel channel = connection.createChannel();
        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        // 定义队列的消费者
        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;
            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                    byte[] body) throws IOException &#123;
                // body 即消息体
                String msg = new String(body);
                System.out.println(&quot; [x] received : &quot; + msg + &quot;!&quot;);
            &#125;
        &#125;;
        // 监听队列，第二个参数：是否自动进行消息确认。
        channel.basicConsume(QUEUE_NAME, true, consumer);
    &#125;
&#125;
</code></pre>
<p>控制台：</p>
<p><img src="1532763733443.png" alt="1532763733443"></p>
<p>这个时候，队列中的消息就没了：</p>
<p><img src="1532763773208.png" alt="1532763773208"></p>
<p>我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印.</p>
<h3 id="2-1-4-消息确认机制（ACK）"><a href="#2-1-4-消息确认机制（ACK）" class="headerlink" title="2.1.4.消息确认机制（ACK）"></a>2.1.4.消息确认机制（ACK）</h3><p>通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。</p>
<p>那么问题来了：RabbitMQ怎么知道消息被接收了呢？</p>
<p>如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！</p>
<p>因此，RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：</p>
<ul>
<li>自动ACK：消息一旦被接收，消费者自动发送ACK</li>
<li>手动ACK：消息接收后，不会发送ACK，需要手动调用</li>
</ul>
<p>大家觉得哪种更好呢？</p>
<p>这需要看消息的重要性：</p>
<ul>
<li>如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便</li>
<li>如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。</li>
</ul>
<p>我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码：</p>
<pre><code class="java">public class Recv2 &#123;
    private final static String QUEUE_NAME = &quot;simple_queue&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 创建通道
        final Channel channel = connection.createChannel();
        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        // 定义队列的消费者
        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;
            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                    byte[] body) throws IOException &#123;
                // body 即消息体
                String msg = new String(body);
                System.out.println(&quot; [x] received : &quot; + msg + &quot;!&quot;);
                // 手动进行ACK
                channel.basicAck(envelope.getDeliveryTag(), false);
            &#125;
        &#125;;
        // 监听队列，第二个参数false，手动进行ACK
        channel.basicConsume(QUEUE_NAME, false, consumer);
    &#125;
&#125;
</code></pre>
<p>注意到最后一行代码：</p>
<pre><code class="java">channel.basicConsume(QUEUE_NAME, false, consumer);
</code></pre>
<p>如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明：</p>
<p><img src="1532764253019.png" alt="1532764253019"></p>
<h4 id="2-1-4-1-自动ACK存在的问题"><a href="#2-1-4-1-自动ACK存在的问题" class="headerlink" title="2.1.4.1.自动ACK存在的问题"></a>2.1.4.1.自动ACK存在的问题</h4><p>修改消费者，添加异常，如下：</p>
<p><img src="1532764600849.png" alt="1532764600849"></p>
<p>生产者不做任何修改，直接运行，消息发送成功：</p>
<p><img src="1532764694290.png" alt="1532764694290"></p>
<p>运行消费者，程序抛出异常。但是消息依然被消费：</p>
<p><img src="1532764717995.png" alt="1532764717995"></p>
<p>管理界面：</p>
<p><img src="1532764734232.png" alt="1532764734232"></p>
<h4 id="2-1-4-2-演示手动ACK"><a href="#2-1-4-2-演示手动ACK" class="headerlink" title="2.1.4.2.演示手动ACK"></a>2.1.4.2.演示手动ACK</h4><p>修改消费者，把自动改成手动（去掉之前制造的异常）</p>
<p><img src="1532764831241.png" alt="1532764831241"></p>
<p>生产者不变，再次运行：</p>
<p><img src="1532764895239.png" alt="1532764895239"></p>
<p>运行消费者</p>
<p><img src="1532764957092.png" alt="1532764957092"></p>
<p>但是，查看管理界面，发现：</p>
<p><img src="1532765013834.png" alt="1532765013834"></p>
<p>停掉消费者的程序，发现：</p>
<p><img src="1532765038088.png" alt="1532765038088"></p>
<p>这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。</p>
<p>当我们关掉这个消费者，消息的状态再次称为Ready</p>
<p>修改代码手动ACK：</p>
<p><img src="1532765123282.png" alt="1532765123282"></p>
<p>执行：</p>
<p><img src="1532765151039.png" alt="1532765151039"></p>
<p>消息消费成功！</p>
<h2 id="2-2-work消息模型"><a href="#2-2-work消息模型" class="headerlink" title="2.2.work消息模型"></a>2.2.work消息模型</h2><p>工作队列或者竞争消费者模式</p>
<p> <img src="1532765197277.png" alt="1532765197277"></p>
<p>在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。</p>
<p>工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是<strong>一个消息只能被一个消费者获取</strong>。</p>
<p>这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。</p>
<p>接下来我们来模拟这个流程：</p>
<pre><code>P：生产者：任务的发布者

C1：消费者，领取任务并且完成任务，假设完成速度较快

C2：消费者2：领取任务并完成任务，假设完成速度慢
</code></pre>
<p>面试题：避免消息堆积？</p>
<p>1）采用workqueue，多个消费者监听同一队列。</p>
<p>2）接收到消息以后，而是通过线程池，异步消费。</p>
<h3 id="2-2-1-生产者"><a href="#2-2-1-生产者" class="headerlink" title="2.2.1.生产者"></a>2.2.1.生产者</h3><p>生产者与案例1中的几乎一样：</p>
<pre><code class="java">public class Send &#123;
    private final static String QUEUE_NAME = &quot;test_work_queue&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        // 循环发布任务
        for (int i = 0; i &lt; 50; i++) &#123;
            // 消息内容
            String message = &quot;task .. &quot; + i;
            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
            System.out.println(&quot; [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);

            Thread.sleep(i * 2);
        &#125;
        // 关闭通道和连接
        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<p>不过这里我们是循环发送50条消息。</p>
<h3 id="2-2-2-消费者1"><a href="#2-2-2-消费者1" class="headerlink" title="2.2.2.消费者1"></a>2.2.2.消费者1</h3><p><img src="1527085386747.png" alt="1527085386747"></p>
<h3 id="2-2-3-消费者2"><a href="#2-2-3-消费者2" class="headerlink" title="2.2.3.消费者2"></a>2.2.3.消费者2</h3><p><img src="1527085448377.png" alt="1527085448377"></p>
<p>与消费者1基本类似，就是没有设置消费耗时时间。</p>
<p>这里是模拟有些消费者快，有些比较慢。</p>
<p>接下来，两个消费者一同启动，然后发送50条消息：</p>
<p><img src="1527085826462.png" alt="1527085826462"></p>
<p>可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。</p>
<h3 id="2-2-4-能者多劳"><a href="#2-2-4-能者多劳" class="headerlink" title="2.2.4.能者多劳"></a>2.2.4.能者多劳</h3><p>刚才的实现有问题吗？</p>
<ul>
<li>消费者1比消费者2的效率要低，一次任务的耗时较长</li>
<li>然而两人最终消费的消息数量是一样的</li>
<li>消费者2大量时间处于空闲状态，消费者1一直忙碌</li>
</ul>
<p>现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。</p>
<p>怎么实现呢？</p>
<p>我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。</p>
<p><img src="1532765689904.png" alt="1532765689904"></p>
<p>再次测试：</p>
<p><img src="1527086159534.png" alt="1527086159534"></p>
<h2 id="2-3-订阅模型分类"><a href="#2-3-订阅模型分类" class="headerlink" title="2.3.订阅模型分类"></a>2.3.订阅模型分类</h2><p>在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。 </p>
<p>订阅模型示意图：</p>
<p> <img src="1527086284940.png" alt="1527086284940"></p>
<p>解读：</p>
<p>1、1个生产者，多个消费者</p>
<p>2、每一个消费者都有自己的一个队列</p>
<p>3、生产者没有将消息直接发送到队列，而是发送到了交换机</p>
<p>4、每个队列都要绑定到交换机</p>
<p>5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的</p>
<p>X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p>
<p>Exchange类型有以下几种：</p>
<pre><code>Fanout：广播，将消息交给所有绑定到交换机的队列

Direct：定向，把消息交给符合指定routing key 的队列 

Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列
</code></pre>
<p>我们这里先学习</p>
<pre><code>Fanout：即广播模式
</code></pre>
<p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<h2 id="2-4-订阅模型-Fanout"><a href="#2-4-订阅模型-Fanout" class="headerlink" title="2.4.订阅模型-Fanout"></a>2.4.订阅模型-Fanout</h2><p>Fanout，也称为广播。</p>
<p>流程图：</p>
<p> <img src="1527086564505.png" alt="1527086564505"></p>
<p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>1）  可以有多个消费者</li>
<li>2）  每个<strong>消费者有自己的queue</strong>（队列）</li>
<li>3）  每个<strong>队列都要绑定到Exchange</strong>（交换机）</li>
<li>4）  <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li>
<li>5）  交换机把消息发送给绑定过的所有队列</li>
<li>6）  队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li>
</ul>
<h3 id="2-4-1-生产者"><a href="#2-4-1-生产者" class="headerlink" title="2.4.1.生产者"></a>2.4.1.生产者</h3><p>两个变化：</p>
<ul>
<li>1）  声明Exchange，不再声明Queue</li>
<li>2）  发送消息到Exchange，不再发送到Queue</li>
</ul>
<pre><code class="java">public class Send &#123;

    private final static String EXCHANGE_NAME = &quot;fanout_exchange_test&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        
        // 声明exchange，指定类型为fanout
        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);
        
        // 消息内容
        String message = &quot;Hello everyone&quot;;
        // 发布消息到Exchange
        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
        System.out.println(&quot; [生产者] Sent &#39;&quot; + message + &quot;&#39;&quot;);

        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<h3 id="2-4-2-消费者1"><a href="#2-4-2-消费者1" class="headerlink" title="2.4.2.消费者1"></a>2.4.2.消费者1</h3><pre><code class="java">public class Recv &#123;
    private final static String QUEUE_NAME = &quot;fanout_exchange_queue_1&quot;;

    private final static String EXCHANGE_NAME = &quot;fanout_exchange_test&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 绑定队列到交换机
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);

        // 定义队列的消费者
        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;
            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                    byte[] body) throws IOException &#123;
                // body 即消息体
                String msg = new String(body);
                System.out.println(&quot; [消费者1] received : &quot; + msg + &quot;!&quot;);
            &#125;
        &#125;;
        // 监听队列，自动返回完成
        channel.basicConsume(QUEUE_NAME, true, consumer);
    &#125;
&#125;
</code></pre>
<p>要注意代码中：<strong>队列需要和交换机绑定</strong></p>
<h3 id="2-4-3-消费者2"><a href="#2-4-3-消费者2" class="headerlink" title="2.4.3.消费者2"></a>2.4.3.消费者2</h3><pre><code class="java">public class Recv2 &#123;
    private final static String QUEUE_NAME = &quot;fanout_exchange_queue_2&quot;;

    private final static String EXCHANGE_NAME = &quot;fanout_exchange_test&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        // 绑定队列到交换机
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);
        
        // 定义队列的消费者
        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;
            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                    byte[] body) throws IOException &#123;
                // body 即消息体
                String msg = new String(body);
                System.out.println(&quot; [消费者2] received : &quot; + msg + &quot;!&quot;);
            &#125;
        &#125;;
        // 监听队列，手动返回完成
        channel.basicConsume(QUEUE_NAME, true, consumer);
    &#125;
&#125;
</code></pre>
<h3 id="2-4-4-测试"><a href="#2-4-4-测试" class="headerlink" title="2.4.4.测试"></a>2.4.4.测试</h3><p>我们运行两个消费者，然后发送1条消息：</p>
<p><img src="1532766264386.png" alt="1532766264386"></p>
<p><img src="1532766291204.png" alt="1532766291204"></p>
<h2 id="2-5-订阅模型-Direct"><a href="#2-5-订阅模型-Direct" class="headerlink" title="2.5.订阅模型-Direct"></a>2.5.订阅模型-Direct</h2><p>有选择性的接收消息</p>
<p>在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。</p>
<p>在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。</p>
<p>但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p>
<p>在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</p>
<p>消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。</p>
<p> <img src="1532766437787.png" alt="1532766437787"></p>
<p>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p>
<p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p>
<p>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p>
<p>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p>
<h3 id="2-5-1-生产者"><a href="#2-5-1-生产者" class="headerlink" title="2.5.1.生产者"></a>2.5.1.生产者</h3><p>此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete</p>
<pre><code class="java">public class Send &#123;
    private final static String EXCHANGE_NAME = &quot;direct_exchange_test&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        // 声明exchange，指定类型为direct
        channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);
        // 消息内容
        String message = &quot;商品新增了， id = 1001&quot;;
        // 发送消息，并且指定routing key 为：insert ,代表新增商品
        channel.basicPublish(EXCHANGE_NAME, &quot;insert&quot;, null, message.getBytes());
        System.out.println(&quot; [商品服务：] Sent &#39;&quot; + message + &quot;&#39;&quot;);

        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<h3 id="2-5-2-消费者1"><a href="#2-5-2-消费者1" class="headerlink" title="2.5.2.消费者1"></a>2.5.2.消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。</p>
<pre><code class="java">public class Recv &#123;
    private final static String QUEUE_NAME = &quot;direct_exchange_queue_1&quot;;
    private final static String EXCHANGE_NAME = &quot;direct_exchange_test&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        
        // 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;update&quot;);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);

        // 定义队列的消费者
        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;
            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                    byte[] body) throws IOException &#123;
                // body 即消息体
                String msg = new String(body);
                System.out.println(&quot; [消费者1] received : &quot; + msg + &quot;!&quot;);
            &#125;
        &#125;;
        // 监听队列，自动ACK
        channel.basicConsume(QUEUE_NAME, true, consumer);
    &#125;
&#125;
</code></pre>
<h3 id="2-5-3-消费者2"><a href="#2-5-3-消费者2" class="headerlink" title="2.5.3.消费者2"></a>2.5.3.消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p>
<pre><code class="java">public class Recv2 &#123;
    private final static String QUEUE_NAME = &quot;direct_exchange_queue_2&quot;;
    private final static String EXCHANGE_NAME = &quot;direct_exchange_test&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        
        // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;insert&quot;);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;update&quot;);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);

        // 定义队列的消费者
        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;
            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                    byte[] body) throws IOException &#123;
                // body 即消息体
                String msg = new String(body);
                System.out.println(&quot; [消费者2] received : &quot; + msg + &quot;!&quot;);
            &#125;
        &#125;;
        // 监听队列，自动ACK
        channel.basicConsume(QUEUE_NAME, true, consumer);
    &#125;
&#125;
</code></pre>
<h3 id="2-5-4-测试"><a href="#2-5-4-测试" class="headerlink" title="2.5.4.测试"></a>2.5.4.测试</h3><p>我们分别发送增、删、改的RoutingKey，发现结果：</p>
<p> <img src="1527088296131.png" alt="1527088296131"></p>
<h2 id="2-6-订阅模型-Topic"><a href="#2-6-订阅模型-Topic" class="headerlink" title="2.6.订阅模型-Topic"></a>2.6.订阅模型-Topic</h2><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<pre><code>`#`：匹配一个或多个词

`*`：匹配不多不少恰好1个词
</code></pre>
<p>举例：</p>
<pre><code>`audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs`

`audit.*`：只能匹配`audit.irs`
</code></pre>
<p> <img src="1532766712166.png" alt="1532766712166"></p>
<p>在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</p>
<p>我们创建了三个绑定：Q1绑定了绑定键“* .orange.<em>”，Q2绑定了“</em>.*.rabbit”和“lazy.＃”。</p>
<p>Q1匹配所有的橙色动物。</p>
<p>Q2匹配关于兔子以及懒惰动物的消息。</p>
<p>练习，生产者发送如下消息，会进入那个队列：</p>
<p>quick.orange.rabbit     Q1 Q2</p>
<p>lazy.orange.elephant     </p>
<p>quick.orange.fox      </p>
<p>lazy.pink.rabbit      </p>
<p>quick.brown.fox     </p>
<p>quick.orange.male.rabbit </p>
<p>orange </p>
<h3 id="2-6-1-生产者"><a href="#2-6-1-生产者" class="headerlink" title="2.6.1.生产者"></a>2.6.1.生产者</h3><p>使用topic类型的Exchange，发送消息的routing key有3种： <code>item.isnert</code>、<code>item.update</code>、<code>item.delete</code>：</p>
<pre><code class="java">public class Send &#123;
    private final static String EXCHANGE_NAME = &quot;topic_exchange_test&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        // 声明exchange，指定类型为topic
        channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;);
        // 消息内容
        String message = &quot;新增商品 : id = 1001&quot;;
        // 发送消息，并且指定routing key 为：insert ,代表新增商品
        channel.basicPublish(EXCHANGE_NAME, &quot;item.insert&quot;, null, message.getBytes());
        System.out.println(&quot; [商品服务：] Sent &#39;&quot; + message + &quot;&#39;&quot;);

        channel.close();
        connection.close();
    &#125;
&#125;
</code></pre>
<h3 id="2-6-2-消费者1"><a href="#2-6-2-消费者1" class="headerlink" title="2.6.2.消费者1"></a>2.6.2.消费者1</h3><p>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品</p>
<pre><code class="java">public class Recv &#123;
    private final static String QUEUE_NAME = &quot;topic_exchange_queue_1&quot;;
    private final static String EXCHANGE_NAME = &quot;topic_exchange_test&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        
        // 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.update&quot;);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.delete&quot;);

        // 定义队列的消费者
        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;
            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                    byte[] body) throws IOException &#123;
                // body 即消息体
                String msg = new String(body);
                System.out.println(&quot; [消费者1] received : &quot; + msg + &quot;!&quot;);
            &#125;
        &#125;;
        // 监听队列，自动ACK
        channel.basicConsume(QUEUE_NAME, true, consumer);
    &#125;
&#125;
</code></pre>
<h3 id="2-6-3-消费者2"><a href="#2-6-3-消费者2" class="headerlink" title="2.6.3.消费者2"></a>2.6.3.消费者2</h3><p>我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。</p>
<pre><code class="java">/**
 * 消费者2
 */
public class Recv2 &#123;
    private final static String QUEUE_NAME = &quot;topic_exchange_queue_2&quot;;
    private final static String EXCHANGE_NAME = &quot;topic_exchange_test&quot;;

    public static void main(String[] argv) throws Exception &#123;
        // 获取到连接
        Connection connection = ConnectionUtil.getConnection();
        // 获取通道
        Channel channel = connection.createChannel();
        // 声明队列
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        
        // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.*&quot;);

        // 定义队列的消费者
        DefaultConsumer consumer = new DefaultConsumer(channel) &#123;
            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                    byte[] body) throws IOException &#123;
                // body 即消息体
                String msg = new String(body);
                System.out.println(&quot; [消费者2] received : &quot; + msg + &quot;!&quot;);
            &#125;
        &#125;;
        // 监听队列，自动ACK
        channel.basicConsume(QUEUE_NAME, true, consumer);
    &#125;
&#125;
</code></pre>
<h2 id="2-7-持久化"><a href="#2-7-持久化" class="headerlink" title="2.7.持久化"></a>2.7.持久化</h2><p>如何避免消息丢失？</p>
<p>1）  消费者的ACK机制。可以防止消费者丢失消息。</p>
<p>2）  但是，如果在消费者消费之前，MQ就宕机了，消息就没了。</p>
<p>是可以将消息进行持久化呢？</p>
<p>要将消息持久化，前提是：队列、Exchange都持久化</p>
<h3 id="2-7-1-交换机持久化"><a href="#2-7-1-交换机持久化" class="headerlink" title="2.7.1.交换机持久化"></a>2.7.1.交换机持久化</h3><p><img src="1532766951432.png" alt="1532766951432"></p>
<h3 id="2-7-2-队列持久化"><a href="#2-7-2-队列持久化" class="headerlink" title="2.7.2.队列持久化"></a>2.7.2.队列持久化</h3><p><img src="1532766981230.png" alt="1532766981230"></p>
<h3 id="2-7-3-消息持久化"><a href="#2-7-3-消息持久化" class="headerlink" title="2.7.3.消息持久化"></a>2.7.3.消息持久化</h3><p><img src="1532767057491.png" alt="1532767057491"></p>
<h1 id="3-Spring-AMQP"><a href="#3-Spring-AMQP" class="headerlink" title="3.Spring AMQP"></a>3.Spring AMQP</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h2><p>Sprin有很多不同的项目，其中就有对AMQP的支持：</p>
<p><img src="1532767136007.png" alt="1532767136007"></p>
<p>Spring AMQP的页面：<a target="_blank" rel="noopener" href="http://spring.io/projects/spring-amqp">http://spring.io/projects/spring-amqp</a></p>
<p><img src="1532767171063.png" alt="1532767171063"></p>
<p>注意这里一段描述：</p>
<p><img src="1532767227821.png" alt="1532767227821">                                             </p>
<pre><code>     Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。
</code></pre>
<h2 id="3-2-依赖和配置"><a href="#3-2-依赖和配置" class="headerlink" title="3.2.依赖和配置"></a>3.2.依赖和配置</h2><p>添加AMQP的启动器：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>在<code>application.yml</code>中添加RabbitMQ地址：</p>
<pre><code class="yaml">spring:
  rabbitmq:
    host: 192.168.56.101
    username: leyou
    password: leyou
    virtual-host: /leyou
</code></pre>
<h2 id="3-3-监听者"><a href="#3-3-监听者" class="headerlink" title="3.3.监听者"></a>3.3.监听者</h2><p>在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。</p>
<pre><code class="java">@Component
public class Listener &#123;

    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = &quot;spring.test.queue&quot;, durable = &quot;true&quot;),
            exchange = @Exchange(
                    value = &quot;spring.test.exchange&quot;,
                    ignoreDeclarationExceptions = &quot;true&quot;,
                    type = ExchangeTypes.TOPIC
            ),
            key = &#123;&quot;#.#&quot;&#125;))
    public void listen(String msg)&#123;
        System.out.println(&quot;接收到消息：&quot; + msg);
    &#125;
&#125;
</code></pre>
<ul>
<li><code>@Componet</code>：类上的注解，注册到Spring容器</li>
<li><code>@RabbitListener</code>：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性：<ul>
<li><code>bindings</code>：指定绑定关系，可以有多个。值是<code>@QueueBinding</code>的数组。<code>@QueueBinding</code>包含下面属性：<ul>
<li><code>value</code>：这个消费者关联的队列。值是<code>@Queue</code>，代表一个队列</li>
<li><code>exchange</code>：队列所绑定的交换机，值是<code>@Exchange</code>类型</li>
<li><code>key</code>：队列和交换机绑定的<code>RoutingKey</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>类似listen这样的方法在一个类中可以写多个，就代表多个消费者。</p>
<h2 id="3-4-AmqpTemplate"><a href="#3-4-AmqpTemplate" class="headerlink" title="3.4.AmqpTemplate"></a>3.4.AmqpTemplate</h2><p>Spring最擅长的事情就是封装，把他人的框架进行封装和整合。</p>
<p>Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法：</p>
<p><img src="1527090258083.png" alt="1527090258083"></p>
<p>红框圈起来的是比较常用的3个方法，分别是：</p>
<ul>
<li>指定交换机、RoutingKey和消息体</li>
<li>指定消息</li>
<li>指定RoutingKey和消息，会向默认的交换机发送消息</li>
</ul>
<h2 id="3-5-测试代码"><a href="#3-5-测试代码" class="headerlink" title="3.5.测试代码"></a>3.5.测试代码</h2><pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class MqDemo &#123;

    @Autowired
    private AmqpTemplate amqpTemplate;

    @Test
    public void testSend() throws InterruptedException &#123;
        String msg = &quot;hello, Spring boot amqp&quot;;
        this.amqpTemplate.convertAndSend(&quot;spring.test.exchange&quot;,&quot;a.b&quot;, msg);
        // 等待10秒后再结束
        Thread.sleep(10000);
    &#125;
&#125;
</code></pre>
<p>运行后查看日志：</p>
<p><img src="1532767726274.png" alt="1532767726274"></p>
<h1 id="3-项目改造"><a href="#3-项目改造" class="headerlink" title="3.项目改造"></a>3.项目改造</h1><p>接下来，我们就改造项目，实现搜索服务、商品静态页的数据同步。</p>
<h2 id="3-1-思路分析"><a href="#3-1-思路分析" class="headerlink" title="3.1.思路分析"></a>3.1.思路分析</h2><blockquote>
<p>发送方：商品微服务</p>
</blockquote>
<ul>
<li><p>什么时候发？</p>
<p>当商品服务对商品进行写操作：增、删、改的时候，需要发送一条消息，通知其它服务。</p>
</li>
<li><p>发送什么内容？</p>
<p>对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们<strong>只发送商品id</strong>，其它服务可以根据id查询自己需要的信息。</p>
</li>
</ul>
<blockquote>
<p>接收方：搜索微服务、静态页微服务</p>
</blockquote>
<p>接收消息后如何处理？</p>
<ul>
<li>搜索微服务：<ul>
<li>增/改：添加新的数据到索引库 </li>
<li>删：删除索引库数据</li>
</ul>
</li>
<li>静态页微服务：<ul>
<li>增/改：创建新的静态页</li>
<li>删：删除原来的静态页</li>
</ul>
</li>
</ul>
<h2 id="3-2-商品服务发送消息"><a href="#3-2-商品服务发送消息" class="headerlink" title="3.2.商品服务发送消息"></a>3.2.商品服务发送消息</h2><p>我们先在商品微服务<code>leyou-item-service</code>中实现发送消息。</p>
<h3 id="3-2-1-引入依赖"><a href="#3-2-1-引入依赖" class="headerlink" title="3.2.1.引入依赖"></a>3.2.1.引入依赖</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="3-2-2-配置文件"><a href="#3-2-2-配置文件" class="headerlink" title="3.2.2.配置文件"></a>3.2.2.配置文件</h3><p>我们在application.yml中添加一些有关RabbitMQ的配置：</p>
<pre><code class="yaml">spring:
  rabbitmq:
    host: 192.168.56.101
    username: leyou
    password: leyou
    virtual-host: /leyou
    template:
      exchange: leyou.item.exchange
    publisher-confirms: true
</code></pre>
<ul>
<li>template：有关<code>AmqpTemplate</code>的配置<ul>
<li>exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个</li>
</ul>
</li>
<li>publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试</li>
</ul>
<h3 id="3-2-3-改造GoodsService"><a href="#3-2-3-改造GoodsService" class="headerlink" title="3.2.3.改造GoodsService"></a>3.2.3.改造GoodsService</h3><p>在GoodsService中封装一个发送消息到mq的方法：<strong>（需要注入AmqpTemplate模板）</strong></p>
<pre><code class="java">private void sendMessage(Long id, String type)&#123;
    // 发送消息
    try &#123;
        this.amqpTemplate.convertAndSend(&quot;item.&quot; + type, id);
    &#125; catch (Exception e) &#123;
        logger.error(&quot;&#123;&#125;商品消息发送异常，商品id：&#123;&#125;&quot;, type, id, e);
    &#125;
&#125;
</code></pre>
<p>这里没有指定交换机，因此默认发送到了配置中的：<code>leyou.item.exchange</code></p>
<p><strong>注意：这里要把所有异常都try起来，不能让消息的发送影响到正常的业务逻辑</strong></p>
<p>然后在新增的时候调用：</p>
<p><img src="1532768930797.png" alt="1532768930797"></p>
<p>修改的时候调用：</p>
<p><img src="1532769005960.png" alt="1532769005960"></p>
<h2 id="3-3-搜索服务接收消息"><a href="#3-3-搜索服务接收消息" class="headerlink" title="3.3.搜索服务接收消息"></a>3.3.搜索服务接收消息</h2><p>搜索服务接收到消息后要做的事情：</p>
<ul>
<li>增：添加新的数据到索引库</li>
<li>删：删除索引库数据</li>
<li>改：修改索引库数据</li>
</ul>
<p>因为索引库的新增和修改方法是合二为一的，因此我们可以将这两类消息一同处理，删除另外处理。</p>
<h3 id="3-3-1-引入依赖"><a href="#3-3-1-引入依赖" class="headerlink" title="3.3.1.引入依赖"></a>3.3.1.引入依赖</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="3-3-2-添加配置"><a href="#3-3-2-添加配置" class="headerlink" title="3.3.2.添加配置"></a>3.3.2.添加配置</h3><pre><code class="yaml">spring:
  rabbitmq:
    host: 192.168.56.101
    username: leyou
    password: leyou
    virtual-host: /leyou
</code></pre>
<p>这里只是接收消息而不发送，所以不用配置template相关内容。</p>
<h3 id="3-3-3-编写监听器"><a href="#3-3-3-编写监听器" class="headerlink" title="3.3.3.编写监听器"></a>3.3.3.编写监听器</h3><p> <img src="1532769181819.png" alt="1532769181819"></p>
<p>代码：</p>
<pre><code class="java">@Component
public class GoodsListener &#123;

    @Autowired
    private SearchService searchService;

    /**
     * 处理insert和update的消息
     *
     * @param id
     * @throws Exception
     */
    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = &quot;leyou.create.index.queue&quot;, durable = &quot;true&quot;),
            exchange = @Exchange(
                    value = &quot;leyou.item.exchange&quot;,
                    ignoreDeclarationExceptions = &quot;true&quot;,
                    type = ExchangeTypes.TOPIC),
            key = &#123;&quot;item.insert&quot;, &quot;item.update&quot;&#125;))
    public void listenCreate(Long id) throws Exception &#123;
        if (id == null) &#123;
            return;
        &#125;
        // 创建或更新索引
        this.searchService.createIndex(id);
    &#125;

    /**
     * 处理delete的消息
     *
     * @param id
     */
    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = &quot;leyou.delete.index.queue&quot;, durable = &quot;true&quot;),
            exchange = @Exchange(
                    value = &quot;leyou.item.exchange&quot;,
                    ignoreDeclarationExceptions = &quot;true&quot;,
                    type = ExchangeTypes.TOPIC),
            key = &quot;item.delete&quot;))
    public void listenDelete(Long id) &#123;
        if (id == null) &#123;
            return;
        &#125;
        // 删除索引
        this.searchService.deleteIndex(id);
    &#125;
&#125;
</code></pre>
<h3 id="3-3-4-编写创建和删除索引方法"><a href="#3-3-4-编写创建和删除索引方法" class="headerlink" title="3.3.4.编写创建和删除索引方法"></a>3.3.4.编写创建和删除索引方法</h3><p>这里因为要创建和删除索引，我们需要在SearchService中拓展两个方法，创建和删除索引：</p>
<pre><code class="java">public void createIndex(Long id) throws IOException &#123;

    Spu spu = this.goodsClient.querySpuById(id);
    // 构建商品
    Goods goods = this.buildGoods(spu);

    // 保存数据到索引库
    this.goodsRepository.save(goods);
&#125;

public void deleteIndex(Long id) &#123;
    this.goodsRepository.deleteById(id);
&#125;
</code></pre>
<p>创建索引的方法可以从之前导入数据的测试类中拷贝和改造。</p>
<h2 id="3-4-静态页服务接收消息"><a href="#3-4-静态页服务接收消息" class="headerlink" title="3.4.静态页服务接收消息"></a>3.4.静态页服务接收消息</h2><p>商品静态页服务接收到消息后的处理：</p>
<ul>
<li>增：创建新的静态页</li>
<li>删：删除原来的静态页</li>
<li>改：创建新的静态页并覆盖原来的</li>
</ul>
<p>不过，我们编写的创建静态页的方法也具备覆盖以前页面的功能，因此：增和改的消息可以放在一个方法中处理，删除消息放在另一个方法处理。</p>
<h3 id="3-4-1-引入依赖"><a href="#3-4-1-引入依赖" class="headerlink" title="3.4.1.引入依赖"></a>3.4.1.引入依赖</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="3-4-2-添加配置"><a href="#3-4-2-添加配置" class="headerlink" title="3.4.2.添加配置"></a>3.4.2.添加配置</h3><pre><code class="yaml">spring:
  rabbitmq:
    host: 192.168.56.101
    username: leyou
    password: leyou
    virtual-host: /leyou
</code></pre>
<p>这里只是接收消息而不发送，所以不用配置template相关内容。</p>
<h3 id="3-4-3-编写监听器"><a href="#3-4-3-编写监听器" class="headerlink" title="3.4.3.编写监听器"></a>3.4.3.编写监听器</h3><p> <img src="1532769581964.png" alt="1532769581964"></p>
<p>代码：</p>
<pre><code class="java">@Component
public class GoodsListener &#123;

    @Autowired
    private GoodsHtmlService goodsHtmlService;

    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = &quot;leyou.create.web.queue&quot;, durable = &quot;true&quot;),
            exchange = @Exchange(
                    value = &quot;leyou.item.exchange&quot;,
                    ignoreDeclarationExceptions = &quot;true&quot;,
                    type = ExchangeTypes.TOPIC),
            key = &#123;&quot;item.insert&quot;, &quot;item.update&quot;&#125;))
    public void listenCreate(Long id) throws Exception &#123;
        if (id == null) &#123;
            return;
        &#125;
        // 创建页面
        goodsHtmlService.createHtml(id);
    &#125;

    @RabbitListener(bindings = @QueueBinding(
            value = @Queue(value = &quot;leyou.delete.web.queue&quot;, durable = &quot;true&quot;),
            exchange = @Exchange(
                    value = &quot;leyou.item.exchange&quot;,
                    ignoreDeclarationExceptions = &quot;true&quot;,
                    type = ExchangeTypes.TOPIC),
            key = &quot;item.delete&quot;))
    public void listenDelete(Long id) &#123;
        if (id == null) &#123;
            return;
        &#125;
        // 删除页面
        goodsHtmlService.deleteHtml(id);
    &#125;
&#125;
</code></pre>
<h3 id="3-4-4-添加删除页面方法"><a href="#3-4-4-添加删除页面方法" class="headerlink" title="3.4.4.添加删除页面方法"></a>3.4.4.添加删除页面方法</h3><pre><code class="java">public void deleteHtml(Long id) &#123;
    File file = new File(&quot;C:\\project\\nginx-1.14.0\\html\\item\\&quot;, id + &quot;.html&quot;);
    file.deleteOnExit();
&#125;
</code></pre>
<h2 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5.测试"></a>3.5.测试</h2><h3 id="3-5-1-查看RabbitMQ控制台"><a href="#3-5-1-查看RabbitMQ控制台" class="headerlink" title="3.5.1.查看RabbitMQ控制台"></a>3.5.1.查看RabbitMQ控制台</h3><p>重新启动项目，并且登录RabbitMQ管理界面：<a target="_blank" rel="noopener" href="http://192.168.56.101:15672/">http://192.168.56.101:15672</a></p>
<p>可以看到，交换机已经创建出来了：</p>
<p><img src="1532772446520.png" alt="1532772446520"></p>
<p>队列也已经创建完毕：</p>
<p><img src="1532772471931.png" alt="1532772471931"></p>
<p>并且队列都已经绑定到交换机：</p>
<p><img src="1532772521932.png" alt="1532772521932"></p>
<h3 id="3-5-2-修改数据试一试"><a href="#3-5-2-修改数据试一试" class="headerlink" title="3.5.2.修改数据试一试"></a>3.5.2.修改数据试一试</h3><p>在后台修改商品数据的价格，分别在搜索及商品详情页查看是否统一。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/rabbitMQ/" rel="tag"># rabbitMQ</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/01/leyou%E9%97%A8%E6%88%B7-3-thymeleaf%E9%9D%99%E6%80%81%E5%8C%96/" rel="prev" title="leyou门户#3-thymeleaf静态化">
      <i class="fa fa-chevron-left"></i> leyou门户#3-thymeleaf静态化
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/03/leyou%E9%97%A8%E6%88%B7-5-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%EF%BC%88%E9%98%BF%E9%87%8C%E5%A4%A7%E4%BA%8E%EF%BC%89/" rel="next" title="leyou门户#5-用户注册（阿里大于）">
      leyou门户#5-用户注册（阿里大于） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-RabbitMQ"><span class="nav-text">1.RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%95%86%E5%93%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">1.1.搜索与商品服务的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89"><span class="nav-text">1.2.消息队列（MQ）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">1.2.1.什么是消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-AMQP%E5%92%8CJMS"><span class="nav-text">1.2.2.AMQP和JMS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-%E5%B8%B8%E8%A7%81MQ%E4%BA%A7%E5%93%81"><span class="nav-text">1.2.3.常见MQ产品</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-RabbitMQ"><span class="nav-text">1.2.4.RabbitMQ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85"><span class="nav-text">1.3.下载和安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-%E4%B8%8B%E8%BD%BD"><span class="nav-text">1.3.1.下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-%E5%AE%89%E8%A3%85"><span class="nav-text">1.3.2.安装</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%BA%94%E7%A7%8D%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.五种消息模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.1.基本消息模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-text">2.1.1.生产者发送消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B8%AD%E6%9F%A5%E7%9C%8B%E6%B6%88%E6%81%AF"><span class="nav-text">2.1.2.管理工具中查看消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E6%B6%88%E8%B4%B9%E8%80%85%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF"><span class="nav-text">2.1.3.消费者获取消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%EF%BC%88ACK%EF%BC%89"><span class="nav-text">2.1.4.消息确认机制（ACK）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-1-%E8%87%AA%E5%8A%A8ACK%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">2.1.4.1.自动ACK存在的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-2-%E6%BC%94%E7%A4%BA%E6%89%8B%E5%8A%A8ACK"><span class="nav-text">2.1.4.2.演示手动ACK</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-work%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.2.work消息模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">2.2.1.生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E6%B6%88%E8%B4%B9%E8%80%851"><span class="nav-text">2.2.2.消费者1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E6%B6%88%E8%B4%B9%E8%80%852"><span class="nav-text">2.2.3.消费者2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-%E8%83%BD%E8%80%85%E5%A4%9A%E5%8A%B3"><span class="nav-text">2.2.4.能者多劳</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="nav-text">2.3.订阅模型分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B-Fanout"><span class="nav-text">2.4.订阅模型-Fanout</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">2.4.1.生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E6%B6%88%E8%B4%B9%E8%80%851"><span class="nav-text">2.4.2.消费者1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-%E6%B6%88%E8%B4%B9%E8%80%852"><span class="nav-text">2.4.3.消费者2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-%E6%B5%8B%E8%AF%95"><span class="nav-text">2.4.4.测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B-Direct"><span class="nav-text">2.5.订阅模型-Direct</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">2.5.1.生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E6%B6%88%E8%B4%B9%E8%80%851"><span class="nav-text">2.5.2.消费者1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-%E6%B6%88%E8%B4%B9%E8%80%852"><span class="nav-text">2.5.3.消费者2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-4-%E6%B5%8B%E8%AF%95"><span class="nav-text">2.5.4.测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B-Topic"><span class="nav-text">2.6.订阅模型-Topic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">2.6.1.生产者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-%E6%B6%88%E8%B4%B9%E8%80%851"><span class="nav-text">2.6.2.消费者1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-%E6%B6%88%E8%B4%B9%E8%80%852"><span class="nav-text">2.6.3.消费者2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">2.7.持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">2.7.1.交换机持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">2.7.2.队列持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">2.7.3.消息持久化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Spring-AMQP"><span class="nav-text">3.Spring AMQP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">3.1.简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E4%BE%9D%E8%B5%96%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="nav-text">3.2.依赖和配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E7%9B%91%E5%90%AC%E8%80%85"><span class="nav-text">3.3.监听者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-AmqpTemplate"><span class="nav-text">3.4.AmqpTemplate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">3.5.测试代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E9%A1%B9%E7%9B%AE%E6%94%B9%E9%80%A0"><span class="nav-text">3.项目改造</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="nav-text">3.1.思路分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%95%86%E5%93%81%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-text">3.2.商品服务发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-text">3.2.1.引入依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">3.2.2.配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E6%94%B9%E9%80%A0GoodsService"><span class="nav-text">3.2.3.改造GoodsService</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-text">3.3.搜索服务接收消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-text">3.3.1.引入依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE"><span class="nav-text">3.3.2.添加配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E7%BC%96%E5%86%99%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">3.3.3.编写监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E7%BC%96%E5%86%99%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95"><span class="nav-text">3.3.4.编写创建和删除索引方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E9%9D%99%E6%80%81%E9%A1%B5%E6%9C%8D%E5%8A%A1%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-text">3.4.静态页服务接收消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-text">3.4.1.引入依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE"><span class="nav-text">3.4.2.添加配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E7%BC%96%E5%86%99%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">3.4.3.编写监听器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E9%A1%B5%E9%9D%A2%E6%96%B9%E6%B3%95"><span class="nav-text">3.4.4.添加删除页面方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%B5%8B%E8%AF%95"><span class="nav-text">3.5.测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E6%9F%A5%E7%9C%8BRabbitMQ%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="nav-text">3.5.1.查看RabbitMQ控制台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E8%AF%95%E4%B8%80%E8%AF%95"><span class="nav-text">3.5.2.修改数据试一试</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
