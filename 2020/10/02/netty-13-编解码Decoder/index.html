<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="上文讲解了粘包和拆包，下面直接代码讲解下编码和解码器Decoder。">
<meta property="og:type" content="article">
<meta property="og:title" content="netty#13-编解码Decoder">
<meta property="og:url" content="http://yoursite.com/2020/10/02/netty-13-%E7%BC%96%E8%A7%A3%E7%A0%81Decoder/index.html">
<meta property="og:site_name" content="摘星">
<meta property="og:description" content="上文讲解了粘包和拆包，下面直接代码讲解下编码和解码器Decoder。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/65135/Desktop/blog文章/netty/image-20201029151436483.png">
<meta property="article:published_time" content="2020-10-02T01:34:33.000Z">
<meta property="article:modified_time" content="2021-05-19T02:15:07.478Z">
<meta property="article:author" content="摘星">
<meta property="article:tag" content="netty">
<meta property="article:tag" content="网络编程">
<meta property="article:tag" content="I&#x2F;O">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/65135/Desktop/blog文章/netty/image-20201029151436483.png">

<link rel="canonical" href="http://yoursite.com/2020/10/02/netty-13-%E7%BC%96%E8%A7%A3%E7%A0%81Decoder/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>netty#13-编解码Decoder | 摘星</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">摘星</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/netty-13-%E7%BC%96%E8%A7%A3%E7%A0%81Decoder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="摘星">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="摘星">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          netty#13-编解码Decoder
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-02 09:34:33" itemprop="dateCreated datePublished" datetime="2020-10-02T09:34:33+08:00">2020-10-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>上文讲解了粘包和拆包，下面直接代码讲解下编码和解码器Decoder。</p>
<span id="more"></span>

<h1 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a>LineBasedFrameDecoder</h1><p><code>LineBasedFrameDecoder</code> 通过在包尾添加回车换行符<code>\r\n</code> 来区分整包消息。逻辑比较简单。</p>
<p>当然应用层还有更多复杂的方式可以解决这个问题，这个就属于网络层的问题了，我们还是用java提供的方式来解决这个问题。我们先看一个例子看看粘包是如何发生的。</p>
<p>服务端：</p>
<pre><code class="java">public class HelloWordServer &#123;
    private int port;

    public HelloWordServer(int port) &#123;
        this.port = port;
    &#125;

    public void start()&#123;
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workGroup = new NioEventLoopGroup();

        ServerBootstrap server = new ServerBootstrap().group(bossGroup,workGroup)
                                    .channel(NioServerSocketChannel.class)
                                    .childHandler(new ServerChannelInitializer());

        try &#123;
            ChannelFuture future = server.bind(port).sync();
            future.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            bossGroup.shutdownGracefully();
            workGroup.shutdownGracefully();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        HelloWordServer server = new HelloWordServer(7788);
        server.start();
    &#125;
&#125;
</code></pre>
<p>服务端Initializer：</p>
<pre><code class="java">public class ServerChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;
    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
        ChannelPipeline pipeline = socketChannel.pipeline();

        // 字符串解码 和 编码
        pipeline.addLast(&quot;decoder&quot;, new StringDecoder());
        pipeline.addLast(&quot;encoder&quot;, new StringEncoder());

        // 自己的逻辑Handler
        pipeline.addLast(&quot;handler&quot;, new HelloWordServerHandler());
    &#125;
&#125;
</code></pre>
<p>服务端handler：</p>
<pre><code class="java">public class HelloWordServerHandler extends ChannelInboundHandlerAdapter &#123;
    private int counter;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        String body = (String)msg;
        System.out.println(&quot;server receive order : &quot; + body + &quot;;the counter is: &quot; + ++counter);
    &#125;

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        super.exceptionCaught(ctx, cause);
    &#125;
&#125;
</code></pre>
<p>客户端：</p>
<pre><code class="java">public class HelloWorldClient &#123;
    private  int port;
    private  String address;

    public HelloWorldClient(int port,String address) &#123;
        this.port = port;
        this.address = address;
    &#125;

    public void start()&#123;
        EventLoopGroup group = new NioEventLoopGroup();

        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(group)
                .channel(NioSocketChannel.class)
                .handler(new ClientChannelInitializer());

        try &#123;
            ChannelFuture future = bootstrap.connect(address,port).sync();         
            future.channel().closeFuture().sync();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            group.shutdownGracefully();
        &#125;

    &#125;

    public static void main(String[] args) &#123;
        HelloWorldClient client = new HelloWorldClient(7788,&quot;127.0.0.1&quot;);
        client.start();
    &#125;
&#125;
</code></pre>
<p>客户端Initializer：</p>
<pre><code class="java">public class ClientChannelInitializer extends  ChannelInitializer&lt;SocketChannel&gt; &#123;

    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
        ChannelPipeline pipeline = socketChannel.pipeline();

        pipeline.addLast(&quot;decoder&quot;, new StringDecoder());
        pipeline.addLast(&quot;encoder&quot;, new StringEncoder());

        // 客户端的逻辑
        pipeline.addLast(&quot;handler&quot;, new HelloWorldClientHandler());
    &#125;
&#125;
</code></pre>
<p>客户端handler：</p>
<pre><code class="java">public class HelloWorldClientHandler extends ChannelInboundHandlerAdapter &#123;
    private byte[] req;
    private int counter;

    public BaseClientHandler() &#123;
        req = (&quot;Unless required by applicable law or agreed to in writing, software\n&quot; +
                &quot;  distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot; +
                &quot;  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot; +
                &quot;  See the License for the specific language governing permissions and\n&quot; +
                &quot;  limitations under the License.This connector uses the BIO implementation that requires the JSSE\n&quot; +
                &quot;  style configuration. When using the APR/native implementation, the\n&quot; +
                &quot;  penSSL style configuration is required as described in the APR/native\n&quot; +
                &quot;  documentation.An Engine represents the entry point (within Catalina) that processes\n&quot; +
                &quot;  every request.  The Engine implementation for Tomcat stand alone\n&quot; +
                &quot;  analyzes the HTTP headers included with the request, and passes them\n&quot; +
                &quot;  on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software\n&quot; +
                &quot;# distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot; +
                &quot;# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot; +
                &quot;# See the License for the specific language governing permissions and\n&quot; +
                &quot;# limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log\n&quot; +
                &quot;# each component that extends LifecycleBase changing state:\n&quot; +
                &quot;#org.apache.catalina.util.LifecycleBase.level = FINE&quot;
                ).getBytes();
    &#125;

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
        ByteBuf message;

        //将上面的所有字符串作为一个消息体发送出去
        message = Unpooled.buffer(req.length);
        message.writeBytes(req);
        ctx.writeAndFlush(message);
    &#125;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        String buf = (String)msg;
        System.out.println(&quot;Now is : &quot; + buf + &quot; ; the counter is : &quot;+ (++counter));
    &#125;

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        ctx.close();
    &#125;
&#125;
</code></pre>
<p>运行客户端和服务端我们能看到：</p>
<p><img src="C:/Users/65135/Desktop/blog文章/netty/image-20201029151436483.png" alt="image-20201029151436483"></p>
<p>我们看到这个长长的字符串被截成了2段发送，这就是发生了拆包的现象。同样粘包我们也很容易去模拟，我们把BaseClientHandler中的channelActive方法里面的：</p>
<pre><code class="java">message = Unpooled.buffer(req.length);
message.writeBytes(req);
ctx.writeAndFlush(message);
</code></pre>
<p>这几行代码是把我们上面的一长串字符转成的byte数组写进流里发送出去，那么我们可以在这里把上面发送消息的这几行循环几遍这样发送的内容增多了就有可能在拆包的时候把上一条消息的一部分分配到下一条消息里面了，修改如下：</p>
<pre><code class="java">for (int i = 0; i &lt; 3; i++) &#123;
    message = Unpooled.buffer(req.length);
    message.writeBytes(req);
    ctx.writeAndFlush(message);
&#125;
</code></pre>
<p>改完之后我们再运行一下，输出太长不好截图，我们在输出结果中能看到循环3次之后的消息服务端收到的就不是之前的完整的一条了，而是被拆分了4次发送。</p>
<p>对于上面出现的粘包和拆包的问题，Netty已有考虑，并且有实施的方案：LineBasedFrameDecoder。<br>我们重新改写一下ServerChannelInitializer：</p>
<pre><code class="java">public class ServerChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;
    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
        ChannelPipeline pipeline = socketChannel.pipeline();


        pipeline.addLast(new LineBasedFrameDecoder(2048));       
        // 字符串解码 和 编码
        pipeline.addLast(&quot;decoder&quot;, new StringDecoder());
        pipeline.addLast(&quot;encoder&quot;, new StringEncoder());

        // 自己的逻辑Handler
        pipeline.addLast(&quot;handler&quot;, new BaseServerHandler());
    &#125;
&#125;
</code></pre>
<p>新增：pipeline.addLast(new LineBasedFrameDecoder(2048))。同时，我们还得对上面发送的消息进行改造BaseClientHandler：</p>
<pre><code class="java">public class BaseClientHandler extends ChannelInboundHandlerAdapter &#123;
    private byte[] req;
    private int counter;

    req = (&quot;Unless required by applicable dfslaw or agreed to in writing, software&quot; +
                &quot;  distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot; +
                &quot;  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot; +
                &quot;  See the License for the specific language governing permissions and&quot; +
                &quot;  limitations under the License.This connector uses the BIO implementation that requires the JSSE&quot; +
                &quot;  style configuration. When using the APR/native implementation, the&quot; +
                &quot;  penSSL style configuration is required as described in the APR/native&quot; +
                &quot;  documentation.An Engine represents the entry point (within Catalina) that processes&quot; +
                &quot;  every request.  The Engine implementation for Tomcat stand alone&quot; +
                &quot;  analyzes the HTTP headers included with the request, and passes them&quot; +
                &quot;  on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software&quot; +
                &quot;# distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot; +
                &quot;# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot; +
                &quot;# See the License for the specific language governing permissions and&quot; +
                &quot;# limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log&quot; +
                &quot;# each component that extends LifecycleBase changing state:&quot; +
                &quot;#org.apache.catalina.util.LifecycleBase.level = FINE\n&quot;
                ).getBytes();  


    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
        ByteBuf message;

        message = Unpooled.buffer(req.length);
        message.writeBytes(req);
        ctx.writeAndFlush(message);
    &#125;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        String buf = (String)msg;
        System.out.println(&quot;Now is : &quot; + buf + &quot; ; the counter is : &quot;+ (++counter));
    &#125;

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        ctx.close();
    &#125;
&#125;
</code></pre>
<p>去掉所有的”\n”,只保留字符串末尾的这一个。原因稍后再说。channelActive方法中我们不必再用循环多次发送消息了，只发送一次就好(第一个例子中发送一次的时候是发生了拆包的)，然后我们再次运行，大家会看到这么长一串字符只发送了一串就发送完毕。程序输出我就不截图了。下面来解释一下LineBasedFrameDecoder。</p>
<p>LineBasedFrameDecoder的工作原理是它依次遍历ByteBuf 中的可读字节，判断看是否有”\n” 或者” \r\n”，如果有，就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。它是以换行符为结束标志的解码器。支持携带结束符或者不携带结束符两种解码方式，同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发现换行符，就会抛出异常，同时忽略掉之前读到的异常码流。这个对于我们确定消息最大长度的应用场景还是很有帮助。</p>
<p>对于上面的判断看是否有”\n” 或者” \r\n”以此作为结束的标志我们可能回想，要是没有”\n” 或者” \r\n”那还有什么别的方式可以判断消息是否结束呢。别担心，Netty对于此已经有考虑，还有别的解码器可以帮助我们解决问题。</p>
<h1 id="FixedLengthFrameDecoder"><a href="#FixedLengthFrameDecoder" class="headerlink" title="FixedLengthFrameDecoder"></a>FixedLengthFrameDecoder</h1><p><code>LineBasedFrameDecoder</code>即固定消息长度解码器，个人认为这个貌似不能适用通用场景。</p>
<p>FixedLengthFrameDecoder是固定长度解码器，它能够按照指定的长度对消息进行自动解码。使用它也没有什么特别费力的事情，在ServerChannelInitializer类中添加：</p>
<p>pipeline.addLast(new FixedLengthFrameDecoder(23));//参数为一次接受的数据长度</p>
<p>即可，同时也别忘了把刚才使用的DelimiterBasedFrameDecoder注释掉啊，不然达不到效果。</p>
<h1 id="DelimiterBasedFrameDecoder"><a href="#DelimiterBasedFrameDecoder" class="headerlink" title="DelimiterBasedFrameDecoder"></a>DelimiterBasedFrameDecoder</h1><p><code>DelimiterBasedFrameDecoder</code>即自定义分隔符解码器。相当于是 <code>LineBasedFrameDecoder</code>的高阶版。</p>
<p>服务端：</p>
<pre><code class="java">public class HelloWordServer &#123;
    private int port;

    public HelloWordServer(int port) &#123;
        this.port = port;
    &#125;

    public void start()&#123;
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workGroup = new NioEventLoopGroup();

        ServerBootstrap server = new ServerBootstrap().group(bossGroup,workGroup)
                                    .channel(NioServerSocketChannel.class)
                                    .childHandler(new ServerChannelInitializer());

        try &#123;
            ChannelFuture future = server.bind(port).sync();
            future.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            bossGroup.shutdownGracefully();
            workGroup.shutdownGracefully();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        HelloWordServer server = new HelloWordServer(7788);
        server.start();
    &#125;
&#125;
</code></pre>
<p>服务端ServerChannelInitializer：</p>
<pre><code class="java">public class ServerChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;
    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
        ChannelPipeline pipeline = socketChannel.pipeline();

        ByteBuf delimiter = Unpooled.copiedBuffer(&quot;\t&quot;.getBytes());
        pipeline.addLast(&quot;framer&quot;, new DelimiterBasedFrameDecoder(2048,delimiter));    
        // 字符串解码 和 编码
        pipeline.addLast(&quot;decoder&quot;, new StringDecoder());
        pipeline.addLast(&quot;encoder&quot;, new StringEncoder());

        // 自己的逻辑Handler
        pipeline.addLast(&quot;handler&quot;, new ServerHandler());
    &#125;
&#125;
</code></pre>
<p>服务端handler：</p>
<pre><code class="java">public class ServerHandler extends ChannelInboundHandlerAdapter &#123;
    private int counter;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        String body = (String)msg;
        System.out.println(&quot;server receive order : &quot; + body + &quot;;the counter is: &quot; + ++counter);
    &#125;

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        super.exceptionCaught(ctx, cause);
    &#125;
&#125;
</code></pre>
<p>客户端：</p>
<pre><code class="java">public class HelloWorldClient &#123;
    private  int port;
    private  String address;

    public HelloWorldClient(int port,String address) &#123;
        this.port = port;
        this.address = address;
    &#125;

    public void start()&#123;
        EventLoopGroup group = new NioEventLoopGroup();

        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(group)
                .channel(NioSocketChannel.class)
                .handler(new ClientChannelInitializer());

        try &#123;
            ChannelFuture future = bootstrap.connect(address,port).sync();
            future.channel().closeFuture().sync();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            group.shutdownGracefully();
        &#125;

    &#125;

    public static void main(String[] args) &#123;
        HelloWorldClient client = new HelloWorldClient(7788,&quot;127.0.0.1&quot;);
        client.start();
    &#125;
&#125;
</code></pre>
<p>客户端ClientChannelInitializer：</p>
<pre><code class="java">public class ClientChannelInitializer extends  ChannelInitializer&lt;SocketChannel&gt; &#123;

    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
        ChannelPipeline pipeline = socketChannel.pipeline();

        /*
         * 这个地方的 必须和服务端对应上。否则无法正常解码和编码
         *
         *
         */       
        ByteBuf delimiter = Unpooled.copiedBuffer(&quot;\t&quot;.getBytes());
        pipeline.addLast(&quot;framer&quot;, new DelimiterBasedFrameDecoder(2048,delimiter)); 
        pipeline.addLast(&quot;decoder&quot;, new StringDecoder());
        pipeline.addLast(&quot;encoder&quot;, new StringEncoder());

        // 客户端的逻辑
        pipeline.addLast(&quot;handler&quot;, new ClientHandler());
    &#125;
&#125;
</code></pre>
<p>客户端handler：</p>
<pre><code class="java">public class ClientHandler extends ChannelInboundHandlerAdapter &#123;
    private byte[] req;
    private int counter;

    public ClientHandler() &#123;
         req = (&quot;Unless required by applicable law or agreed to in writing, software\t&quot; +
                &quot;  distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\t&quot; +
                &quot;  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\t&quot; +
                &quot;  See the License for the specific language governing permissions and\t&quot; +
                &quot;  limitations under the License.This connector uses the BIO implementation that requires the JSSE\t&quot; +
                &quot;  style configuration. When using the APR/native implementation, the\t&quot; +
                &quot;  penSSL style configuration is required as described in the APR/native\t&quot; +
                &quot;  documentation.An Engine represents the entry point (within Catalina) that processes\t&quot; +
                &quot;  every request.  The Engine implementation for Tomcat stand alone\t&quot; +
                &quot;  analyzes the HTTP headers included with the request, and passes them\t&quot; +
                &quot;  on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software\t&quot; +
                &quot;# distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\t&quot; +
                &quot;# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\t&quot; +
                &quot;# See the License for the specific language governing permissions and\t&quot; +
                &quot;# limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log\t&quot; +
                &quot;# each component that extends LifecycleBase changing state:\t&quot; +
                &quot;#org.apache.catalina.util.LifecycleBase.level = FINE\t&quot;
                ).getBytes();
    &#125;

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
        ByteBuf message;

        message = Unpooled.buffer(req.length);
        message.writeBytes(req);
        ctx.writeAndFlush(message);
    &#125;

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        String buf = (String)msg;
        System.out.println(&quot;Now is : &quot; + buf + &quot; ; the counter is : &quot;+ (++counter));
    &#125;

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        ctx.close();
    &#125;
&#125;
</code></pre>
<p>输出如下：</p>
<pre><code class="java">server receive order : Unless required by applicable law or agreed to in writing, software;the counter is: 1
server receive order :   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,;the counter is: 2
server receive order :   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.;the counter is: 3
server receive order :   See the License for the specific language governing permissions and;the counter is: 4
server receive order :   limitations under the License.This connector uses the BIO implementation that requires the JSSE;the counter is: 5
server receive order :   style configuration. When using the APR/native implementation, the;the counter is: 6
server receive order :   penSSL style configuration is required as described in the APR/native;the counter is: 7
server receive order :   documentation.An Engine represents the entry point (within Catalina) that processes;the counter is: 8
server receive order :   every request.  The Engine implementation for Tomcat stand alone;the counter is: 9
server receive order :   analyzes the HTTP headers included with the request, and passes them;the counter is: 10
server receive order :   on to the appropriate Host (virtual host)# Unless required by applicable law or agreed to in writing, software;the counter is: 11
server receive order : # distributed under the License is distributed on an &quot;AS IS&quot; BASIS,;the counter is: 12
server receive order : # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.;the counter is: 13
server receive order : # See the License for the specific language governing permissions and;the counter is: 14
server receive order : # limitations under the License.# For example, set the org.apache.catalina.util.LifecycleBase logger to log;the counter is: 15
server receive order : # each component that extends LifecycleBase changing state:;the counter is: 16
server receive order : #org.apache.catalina.util.LifecycleBase.level = FINE;the counter is: 17
</code></pre>
<p>启动服务端和客户端，我们能看到服务端接收客户端发过来的消息一共分17次接收。那么为什么是17次呢？而且我们并没有使用在上一篇中解决拆包和粘包问题的LineBasedFrameDecoder，并且这次我们的消息每一行的末尾也换成了”\t”。下面就来讲解一下DelimiterBasedFrameDecoder的使用。</p>
<p>DelimiterBasedFrameDecoder是将特殊的字符作为消息的分隔符，本例中用到的是”\t”。而LineBasedFrameDecoder是默认将换行符”\n”作为消息分隔符。首先我们注意到在ServerChannelInitializer中我们在添加解码器时跟以前有点不一样：</p>
<pre><code class="java">ByteBuf delimiter = Unpooled.copiedBuffer(&quot;\t&quot;.getBytes());
pipeline.addLast(&quot;framer&quot;, new DelimiterBasedFrameDecoder(2048, delimiter));
</code></pre>
<p>这里我们添加DelimiterBasedFrameDecoder解码器并且手动指定消息分隔符为：”\t”。我们可以看一下DelimiterBasedFrameDecoder的构造方法：</p>
<pre><code class="java">public DelimiterBasedFrameDecoder(int maxFrameLength, boolean stripDelimiter, ByteBuf delimiter) &#123;
        this(maxFrameLength, stripDelimiter, true, delimiter);
&#125;
</code></pre>
<p>maxFrameLength：解码的帧的最大长度</p>
<p>stripDelimiter：解码时是否去掉分隔符</p>
<p>failFast：为true，当frame长度超过maxFrameLength时立即报TooLongFrameException异常，为false，读取完整个帧再报异常</p>
<p>delimiter：分隔符</p>
<p>这个时候大家应该明白了为什么服务端分17次收到消息。我们在消息的每一行都加了一个”\t”,自然解码器在度消息时遇到”\t”就会认为这是一条消息的结束。用这种方式我们可以把”\t”换成任何我们自定义的字符对象。换成”\n”也是可以的。</p>
<h1 id="LengthFieldBasedFrameDecoder"><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a>LengthFieldBasedFrameDecoder</h1><p><code>LengthFieldBasedFrameDecoder</code>相对就高端一点。前面我们使用到的拆包都是基于一些约定来做的，比如固定长度，特殊分隔符，这些方案总是有一定的弊端。最好的方案就是：发送方告诉我当前消息总长度，接收方如果没有收到该长度大小的数据就认为是没有收完继续等待。</p>
<p>在TCP协议中我们知道当我们在接收消息时候，我们如何判断我们一次读取到的包就是整包消息呢，特别是对于使用了长连接和使用了非阻塞I/O的程序。上节我们也说了上层应用协议为了对消息进行区分一般采用4种方式。前面三种我们都说了，第四种是：通过在消息头定义长度字段来标识消息总长度。这个我们还没讲。当然Netty也提供了相应的解码器：LengthFieldBasedFrameDecoder。</p>
<p>大多数的协议（私有或者公有），协议头中会携带长度字段，用于标识消息体或者整包消息的长度，例如SMPP、HTTP协议等。由于基于长度解码需求 的通用性，Netty提供了LengthFieldBasedFrameDecoder，自动屏蔽TCP底层的拆包和粘 包问题，只需要传入正确的参数，即可轻松解决“读半包“问题。</p>
<p>我们先来看一下他的构造函数：</p>
<pre><code class="java">/**
     * Creates a new instance.
     *
     * @param maxFrameLength 帧的最大长度
     *        
     * @param lengthFieldOffset 长度字段偏移的地址
     *        
     * @param lengthFieldLength 长度字段所占的字节长
     *        修改帧数据长度字段中定义的值，可以为负数 因为有时候我们习惯把头部记入长度,
     *        若为负数,则说明要推后多少个字段
     * @param lengthAdjustment 解析时候跳过多少个长度
     *
     * @param initialBytesToStrip 解码出一个数据包之后，去掉开头的字节数
     *        
     * @param initialBytesToStrip  为true，当frame长度超过maxFrameLength时立即报
     *                   TooLongFrameException异常，为false，读取完整个帧再报异
     *        
     */  
public LengthFieldBasedFrameDecoder(ByteOrder byteOrder, 
                                    int maxFrameLength, 
                                    int lengthFieldOffset, 
                                    int lengthFieldLength, 
                                    int lengthAdjustment, 
                                    int initialBytesToStrip, 
                                    boolean failFast) &#123;

&#125;
</code></pre>
<ul>
<li>byteOrder：表示字节流表示的数据是大端还是小端，用于长度域的读取；</li>
<li>maxFrameLength：表示的是包的最大长度，超出包的最大长度netty将会做一些特殊处理；</li>
<li>lengthFieldOffset：指的是长度域的偏移量，表示跳过指定长度个字节之后的才是长度域；</li>
<li>lengthFieldLength：记录该帧数据长度的字段本身的长度；</li>
<li>lengthAdjustment：该字段加长度字段等于数据帧的长度，包体长度调整的大小，长度域的数值表示的长度加上这个修正值表示的就是带header的包；</li>
<li>initialBytesToStrip：从数据帧中跳过的字节数，表示获取完一个完整的数据包之后，忽略前面的指定的位数个字节，应用解码器拿到的就是不带长度域的数据包；</li>
<li>failFast：如果为true，则表示读取到长度域，TA的值的超过maxFrameLength，就抛出一个 TooLongFrameException，而为false表示只有当真正读取完长度域的值表示的字节之后，才会抛出 TooLongFrameException，默认情况下设置为true，建议不要修改，否则可能会造成内存溢出。</li>
</ul>
<p>LengthFieldBasedFrameDecoder定义了一个长度的字段来表示消息的长度，因此能够处理可变长度的消息。将消息分为消息头和消息体，消息头固定位置增加一个表示长度的字段，通过长度字段来获取整包的信息。LengthFieldBasedFrameDecoder继承了ByteToMessageDecoder，即转换字节这样的工作是由ByteToMessageDecoder来完成，而LengthFieldBasedFrameDecoder只用安心完成他的解码工作就好。Netty在解耦和方面确实做的不错。</p>
<p>在 <code>LengthFieldBasedFrameDecoder</code>类的注解上给出了一些关于该类使用的示例：</p>
<p><strong>示例1：</strong></p>
<p>lengthFieldOffset = 0，长度字段偏移位置为0表示从包的第一个字节开始读取；</p>
<p>lengthFieldLength = 2，长度字段长为2，从包的开始位置往后2个字节的长度为长度字段；</p>
<p>lengthAdjustment = 0 ，解析的时候无需跳过任何长度；</p>
<p>initialBytesToStrip = 0，无需去掉当前数据包的开头字节数, header + body。</p>
<p>0x000C 转为 int = 12。</p>
<pre><code class="txt"> * &lt;pre&gt;
 * &lt;b&gt;lengthFieldOffset&lt;/b&gt;   = &lt;b&gt;0&lt;/b&gt;
 * &lt;b&gt;lengthFieldLength&lt;/b&gt;   = &lt;b&gt;2&lt;/b&gt;
 * lengthAdjustment    = 0
 * initialBytesToStrip = 0 (= do not strip header)
 *
 * BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
 * +--------+----------------+      +--------+----------------+
 * | Length | Actual Content |-----&gt;| Length | Actual Content |
 * | 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |
 * +--------+----------------+      +--------+----------------+
 * &lt;/pre&gt;
</code></pre>
<p>上面这个设置表示：body长度为12，从当前包的第0个字节开始读取，前两个字节表示包长度，读取数据 body的时候不偏移从0字节开始，所以整包大小14个字节，包含包头长度字节在内。</p>
<p><strong>示例2：</strong></p>
<p>lengthFieldOffset = 0，长度字段偏移位置为0表示从包的第一个字节开始读取；</p>
<p>lengthFieldLength = 2，长度字段长为2，从包的开始位置往后2个字节的长度为长度字段；</p>
<p>lengthAdjustment = 0 ，解析的时候无需跳过任何长度；</p>
<p>initialBytesToStrip = 2，去掉当前数据包的开头2字节，去掉 header。</p>
<p>0x000C 转为 int = 12。</p>
<pre><code class="txt">* &lt;pre&gt;
* lengthFieldOffset   = 0
* lengthFieldLength   = 2
* lengthAdjustment    = 0
* &lt;b&gt;initialBytesToStrip&lt;/b&gt; = &lt;b&gt;2&lt;/b&gt; (= the length of the Length field)
*
* BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)
* +--------+----------------+      +----------------+
* | Length | Actual Content |-----&gt;| Actual Content |
* | 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |
* +--------+----------------+      +----------------+
* &lt;/pre&gt;
</code></pre>
<p>这个配置跟上面的而区别就在于，initialBytesToStrip = 2，表示当前包中的有效数据是从整包偏移2个字节开始计算的，即包头中的长度字段 2 byte 不属于包内容的一部分。</p>
<p><strong>示例3：</strong></p>
<p>lengthFieldOffset = 0，长度字段偏移位置为0表示从包的第一个字节开始读取；</p>
<p>lengthFieldLength = 2，长度字段长为2，从包的开始位置往后2个字节的长度为长度字段；</p>
<p>lengthAdjustment = -2 ，解析的时候无需跳过任何长度；</p>
<p>initialBytesToStrip = 0，无需去掉当前数据包的开头字节数。</p>
<p>0x000C 转为 int = 12。</p>
<pre><code class="txt">* &lt;pre&gt;
* lengthFieldOffset   =  0
* lengthFieldLength   =  2
* &lt;b&gt;lengthAdjustment&lt;/b&gt;    = &lt;b&gt;-2&lt;/b&gt; (= the length of the Length field)
* initialBytesToStrip =  0
*
* BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
* +--------+----------------+      +--------+----------------+
* | Length | Actual Content |-----&gt;| Length | Actual Content |
* | 0x000E | &quot;HELLO, WORLD&quot; |      | 0x000E | &quot;HELLO, WORLD&quot; |
* +--------+----------------+      +--------+----------------+
* &lt;/pre&gt;
</code></pre>
<p>length = 14，长度字段为 2 字节，真实的数据长度为 12 个字节，但是 length = 14，那么说明 length的长度也算上了数据包长度了。lengthAdjustment = -2 ，表示当前length长度往回调2个字节，这样总包长度就是14个字节。</p>
<p><strong>示例4：</strong></p>
<p>lengthFieldOffset = 2，长度字段偏移位置为2表示从包的第3个字节开始读取；</p>
<p>lengthFieldLength = 3，长度字段长为3，从包的开始位置往后3个字节的长度为长度字段；</p>
<p>lengthAdjustment = 0 ，解析的时候无需跳过任何长度；</p>
<p>initialBytesToStrip = 0，无需去掉当前数据包的开头字节数。</p>
<p>0x000E 转为 int = 14。</p>
<pre><code class="java">  * &lt;pre&gt;
  * &lt;b&gt;lengthFieldOffset&lt;/b&gt;   = &lt;b&gt;2&lt;/b&gt; (= the length of Header 1)
  * &lt;b&gt;lengthFieldLength&lt;/b&gt;   = &lt;b&gt;3&lt;/b&gt;
  * lengthAdjustment    = 0
  * initialBytesToStrip = 0
  *
  * BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
  * +----------+----------+----------------+      +----------+----------+----------------+
  * | Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |
  * |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |
  * +----------+----------+----------------+      +----------+----------+----------------+
  * &lt;/pre&gt;
  *
</code></pre>
<p>header头占2个字节，长度字段占3个字节，content字段占12个字节，总共17个字节。body读取无偏移要求，所以body整体也是17个字节。</p>
<p><strong>示例5：</strong></p>
<p>lengthFieldOffset = 0，长度字段偏移位置为0表示从包的第0个字节开始读取；</p>
<p>lengthFieldLength = 3，长度字段长为3，从包的开始位置往后3个字节的长度为长度字段；</p>
<p>lengthAdjustment = 2 ，解析的时候跳过2个字节；</p>
<p>initialBytesToStrip = 0，无需去掉当前数据包的开头字节数。</p>
<p>0x000C 转为 int = 12。</p>
<pre><code>* &lt;pre&gt;
* lengthFieldOffset   = 0
* lengthFieldLength   = 3
* &lt;b&gt;lengthAdjustment&lt;/b&gt;    = &lt;b&gt;2&lt;/b&gt; (= the length of Header 1)
* initialBytesToStrip = 0
*
* BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
* +----------+----------+----------------+      +----------+----------+----------------+
* |  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |
* | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |
* +----------+----------+----------------+      +----------+----------+----------------+
* &lt;/pre&gt;
*
</code></pre>
<p>这个包 length在最前面传输占3个字节，header在中间占两个字节，content在最后占12个字节。body字段只有content，所以读取content的时候需要在length字段的基础上往前偏移2个字节跳过heade字段。</p>
<p>关于 <code>LengthFieldBasedFrameDecoder</code> 构造函数的示例用法我们先将这么多，下来举一个示例我们看看实际中的使用：</p>
<p>既然我们知道了LengthFieldBasedFrameDecoder处理的是带有消息头和消息体的消息类型，那么我们完全可以来定义一个我们自己的消息，我们来写一个消息类：</p>
<pre><code class="java">public class Message &#123;

    //消息类型
    private byte type;

    //消息长度
    private int length;

    //消息体
    private String msgBody;

    public Message(byte type, int length, String msgBody) &#123;
        this.type = type;
        this.length = length;
        this.msgBody = msgBody;
    &#125;

    public byte getType() &#123;
        return type;
    &#125;

    public void setType(byte type) &#123;
        this.type = type;
    &#125;

    public int getLength() &#123;
        return length;
    &#125;

    public void setLength(int length) &#123;
        this.length = length;
    &#125;

    public String getMsgBody() &#123;
        return msgBody;
    &#125;

    public void setMsgBody(String msgBody) &#123;
        this.msgBody = msgBody;
    &#125;
&#125;
</code></pre>
<p>我们先来写服务端：</p>
<pre><code class="java">public class NewServer &#123;
    private static final int MAX_FRAME_LENGTH = 1024 * 1024;
    private static final int LENGTH_FIELD_LENGTH = 4;
    private static final int LENGTH_FIELD_OFFSET = 1;
    private static final int LENGTH_ADJUSTMENT = 0;
    private static final int INITIAL_BYTES_TO_STRIP = 0;

    private int port;

    public NewServer(int port) &#123;
        this.port = port;
    &#125;

    public void start()&#123;
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try &#123;
            ServerBootstrap sbs = new ServerBootstrap()
                    .group(bossGroup,workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .localAddress(new InetSocketAddress(port))
                    .childHandler(new NewServerChannelInitializer(MAX_FRAME_LENGTH,LENGTH_FIELD_LENGTH,LENGTH_FIELD_OFFSET,LENGTH_ADJUSTMENT,INITIAL_BYTES_TO_STRIP))
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);

            ChannelFuture future = sbs.bind(port).sync();

            System.out.println(&quot;Server start listen at &quot; + port );
            future.channel().closeFuture().sync();
        &#125; catch (Exception e) &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        NewServer server = new NewServer(7788);
        server.start();
    &#125;

&#125;
</code></pre>
<p>注意到服务端我们在上面定义了5个参数，这5个参数是为了传入LengthFieldBasedFrameDecoder里面用的，因为我们的LengthFieldBasedFrameDecoder写在了NewServerChannelInitializer类里面，所以这几个参数采用可配置的方式也更符合可扩展性，我们分别说一下这几个参数定值的含义：</p>
<ul>
<li>MAX_FRAME_LENGTH = 1024 * 1024 ：这个没什么说的，消息体的最大长度；</li>
<li>LENGTH_FIELD_LENGTH = 4 ：指的就是我们的Message类中的length的长度，int占4位</li>
<li>LENGTH_FIELD_OFFSET = 1 ：偏移多少位之后才是我们的消息体，因为我们消息头只有type一个参数，byte类型占1位，所以是1；</li>
<li>LENGTH_ADJUSTMENT = 0 ：该字段加长度字段等于数据帧的长度，一般数据帧长度都是这样定义(即我们在设置Message中的length属性)，加入你的消息体是20位，再加上</li>
<li>LENGTH_FIELD_LENGTH就是24位，所以在此处为了正确的解析出消息体，需要偏移4位才能解析出消息体的正确位置，我们在发送的消息里面设置的就是消息体本身的长度，所以无需偏移。</li>
<li>INITIAL_BYTES_TO_STRIP = 0 ：这里我们也不需要跳过数据帧中的字节数，因为我们的消息体和长度是分别发送的，详情见下面EnCoder代码。</li>
</ul>
<p>然后我们写ChannelInitializer：</p>
<pre><code class="java">public class NewServerChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;
    private  final int MAX_FRAME_LENGTH;
    private  final int LENGTH_FIELD_LENGTH;
    private  final int LENGTH_FIELD_OFFSET;
    private  final int LENGTH_ADJUSTMENT;
    private  final int INITIAL_BYTES_TO_STRIP;

    public NewServerChannelInitializer(int MAX_FRAME_LENGTH, int LENGTH_FIELD_LENGTH, int LENGTH_FIELD_OFFSET, int LENGTH_ADJUSTMENT, int INITIAL_BYTES_TO_STRIP) &#123;
        this.MAX_FRAME_LENGTH = MAX_FRAME_LENGTH;
        this.LENGTH_FIELD_LENGTH = LENGTH_FIELD_LENGTH;
        this.LENGTH_FIELD_OFFSET = LENGTH_FIELD_OFFSET;
        this.LENGTH_ADJUSTMENT = LENGTH_ADJUSTMENT;
        this.INITIAL_BYTES_TO_STRIP = INITIAL_BYTES_TO_STRIP;
    &#125;

    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
        ChannelPipeline pipeline = socketChannel.pipeline();

        pipeline.addLast(new NewDecoder(MAX_FRAME_LENGTH,LENGTH_FIELD_LENGTH,LENGTH_FIELD_OFFSET,LENGTH_ADJUSTMENT,INITIAL_BYTES_TO_STRIP,false));
        // 自己的逻辑Handler
        pipeline.addLast(&quot;handler&quot;, new NewServerHandler());
    &#125;

&#125;
</code></pre>
<p>上面用到了我们自己写的Decoder，接下来定义一个Decoder，继承LengthFieldBasedFrameDecoder，以方便我们做一些改写：</p>
<pre><code class="java">public class NewDecoder extends LengthFieldBasedFrameDecoder &#123;

    /**
     * 我们在Message类中定义了type和length，这都放在消息头部
     * type占1个字节，length占4个字节所以头部总长度是5个字节
     */
    private static final int HEADER_SIZE = 5;
    private byte type;
    private int length;
    private String msgBody;


    /**
     *
     * @param maxFrameLength   网络字节序，默认为大端字节序
     * @param lengthFieldOffset 消息中长度字段偏移的字节数
     * @param lengthFieldLength 数据帧的最大长度
     * @param lengthAdjustment 该字段加长度字段等于数据帧的长度
     * @param initialBytesToStrip 从数据帧中跳过的字节数
     * @param failFast 如果为true，则表示读取到长度域，TA的值的超过maxFrameLength，就抛出一个 TooLongFrameException
     */
    public NewDecoder(int maxFrameLength, int lengthFieldOffset,
                      int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip,
                      boolean failFast) &#123;
        super(maxFrameLength, lengthFieldOffset, lengthFieldLength,
                lengthAdjustment, initialBytesToStrip, failFast);
    &#125;

    @Override
    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception &#123;
        if(in == null)&#123;
            return null;
        &#125;
        if(in.readableBytes() &lt; HEADER_SIZE)&#123;
            throw new Exception(&quot;错误的消息&quot;);
        &#125;

        /**
         * 通过源码我们能看到在读的过程中
         * 每读一次读过的字节即被抛弃
         * 即指针会往前跳
         */
        type = in.readByte();

        length = in.readByte();


        if(in.readableBytes() &lt; length)&#123;
            throw new Exception(&quot;消息不正确&quot;);
        &#125;

        ByteBuf buf = in.readBytes(length);
        byte[] b = new byte[buf.readableBytes()];
        buf.readBytes(b);

        msgBody = new String(b,&quot;UTF-8&quot;);
        Message msg = new Message(type,length,msgBody);
        return msg;
    &#125;
&#125;
</code></pre>
<p>在上面的NewDecoder中有一个HEADER_SIZE-消息头。上面也解释过了，我们在Message中定义的type和length分别占一个字节和4个字节（别问我为啥是4个哈）。所以我们的消息头就是5个字节啦。</p>
<p>接下来就是服务端的handler了：</p>
<pre><code class="java">public class NewServerHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123;

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, Object o) throws Exception &#123;
        if(o instanceof Message) &#123;
            Message msg = (Message)o;
            System.out.println(&quot;Client-&gt;Server:&quot;+channelHandlerContext.channel().remoteAddress()+&quot; send &quot;+msg.getMsgBody());
        &#125;
    &#125;
&#125;
</code></pre>
<p>在handler中我们用来接收已经被NewDecoder解码过后的客户端发送过来的消息。</p>
<p>下面是客户端：</p>
<pre><code class="java">public class NewClient &#123;

    private  int port;
    private  String address;

    public NewClient(int port,String address) &#123;
        this.port = port;
        this.address = address;
    &#125;

    public void start()&#123;
        EventLoopGroup group = new NioEventLoopGroup();

        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(group)
                .channel(NioSocketChannel.class)
                .option(ChannelOption.TCP_NODELAY, true)
                .handler(new NewClientChannelInitializer());

        try &#123;
            ChannelFuture future = bootstrap.connect(address,port).sync();
            future.channel().closeFuture().sync();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            group.shutdownGracefully();
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        NewClient client = new NewClient(7788,&quot;127.0.0.1&quot;);
        client.start();
    &#125;
&#125;
</code></pre>
<p>客户端Initializer：</p>
<pre><code class="java">public class NewClientChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;

    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
        ChannelPipeline pipeline = socketChannel.pipeline();

        pipeline.addLast(new NewEncoder());
        pipeline.addLast(new NewClientHandler());
    &#125;
&#125;
</code></pre>
<p>客户端中我们又定义了一个编码器NewEncoder，继承了MessageToByteEncoder，该类用于将文本信息转换为流：</p>
<pre><code class="java">public class NewEncoder extends MessageToByteEncoder&lt;Message&gt; &#123;

    @Override
    protected void encode(ChannelHandlerContext channelHandlerContext, Message message, ByteBuf byteBuf) throws Exception &#123;
        if(message == null)&#123;
            throw new Exception(&quot;未获得消息内容&quot;);
        &#125;


        String msgBody = message.getMsgBody();
        byte[] b = msgBody.getBytes(Charset.forName(&quot;utf-8&quot;));
        byteBuf.writeByte(message.getType());
        byteBuf.writeByte(b.length);
        byteBuf.writeBytes(b);


    &#125;
&#125;
</code></pre>
<p>接下来是我们的客户端handler：</p>
<pre><code class="java">public class NewClientHandler extends ChannelInboundHandlerAdapter &#123;

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
        String m = &quot;你好啊,Netty。昂昂&quot;;
        Message msg = new Message((byte)0xCA, m.length(), m);
        ctx.writeAndFlush(msg);
    &#125;
&#125;
</code></pre>
<p>注意到在handler中我们发送了一个Message对象。然后会由NewEncoder编码发送出去，服务端对消息解码获得消息头和消息体。分别启动服务端和客户端,我们的消息就发送出去了。</p>
<h1 id="自定义编解码器-LengthFieldBasedFrameDecoder"><a href="#自定义编解码器-LengthFieldBasedFrameDecoder" class="headerlink" title="自定义编解码器 LengthFieldBasedFrameDecoder"></a>自定义编解码器 LengthFieldBasedFrameDecoder</h1><p>首先我们自定义了一个消息体：</p>
<pre><code class="java">public class MsgReq &#123;

    private byte type;

    private int length;

    private String content;


&#125;
</code></pre>
<p>包含3个字段。</p>
<p>发送消息出去的时候肯定是要将对象转为 byte 发送，所以需要一个消息编码器，我们继承 MessageToByteEncoder 来实现编码器：</p>
<pre><code class="java">package com.zhangkx.learn.packageEvent5;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToByteEncoder;

import java.nio.charset.StandardCharsets;

/**
 * @author zhangkx
 * @date 2020-05-14
 * @Desc 自定义编码器
 */
public class MyProtocolEncoder extends MessageToByteEncoder &#123;



    @Override
    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception &#123;
        MsgReq req = (MsgReq) msg;
        out.writeByte(req.getType());
        out.writeInt(req.getLength());
        out.writeBytes(req.getContent().getBytes(StandardCharsets.UTF_8));
    &#125;
&#125;
</code></pre>
<p>即将 MsgReq 对象转为对应的 byte 发送。</p>
<p>发送出去的是 byte 字节，对应的解码器应该是将 byte 转为对象。自然解码器应该是继承 ByteToMessageDecoder。我们的目的不是自己实现一个完完全全的自定义解码器，而是在消息长度解码器的基础上完成对象解析的工作，所以解码器如下：</p>
<pre><code class="java">package com.zhangkx.learn.packageEvent5;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;

import java.nio.charset.StandardCharsets;

/**
 * @author zhangkx
 * @date 2020-05-14
 * @Desc 自定义解码器
 */
public class MyProtocolDecoder extends LengthFieldBasedFrameDecoder &#123;


    /**
     * @param maxFrameLength      帧的最大长度
     * @param lengthFieldOffset   length字段偏移的地址
     * @param lengthFieldLength   length字段所占的字节长
     * @param lengthAdjustment    修改帧数据长度字段中定义的值，可以为负数 因为有时候我们习惯把头部记入长度,若为负数,则说明要推后多少个字段
     * @param initialBytesToStrip 解析时候跳过多少个长度
     * @param failFast            为true，当frame长度超过maxFrameLength时立即报TooLongFrameException异常，为false，读取完整个帧再报异
     */
    public MyProtocolDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength,
                             int lengthAdjustment, int initialBytesToStrip, boolean failFast) &#123;
        super(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip, failFast);
    &#125;


    @Override
    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception &#123;
        //在这里调用父类的方法
        in = (ByteBuf) super.decode(ctx, in);
        if (in == null) &#123;
            return null;
        &#125;
        //读取type字段
        byte type = in.readByte();
        //读取length字段
        int length = in.readInt();
        if (in.readableBytes() != length) &#123;
            throw new RuntimeException(&quot;长度与标记不符&quot;);
        &#125;
        //读取body
        byte[] bytes = new byte[in.readableBytes()];
        in.readBytes(bytes);
        return MsgReq.builder().length(length).type(type).content(new String(bytes, StandardCharsets.UTF_8)).build();
    &#125;
&#125;
</code></pre>
<p>通过这种方式，我们只用约定好消息的最大长度，比如一条消息超过多少字节就拒收，约定好消息长度字段所占的字节，一般来说int类型4个字节足够。剩下的几个参数都无需设置，按照约定的消息格式进行解析即可。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/netty/" rel="tag"># netty</a>
              <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"># 网络编程</a>
              <a href="/tags/I-O/" rel="tag"># I/O</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/01/netty-12-TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85/" rel="prev" title="netty#12-TCP粘包拆包">
      <i class="fa fa-chevron-left"></i> netty#12-TCP粘包拆包
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/03/%E8%AE%A4%E8%AF%86Jetty/" rel="next" title="认识Jetty">
      认识Jetty <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LineBasedFrameDecoder"><span class="nav-text">LineBasedFrameDecoder</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FixedLengthFrameDecoder"><span class="nav-text">FixedLengthFrameDecoder</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DelimiterBasedFrameDecoder"><span class="nav-text">DelimiterBasedFrameDecoder</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LengthFieldBasedFrameDecoder"><span class="nav-text">LengthFieldBasedFrameDecoder</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8-LengthFieldBasedFrameDecoder"><span class="nav-text">自定义编解码器 LengthFieldBasedFrameDecoder</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="摘星"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">摘星</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">139</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangkexuan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkexuan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/kexuan_zhang@qq.com" title="E-Mail → kexuan_zhang@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">摘星</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/clicklove.js"></script>
